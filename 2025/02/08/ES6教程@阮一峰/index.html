<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>📖ES6 教程 @阮一峰 | 川一土的博客视界</title><meta name="author" content="yiTuChuan"><meta name="copyright" content="yiTuChuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="深入讲解 ES6+ 的核心特性，包括 Set&#x2F;Map 集合、Symbol 类型（略）、Proxy&#x2F;Reflect 元编程、Iterator 迭代器、Generator 生成器、ArrayBuffer 二进制数组（略）等高级概念。通过丰富的代码示例和原理解析，帮助读者掌握现代 JavaScript 的重要语言特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="📖ES6 教程 @阮一峰">
<meta property="og:url" content="https://zhengzehua.top/2025/02/08/ES6%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/index.html">
<meta property="og:site_name" content="川一土的博客视界">
<meta property="og:description" content="深入讲解 ES6+ 的核心特性，包括 Set&#x2F;Map 集合、Symbol 类型（略）、Proxy&#x2F;Reflect 元编程、Iterator 迭代器、Generator 生成器、ArrayBuffer 二进制数组（略）等高级概念。通过丰富的代码示例和原理解析，帮助读者掌握现代 JavaScript 的重要语言特性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhengzehua.top/images/butterfly_avatar_img.svg">
<meta property="article:published_time" content="2025-02-08T10:21:02.000Z">
<meta property="article:modified_time" content="2025-06-05T07:36:03.275Z">
<meta property="article:author" content="yiTuChuan">
<meta property="article:tag" content="前端学习,前端开发,Web开发,技术分享,学习感悟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhengzehua.top/images/butterfly_avatar_img.svg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "📖ES6 教程 @阮一峰",
  "url": "https://zhengzehua.top/2025/02/08/ES6%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/",
  "image": "https://zhengzehua.top/images/butterfly_avatar_img.svg",
  "datePublished": "2025-02-08T10:21:02.000Z",
  "dateModified": "2025-06-05T07:36:03.275Z",
  "author": [
    {
      "@type": "Person",
      "name": "yiTuChuan",
      "url": "https://github.com/Nasir1423"
    }
  ]
}</script><link rel="shortcut icon" href="/images/butterfly_favicon.svg"><link rel="canonical" href="https://zhengzehua.top/2025/02/08/ES6%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="VS0CYuuxqYH1AjmSVIi39UiBz0ubcCCtUtHMiSsRQXA"/><meta name="msvalidate.01" content="3C21ED06CE83FA63D0A6E0ADE00F1DEE"/><link rel="stylesheet" href="/css/index.css?v=5.4.0-b2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-JRLJPHP21V"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-JRLJPHP21V')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-JRLJPHP21V', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '📖ES6 教程 @阮一峰',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/styles/minimal.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/butterfly_avatar_img.svg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 实用站点</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to top, #2980b9, #6dd5fa, #ffffff);;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/butterfly_nav_logo.svg" alt="Logo"><span class="site-name">川一土的博客视界</span></a><a class="nav-page-title" href="/"><span class="site-name">📖ES6 教程 @阮一峰</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 实用站点</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">📖ES6 教程 @阮一峰</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-08T10:21:02.000Z" title="发表于 2025-02-08 18:21:02">2025-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-05T07:36:03.275Z" title="更新于 2025-06-05 15:36:03">2025-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/ES6/">ES6</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Set-Map">Set &amp; Map</h2>
<h3 id="1-Set">1. Set</h3>
<ol>
<li>
<p>解释：类似数组，但是<strong>成员值唯一</strong>的数据结构。成员值重复判断的算法为 Same-value equality，类似 <code>===</code> 运算符。</p>
<blockquote>
<p>注：Same-value equality 认为 NaN 等于自身，但是 <code>===</code> 认为 NaN 不等于自身。</p>
</blockquote>
</li>
<li>
<p>初始化</p>
<ul>
<li>
<p>方法一：创建空 <code>Set</code>，使用 <code>.add()</code> 添加成员</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">x</span> =&gt;</span> set.<span class="title function_">add</span>(x));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二：接受数组或实现了 Iterable 接口的数据结构作为参数，创建 <code>Set</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>实例属性和方法</p>
<ul>
<li>
<p>属性</p>
<ul>
<li>
<p><code>.constructor</code> 构造函数，即 Set 函数。</p>
</li>
<li>
<p><code>.size</code> Set 实例的成员总数。</p>
</li>
</ul>
</li>
<li>
<p>操作方法</p>
<ul>
<li>
<p><code>.add(value): Set</code> 添加某个值，返回 Set 实例本身，因此可以链式调用。</p>
</li>
<li>
<p><code>.delete(value): boolean</code> 删除某个值，返回一个布尔值，表示删除是否成功。</p>
</li>
<li>
<p><code>.has(value): boolean</code> 返回一个布尔值，表示该值是否为 Set 实例的成员。</p>
</li>
<li>
<p><code>.clear(): void</code> 清除所有成员，没有返回值。</p>
</li>
</ul>
</li>
<li>
<p>遍历方法：Set 的<strong>遍历顺序就是插入顺序</strong></p>
<blockquote>
<p>注-1：<code>.keys()</code> 方法和 <code>.values()</code> 方法的行为完全一致，因为 Set 的键名和键值是相同的。</p>
<p>注-2：遍历器可以使用 <code>for...of</code> 遍历。</p>
<p>注-3：Set 实例默认可以遍历，其默认遍历器生成函数即其 <code>.values()</code> 方法。</p>
<p>注-4：可以对 <code>.key()</code>、<code>.values()</code>、<code>.entries()</code> 返回的遍历器使用扩展运算符 <code>...</code>，快速转换为数组。</p>
</blockquote>
<ul>
<li><code>.keys()</code> 返回键名的遍历器。</li>
<li><code>.values()</code> 返回键值的遍历器。</li>
<li><code>.entries()</code> 返回键值对的遍历器。</li>
<li><code>.forEach((value, key, set) =&gt; &#123;&#125;, thisArg)</code> 使用回调函数遍历每个成员。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>应用场景：数组去重。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line">array = [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]; <span class="comment">// 方法一（...扩展运算符内部使用了 for...of 循环遍历 Set 结构）</span></span><br><span class="line">array = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array)); <span class="comment">// 方法二</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-WeakSet">2. WeakSet</h3>
<ol>
<li>
<p>解释：与 Set 类似，但是<strong>成员类型只能是对象</strong>，且为<strong>弱引用</strong>，即只要其他对象都不引用该对象，那么 GC 会自动回收该对象所占用的内存，而不考虑该对象是否还存在于 WeakSet 之中。由于 WeakSet 内部有多少个成员，取决于 GC 有没有运行，运行前后很可能成员个数是不一样的，而 GC 何时运行是不可预测的，因此 ES6 规定 WeakSet <strong>不可遍历</strong>。</p>
</li>
<li>
<p>与 Set 的区别</p>
<ul>
<li>没有 <code>.size</code> 属性。</li>
<li>没有 <code>.clear()</code> 方法。</li>
<li>没有 <code>.keys()</code>、<code>.values()</code> 等遍历方法。</li>
</ul>
</li>
<li>
<p>应用场景</p>
<ul>
<li>
<p>DOM 节点的存储。当 DOM 节点从文档移除时，不用担心会引发内存泄漏。</p>
</li>
<li>
<p>确保实例方法只能在实例上调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        foos.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">method</span> () &#123;</span><br><span class="line">        <span class="keyword">if</span> (!foos.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在 Foo 的实例上调用！&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="3-Map">3. Map</h3>
<ol>
<li>
<p>解释：类似对象，但加强版，<strong>允许任意类型的值作为键</strong>的数据结构。</p>
<blockquote>
<p>注：对于 number、string、boolean 类型的键，Map 需要通过严格相等判断是否为同一个键；true 和 ‘true’ 被认为是两个不同的键；undefined 和 null 被认为是两个不同的键；NaN 及其自身被认为是相同的键。</p>
</blockquote>
</li>
<li>
<p>初始化</p>
<ul>
<li>
<p>方法一：创建空 <code>Map</code>，使用 <code>.set(key, value)</code> 添加键值对</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;;</span><br><span class="line">map1.<span class="title function_">set</span>(person, <span class="string">`<span class="subst">$&#123;person.name&#125;</span>-<span class="subst">$&#123;person.age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二：接受数组（成员为长度为 2 的数组）或实现了 Iterable 接口的数据结构（成员为长度为 2 的数组）作为参数，创建 <code>Map</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>, <span class="number">19</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>实例属性和方法</p>
<ul>
<li>
<p>属性</p>
<ul>
<li><code>.constructor</code> 构造函数，即 Map 函数。</li>
<li><code>.size</code> 性返回 Map 结构的成员总数</li>
</ul>
</li>
<li>
<p>操作方法</p>
<ul>
<li><code>.set(key, value): Map</code> 设置键名 key 对应的键值为 value ，然后返回整个 Map 结构，因此可以链式调用。如果 key 已经有值，则键值会被更新，否则就新生成该键。</li>
<li><code>.get(key): any</code> 法读取 key 对应的键值，如果找不到 key ，返回 undefined。</li>
<li><code>.has(key): boolean</code> 返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>.delete(key): boolean</code> 删除某个键，返回 true。如果删除失败，返回 false。</li>
<li><code>.clear(): void</code> 清除所有成员，没有返回值。</li>
</ul>
</li>
<li>
<p>遍历方法：Map 的<strong>遍历顺序就是插入顺序</strong></p>
<blockquote>
<p>注-1：遍历器可以使用 <code>for...of</code> 遍历。</p>
<p>注-2：Map 实例默认可以遍历，其默认遍历器生成函数即其 <code>.entries()</code> 方法。</p>
<p>注-3：可以对 <code>.key()</code>、<code>.values()</code>、<code>.entries()</code> 返回的遍历器使用扩展运算符 <code>...</code>，快速转换为数组。</p>
</blockquote>
<ul>
<li><code>.keys()</code> 返回键名的遍历器。</li>
<li><code>.values()</code> 返回键值的遍历器。</li>
<li><code>.entries()</code> 返回键值对的遍历器。</li>
<li><code>.forEach((value, key, map) =&gt; &#123;&#125;, thisArg)</code> 使用回调函数遍历每个成员。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-WeakMap">4. WeakMap</h3>
<ol>
<li>
<p>解释：与 Map 类似，但是<strong>键的类型只能是对象</strong>（null 除外），且为<strong>弱引用</strong>，即只要所引用的对象的其他引用都被清除，GC 就会释放该对象所占用的内存，WeakMap 里面的键名对象和所对应的键值对会自动消失。</p>
<blockquote>
<p>注：WeakMap 的键值为<strong>正常引用</strong>，不会因为键名被回收而被消除。</p>
</blockquote>
</li>
<li>
<p>与 Map 的区别</p>
<ul>
<li>没有 <code>.size</code> 属性。</li>
<li>没有 <code>.clear()</code> 方法。</li>
<li>没有 <code>.keys()</code>、<code>.values()</code> 等遍历方法。</li>
</ul>
</li>
<li>
<p>应用场景</p>
<ul>
<li>
<p>为 DOM 节点附加描述信息。当 DOM 节点从文档移除时，不用担心会引发内存泄漏。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">myWeakmap.<span class="title function_">set</span>(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line">myElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> logoData = myWeakmap.<span class="title function_">get</span>(myElement);</span><br><span class="line">    logoData.<span class="property">timesClicked</span>++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>部署私有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">        _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">        _action.<span class="title function_">set</span>(<span class="variable language_">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = _counter.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        counter--;</span><br><span class="line">        _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">        <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">            _action.<span class="title function_">get</span>(<span class="variable language_">this</span>)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Countdown</span>(<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>));</span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="Symbol">Symbol</h2>
<p>More in <a target="_blank" rel="noopener" href="https://netmarket.oss.aliyuncs.com/35cdb5c1-9e70-4562-a245-2664416d784b.pdf">阮一峰 ES6（第三版）</a></p>
<h2 id="Reflect">Reflect</h2>
<h3 id="1-简要概述">1. 简要概述</h3>
<ol>
<li>
<p>解释：Reflect 是 ES6 引入的一个新的<strong>全局对象</strong>，提供了一系列用于<strong>操作对象</strong>的方法。</p>
</li>
<li>
<p>设计目的</p>
<ul>
<li>
<p>将一些明显属于<strong>语言内部</strong>的方法（如 <code>Object.defineProperty</code>）放到 Reflect 对象上。</p>
</li>
<li>
<p>修改某些 Object 方法的返回结果，使其更<strong>合理</strong>。如 <code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一 个错误，而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code>。</p>
</li>
<li>
<p>让 Object 操作都变成<strong>函数行为</strong>。如 <code>name in obj</code> 和 <code>delete obj[name]</code> ，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为。</p>
</li>
<li>
<p>保持与 Proxy 对象的方法一一对应。Proxy 对象修改默认行为，而 Reflect 对象执行默认行为。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-静态方法">2. 静态方法</h3>
<ol>
<li>
<p><code>Reflect.get(target, name[, receiver])</code></p>
<ul>
<li>
<p>历史方法 <code>target[name]</code></p>
</li>
<li>
<p>使用说明</p>
<ul>
<li>查找并返回 <code>target</code> 对象的 <code>name</code> 属性，如果没有该属性，则返回 <code>undefined</code>。</li>
<li><code>receiver</code> 用于指定 <code>target</code> 对象中的 <code>getter</code> 属性的 <code>this</code>。</li>
<li>如果第一个参数不是对象， <code>Reflect.get</code> 方法会报错。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Reflect.set(target, name, value[, receiver])</code></p>
</li>
</ol>
<ul>
<li>历史方法 <code>target[name] = value</code></li>
<li>使用说明
<ul>
<li>设置 <code>target</code> 对象的 <code>name</code> 属性等于 <code>value</code>。</li>
<li><code>receiver</code> 用于指定 <code>target</code> 对象中的 <code>setter</code> 属性的 <code>this</code>。</li>
<li>如果第一个参数不是对象， <code>Reflect.set</code> 会报错。</li>
<li><code>Reflect.set</code>（需要使用 <code>receiver</code> 参数）会触发 <code>Proxy.defineProperty</code> 拦截。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>Reflect.has(obj, name): boolean</code></li>
</ol>
<ul>
<li>历史方法 <code>name in obj</code></li>
<li>使用说明
<ul>
<li>检查指定的属性是否存在于指定的<strong>对象或其原型链</strong>中，包括<strong>不可枚举</strong>属性。</li>
<li>如果第一个参数不是对象， <code>Reflect.has</code> 和 <code>in</code> 运算符都会报错。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><code>Reflect.deleteProperty(target, name): boolean</code></li>
</ol>
<ul>
<li>历史方法 <code>delete obj[name]</code></li>
<li>使用说明：删除对象的属性，返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回 <code>true</code> ； 删除失败，被删除的属性依然存在，返回 <code>false</code>。</li>
</ul>
<ol start="5">
<li><code>Reflect.construct(target, args)</code></li>
</ol>
<ul>
<li>历史方法 <code>new target(...args)</code></li>
<li>使用说明：提供了一种不使用 <code>new</code> ，来调用构造函数的方法。</li>
</ul>
<ol start="6">
<li><code>Reflect.getPrototypeOf(obj)</code></li>
</ol>
<ul>
<li>历史方法  <code>Object.getPrototypeOf(obj)</code></li>
<li>使用说明
<ul>
<li>读取对象的 <code>__proto__</code> 属性。</li>
<li><code>Reflect.getPrototypeOf</code> 和 <code>Object.getPrototypeOf</code> 的一个区别是，如果参数不是对象， <code>Object.getPrototypeOf</code> 会将这个参数转为对象，然后再运行， 而 <code>Reflect.getPrototypeOf</code> 会报错。</li>
</ul>
</li>
</ul>
<ol start="7">
<li><code>Reflect.setPrototypeOf(obj, newProto)</code></li>
</ol>
<ul>
<li>历史方法 <code>Object.setPrototypeOf(obj, newProto)</code></li>
<li>使用说明
<ul>
<li>设置对象的 <code>__proto__</code> 属性，返回第一个参数对象。</li>
<li>如果第一个参数不是对象， <code>Object.setPrototypeOf</code> 会返回第一个参数本身， 而 <code>Reflect.setPrototypeOf</code> 会报错。</li>
<li>如果第一个参数 是 <code>undefined</code> 或 <code>null</code> ， <code>Object.setPrototypeOf</code> 和 <code>Reflect.setPrototypeOf</code> 都会报错。</li>
</ul>
</li>
</ul>
<ol start="8">
<li>
<p><code>Reflect.apply(func, thisArg, args)</code></p>
<ul>
<li>
<p>历史方法 <code>Function.prototype.apply.call(func, thisArg, args)</code></p>
<blockquote>
<p>注：这里的 <code>args</code> 为传递给 <code>func</code> 的参数数组。</p>
</blockquote>
</li>
<li>
<p>使用说明</p>
<ul>
<li>绑定 <code>this</code>，然后执行给定函数。</li>
<li>当函数自定义了 <code>apply</code> 方法时，直接调用 <code>fn.apply(thisArg, args)</code> 将无法正确执行函数并绑定 <code>this</code> 值。此时应使用 <code>Function.prototype.apply.call(func, thisArg, args)</code> 来确保调用原始的 <code>apply</code> 方法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Reflect.defineProperty(target, propertyKey, attributes): boolean</code></p>
<ul>
<li>历史方法 <code>Object.defineProperty(target, propertyKey, attributes)</code></li>
<li>使用说明
<ul>
<li>为对象定义属性。</li>
<li>如果 <code>Reflect.defineProperty</code> 的第一个参数不是对象，就会抛出错误。</li>
<li><code>Reflect.defineProperty</code> 返回一个布尔值，表示属性是否定义成功。<code>Object.defineProperty</code> 在失败时会抛出异常。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code></p>
<ul>
<li>历史方法 <code>Object.getOwnPropertyDescriptor(target, propertyKey)</code></li>
<li>使用说明
<ul>
<li>得到指定属性的描述对象。</li>
<li>如果第一个参数不是对象， <code>Object.getOwnPropertyDescriptor</code> 不报错，返回 <code>undefined</code> ，而 <code>Reflect.getOwnPropertyDescriptor</code> 会抛出错误，表示参数非法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Reflect.isExtensible(target): boolean</code></p>
<ul>
<li>历史方法 <code>Object.isExtensible(target)</code></li>
<li>使用说明
<ul>
<li>返回一个布尔值， 表示当前对象是否可扩展（即是否可以添加新属性）。</li>
<li>如果参数不是对象，<code>Object.isExtensible</code> 会返回 <code>false</code> ，因为非对象本来就是不可扩展的，而 <code>Reflect.isExtensible</code> 会报错。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Reflect.preventExtensions(target): boolean</code></p>
<ul>
<li>历史方法 <code>Object.preventExtensions(target)</code></li>
<li>使用说明
<ul>
<li>让一个对象变为不可扩展，返回一个布尔值，表示是否操作成功。</li>
<li>如果参数不是对象， <code>Object.preventExtensions</code> 在 ES5 环境报错，在 ES6 环境返回传入的参数，而 <code>Reflect.preventExtensions</code> 会报错。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Reflect.ownKeys(target)</code></p>
<ul>
<li>历史方法 <code>Object.getOwnPropertyNames</code> + <code>Object.getOwnPropertySymbols</code></li>
<li>使用说明
<ul>
<li>返回对象的所有属性（包括不可枚举属性）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-应用：观察者模式">3. 应用：观察者模式</h3>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = (<span class="params">fn</span>) =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = (<span class="params">obj</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; set &#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123; <span class="comment">// 观察目标</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123; <span class="comment">// 观察者</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observe</span>(print); <span class="comment">// 一旦观察目标改变，观察者对应的函数会被调用</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;李四&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Proxy">Proxy</h2>
<h3 id="1-简要概述-2">1. 简要概述</h3>
<ol>
<li>
<p>解释：为特定对象设置“拦截”的<strong>数据结构</strong>，可以对外界对该对象的访问进行过滤或改写。</p>
</li>
<li>
<p>实例化</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这里的 <code>target</code> 表示要拦截的目标对象，<code>handler</code> 参数用来定制拦截行为。当对 <code>proxy</code> 对象进行操作时，<code>handler</code> 中定义的拦截行为才会生效。</p>
</blockquote>
</li>
</ol>
<h3 id="2-拦截操作">2. 拦截操作</h3>
<ol>
<li>
<p><code>get(target, propKey, receiver)</code></p>
<ul>
<li>
<p>解释：拦截对象属性的读取，如 <code>proxy.foo</code>、<code>proxy['foo']</code>。</p>
</li>
<li>
<p>使用说明：如果一个属性不可配置（configurable）和不可写（writable），则该属性<strong>不能被代理</strong>，通过 Proxy 对象访问该属性会报错。</p>
</li>
<li>
<p>应用</p>
<ul>
<li>
<p>访问目标对象不存在的属性时抛错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">return</span> target[property];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Property \&quot;&quot;</span> + property + <span class="string">&quot;\&quot; do</span></span><br><span class="line"><span class="string">                                     es not exist.&quot;</span>);</span><br><span class="line">                                     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>允许负数索引访问数组元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> target = [];</span><br><span class="line">    target.<span class="title function_">push</span>(...elements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实现函数名的链式调用，前一个函数的返回值作为后一个函数的参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> funcStack = [];</span><br><span class="line">        <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fnName === <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> funcStack.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">val, fn</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="title function_">fn</span>(val);</span><br><span class="line">                        &#125;, value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    funcStack.<span class="title function_">push</span>(<span class="variable language_">window</span>[fnName]);</span><br><span class="line">                    <span class="keyword">return</span> oproxy;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> oproxy;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">double</span> = (<span class="params">n</span>) =&gt; n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">pow</span> = (<span class="params">n</span>) =&gt; n * n;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">reverseInt</span> = (<span class="params">n</span>) =&gt; n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line"><span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">reverseInt</span>.<span class="property">get</span>; <span class="comment">// 63</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成 DOM 结构的通用函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(property);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(attrs)) &#123;</span><br><span class="line">                el.<span class="title function_">setAttribute</span>(prop, attrs[prop]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                    child = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">                el.<span class="title function_">appendChild</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> el;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> el = dom.<span class="title function_">div</span>(&#123;&#125;,</span><br><span class="line">                   <span class="string">&#x27;Hello, my name is &#x27;</span>,</span><br><span class="line">                   dom.<span class="title function_">a</span>(&#123;<span class="attr">href</span>: <span class="string">&#x27;//example.com&#x27;</span>&#125;, <span class="string">&#x27;Mark&#x27;</span>),</span><br><span class="line">                   <span class="string">&#x27;. I like:&#x27;</span>,</span><br><span class="line">                   dom.<span class="title function_">ul</span>(&#123;&#125;,</span><br><span class="line">                          dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;The web&#x27;</span>),</span><br><span class="line">                          dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;Food&#x27;</span>),</span><br><span class="line">                          dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;…actually that\&#x27;s it&#x27;</span>)</span><br><span class="line">                         )</span><br><span class="line">                  );</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(el);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>set(target, propKey, value, receiver)</code></p>
<ul>
<li>
<p>解释：拦截对象属性的设置，如 <code>proxy.foo = v</code>、 <code>proxy['foo'] = v</code>。</p>
</li>
<li>
<p>应用</p>
<ul>
<li>
<p>限制对象属性的取值范围，不满足要求时报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于 age 以外的属性，直接保存</span></span><br><span class="line">        obj[prop] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>监听数据变化，自动更新 DOM。</p>
</li>
<li>
<p>禁止内部属性（如以下划线开头的字段）被读取或修改。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>has(target, propKey): boolean</code></p>
<ul>
<li>解释：拦截 <code>propKey in proxy</code>（包括不可枚举和原型链上的属性）的操作，返回一个布尔值。</li>
<li>使用说明
<ul>
<li>如果原对象不可配置或者禁止扩展，这时 <code>has</code> 拦截会报错。</li>
<li>虽然 <code>for...in</code> 循环也用到了 <code>in</code> 运算符，但是 <code>has</code> 拦截 对 <code>for...in</code> 循环不生效。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>deleteProperty(target, propKey): boolean</code></p>
<ul>
<li>解释：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li>
<li>使用说明：如果这个方法抛出错误或者返回 <code>false</code> ，当前属性就无法被 <code>delete</code> 命令删除。</li>
</ul>
</li>
<li>
<p><code>ownKeys(target)</code></p>
<ul>
<li>
<p>解释：拦截 <code>Object.getOwnPropertyNames(proxy)</code> 、 <code>Object.getOwnPropertySymbols (proxy)</code> 、 <code>Object.keys(proxy)</code> ，返回一个数组。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">包含字符串属性</th>
<th style="text-align:center">包含 Symbol 属性</th>
<th style="text-align:center">包含不可枚举属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Object.getOwnPropertyNames()</code></td>
<td style="text-align:center">✅</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center"><code>Object.getOwnPropertySymbols()</code></td>
<td style="text-align:center">❌</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center"><code>Object.keys()</code></td>
<td style="text-align:center">✅</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：使用 <code>Object.keys()</code> 时，<code>Symbol</code> 属性、目标对象上不存在的属性，以及不可枚举的属性会被过滤掉。</p>
</blockquote>
</li>
<li>
<p>使用说明</p>
<ul>
<li><code>ownKeys</code> 方法返回的数组成员，只能是字符串。</li>
<li>如果目标对象自身包含不可配置的属性，则该属性必须被 <code>ownKeys</code> 方法返回，否则报错。</li>
<li>如果目标对象是不可扩展的（non-extensition），这时 <code>ownKeys</code> 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>getOwnPropertyDescriptor(target, propKey)</code></p>
<ul>
<li>解释：拦截 <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
</ul>
</li>
<li>
<p><code>defineProperty(target, propKey, propDesc): boolean</code></p>
<ul>
<li>解释：拦截 <code>Object.defineProperty(proxy, propKey, propDesc)</code> 、 <code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li>使用说明
<ul>
<li>如果目标对象不可扩展（extensible），则 <code>defineProperty</code> 不能增加目标 对象上不存在的属性，否则会报错。</li>
<li>如果目标对象的某个属性不可写 （writable）或不可配置（configurable），则 <code>defineProperty</code> 方法不得改变这两个设置。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>preventExtensions(target): boolean</code></p>
<ul>
<li>解释：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li>使用说明：只有目标对象不可扩展时（即 <code>Object.isExtensible(proxy)</code> 为 <code>false</code>），<code>proxy.preventExtensions</code> 才能返回 <code>true</code>，否则会报错。为了防止出现这个问题，通常要在 <code>proxy.preventExtensions</code> 方法里面，调用一 次 <code>Object.preventExtensions</code> 。</li>
</ul>
</li>
<li>
<p><code>getPrototypeOf(target)</code></p>
<ul>
<li>解释：拦截 <code>Object.getPrototypeOf(proxy)</code> ，返回一个对象。</li>
<li>使用说明：可拦截的情况共包括以下几种情况，
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>isExtensible(target): boolean</code></p>
<ul>
<li>解释：拦截 <code>Object.isExtensible(proxy)</code> ，返回一个布尔值。</li>
<li>使用说明：该方法的返回值必须与目标对象的 <code>isExtensible</code> 属性保持 一致，否则就会抛出错误。即 <code>Object.isExtensible(proxy) === Object.isExtensible(target)</code>。</li>
</ul>
</li>
<li>
<p><code>setPrototypeOf(target, proto): boolean</code></p>
<ul>
<li>解释：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</li>
<li>使用说明：如果目标对象不 可扩展（extensible），<code>setPrototypeOf</code> 方法不得改变目标对象的原型。</li>
</ul>
</li>
<li>
<p><code>apply(target, object, args)</code></p>
<ul>
<li>解释：拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
</ul>
</li>
<li>
<p><code>construct(target, args)</code></p>
<ul>
<li>解释：拦截 Proxy 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</li>
<li>使用说明：<code>construct</code> 方法返回的必须是一个对象，否则会报错。</li>
</ul>
</li>
</ol>
<h3 id="3-可取消的-Proxy">3. 可取消的 Proxy</h3>
<ol>
<li>解释：<code>Proxy.revocable()</code> 方法可以用来创建一个<strong>可撤销的代理对象</strong>。一旦通过调用 <code>revoke</code> 函数撤销了代理，该代理将变得不可用，任何后续对它的操作（如读取、设置属性）都会抛出 <code>TypeError</code>。</li>
<li>作用：精细控制代理对象的生命周期。</li>
<li>语法：<code>let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);</code>
<ul>
<li><code>proxy</code>：Proxy 实例，可以基于拦截规则 <code>handler</code>，拦截对目标对象 <code>target</code> 的访问。</li>
<li><code>revoke</code>：一个不带参数的函数，用于取消该 <code>proxy</code> 实例。</li>
</ul>
</li>
</ol>
<h3 id="4-this-问题">4. this 问题</h3>
<ol>
<li>
<p>解释：当通过 Proxy 实例调用目标对象的方法时，<strong>方法内部的 <code>this</code> 会指向 Proxy 实例本身</strong>，而不是原始的目标对象。这可能导致以下情况：</p>
<ul>
<li>如果方法内部依赖 <code>this</code> 来访问原始对象的属性或方法（尤其是那些未被代理拦截的内部属性或原型链上的方法），可能会出现非预期的行为或错误。</li>
<li>直接在目标对象上调用相同方法时，<code>this</code> 指向目标对象，行为可能与通过代理调用时不同。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this === proxy:&#x27;</span>, <span class="variable language_">this</span> === proxy); <span class="comment">// 检查 this 是否指向 proxy</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this === target:&#x27;</span>, <span class="variable language_">this</span> === target); <span class="comment">// 检查 this 是否指向 target</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;直接调用 target.m():&#x27;</span>);</span><br><span class="line">target.<span class="title function_">m</span>();</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// this === proxy: false</span></span><br><span class="line"><span class="comment">// this === target: true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n通过 proxy.m() 调用:&#x27;</span>);</span><br><span class="line">proxy.<span class="title function_">m</span>();</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// this === proxy: true</span></span><br><span class="line"><span class="comment">// this === target: false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解决：为了确保通过代理调用的方法内部的 <code>this</code> 正确指向原始的目标对象，可以在 <code>get</code> 拦截器中进行处理：</p>
<ul>
<li>当访问的属性是一个函数（方法）时，<strong>使用 <code>Function.prototype.bind()</code> 将该方法的 <code>this</code> 绑定到原始的 <code>target</code> 对象上</strong>。</li>
<li>对于其他类型的属性，可以使用 <code>Reflect.get()</code> 来获取属性值，以保持默认行为。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop, receiver); <span class="comment">// 使用 receiver 来正确处理 getter 等情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 确保只绑定定义在 target 自身或其原型链上的函数</span></span><br><span class="line">            <span class="comment">// 并且该函数确实是 target 的一部分 (避免绑定不相关的函数)</span></span><br><span class="line">            <span class="keyword">return</span> value.<span class="title function_">bind</span>(target); <span class="comment">// 将 this 绑定到原始 target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2025-10-20&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxyDate = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetDate, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyDate.<span class="title function_">getFullYear</span>()); <span class="comment">// 输出: 2025 (this 正确指向 targetDate)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customTarget = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyCustom = <span class="keyword">new</span> <span class="title class_">Proxy</span>(customTarget, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyCustom.<span class="title function_">getValue</span>()); <span class="comment">// 输出: 42 (this 正确指向 customTarget)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-对象属性检测总结">5. 对象属性检测总结</h3>
<p>为了客观准确地对比一系列检测对象属性的方法，这里重点关注以下维度 ① <strong>自有属性 vs. 继承属性</strong>（即属性在对象实例上，还是在原型链上）② <strong>可枚举属性 vs. 不可枚举属性</strong>（即属性是否会出现在 <code>for...in</code> 或 <code>Object.keys()</code> 的结果中）③ <strong>字符串属性 vs. Symbol 属性</strong>（即属性的键是字符串还是 ES6 的 Symbol）④ <strong>安全性与健壮性</strong>（即对象通过 <code>Object.create(null)</code> 创建时，检测方法是否仍然可靠；对象自身是否可以重写检测方法，如 <code>hasOwnProperty</code>）</p>
<ol>
<li><code>Object.prototype.hasOwnProperty.call(obj, prop): boolean</code> 关注<strong>对象自身独有</strong>的属性
<ul>
<li>自有属性 ✅；继承属性 ❌</li>
<li>可枚举属性 ✅；不可枚举属性 ✅</li>
<li>字符串属性 ✅；Symbol 属性 ✅</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
<li><code>Reflect.ownKeys(obj).includes(prop)</code> 关注<strong>对象自身独有</strong>的属性
<ul>
<li>自有属性 ✅；继承属性 ❌</li>
<li>可枚举属性 ✅；不可枚举属性 ✅</li>
<li>字符串属性 ✅；Symbol 属性 ✅</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
<li><code>prop in obj</code> 关注<strong>可访问</strong>的属性
<ul>
<li>自有属性 ✅；继承属性 ✅</li>
<li>可枚举属性 ✅；不可枚举属性 ✅</li>
<li>字符串属性 ✅；Symbol 属性 ✅</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
<li><code>Reflect.has(obj, prop)</code> 关注<strong>可访问</strong>的属性（<code>in</code> 操作符的上位替代）
<ul>
<li>自有属性 ✅；继承属性 ✅</li>
<li>可枚举属性 ✅；不可枚举属性 ✅</li>
<li>字符串属性 ✅；Symbol 属性 ✅</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
<li><code>Object.keys(obj).includes(prop)</code> 关注<strong>对象自身独有、可枚举的字符串</strong>属性
<ul>
<li>自有属性 ✅；继承属性 ❌</li>
<li>可枚举属性 ✅；不可枚举属性 ❌</li>
<li>字符串属性 ✅；Symbol 属性 ❌</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
<li><code>Object.getOwnPropertyNames(obj).includes(prop)</code> 关注<strong>对象自身独有的字符串</strong>属性
<ul>
<li>自有属性 ✅；继承属性 ❌</li>
<li>可枚举属性 ✅；不可枚举属性 ✅</li>
<li>字符串属性 ✅；Symbol 属性 ❌</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
<li><code>Object.getOwnPropertyNames(obj).includes(prop)</code> 关注<strong>对象自身独有的 Symbol</strong> 属性
<ul>
<li>自有属性 ✅；继承属性 ❌</li>
<li>可枚举属性 ✅；不可枚举属性 ✅</li>
<li>字符串属性 ❌；Symbol 属性 ✅</li>
<li>安全性与健壮性 ✅</li>
</ul>
</li>
</ol>
<p>使用建议：</p>
<ul>
<li>
<p>检查自有属性：<code>Object.prototype.hasOwnProperty.call(obj, prop): boolean</code></p>
</li>
<li>
<p>检查属性的可访问性：<code>Reflect.has(obj, prop)</code></p>
</li>
<li>
<p>最常用的场景（对象自有、可枚举、字符串）：<code>Object.keys(obj).includes(prop)</code></p>
</li>
<li>
<p>检测属性是对象独有的，还是继承自父类的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isOwnVsInherited</span>(<span class="params">obj, prop</span>): <span class="string">&quot;own&quot;</span> | <span class="string">&quot;inherited&quot;</span> | <span class="string">&quot;unknown&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, prop)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;own&quot;</span>; <span class="comment">// 对象自由属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, prop)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inherited&quot;</span>; <span class="comment">// 对象原型链上的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span> <span class="comment">// 不存在的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-应用：数据库-ORM">6. 应用：数据库 ORM</h3>
<p>核心思想：利用 Proxy 动态响应不确定的方法名，将其转换为一种具体的、参数化的操作（无论是 API 调用还是 SQL 查询），从而用极少的代码实现强大的动态功能。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- 1. 模拟数据库 ---</span></span><br><span class="line"><span class="comment">// 在真实场景中，这里会是一个数据库连接池和查询执行器</span></span><br><span class="line"><span class="keyword">const</span> db = &#123;</span><br><span class="line">  <span class="attr">users</span>: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">username</span>: <span class="string">&#x27;alice&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;alice@example.com&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">username</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;bob@example.com&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">products</span>: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">101</span>, <span class="attr">name</span>: <span class="string">&#x27;Laptop&#x27;</span>, <span class="attr">price</span>: <span class="number">1200</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">102</span>, <span class="attr">name</span>: <span class="string">&#x27;Mouse&#x27;</span>, <span class="attr">price</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 模拟执行 SQL 查询的函数</span></span><br><span class="line">  <span class="title function_">execute</span>(<span class="params">sql</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[DB]  executing: <span class="subst">$&#123;sql&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 这是一个非常简化的模拟器，并非一个真正的SQL解析器</span></span><br><span class="line">    <span class="comment">// 仅用于演示</span></span><br><span class="line">    <span class="keyword">if</span> (sql.<span class="title function_">includes</span>(<span class="string">&quot;FROM users WHERE username = &#x27;alice&#x27;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">username</span> === <span class="string">&#x27;alice&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sql.<span class="title function_">includes</span>(<span class="string">&quot;FROM users&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 2. ORM 模型创建函数 ---</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createModel</span>(<span class="params">tableName</span>) &#123;</span><br><span class="line">  <span class="comment">// Proxy 的目标对象可以是空的，因为所有操作都将被 get 陷阱拦截</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 3. Proxy 的 get 拦截器 ---</span></span><br><span class="line">    <span class="comment">// 这是所有魔法发生的地方</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[Proxy] 拦截到属性访问: <span class="subst">$&#123;<span class="built_in">String</span>(propKey)&#125;</span>`</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 匹配 findBy&lt;Field&gt; 模式, e.g., &quot;findByUsername&quot;</span></span><br><span class="line">      <span class="keyword">const</span> findByMatch = <span class="title class_">String</span>(propKey).<span class="title function_">match</span>(<span class="regexp">/^findBy([A-Z]\w*)$/</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (findByMatch) &#123;</span><br><span class="line">        <span class="comment">// 从 &quot;findByUsername&quot; 中提取 &quot;Username&quot;</span></span><br><span class="line">        <span class="keyword">const</span> fieldName = findByMatch[<span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 将字段名转换为数据库列名 (e.g., &quot;Username&quot; -&gt; &quot;username&quot;)</span></span><br><span class="line">        <span class="keyword">const</span> columnName = fieldName.<span class="title function_">toLowerCase</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个函数，这个函数将接收查询值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="comment">// 动态构建 SQL 语句</span></span><br><span class="line">          <span class="keyword">const</span> sql = <span class="string">`SELECT * FROM <span class="subst">$&#123;tableName&#125;</span> WHERE <span class="subst">$&#123;columnName&#125;</span> = &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;;`</span>;</span><br><span class="line">          <span class="comment">// 执行查询并返回结果</span></span><br><span class="line">          <span class="keyword">return</span> db.<span class="title function_">execute</span>(sql);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 匹配 findAll 模式</span></span><br><span class="line">      <span class="keyword">if</span> (propKey === <span class="string">&#x27;findAll&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> sql = <span class="string">`SELECT * FROM <span class="subst">$&#123;tableName&#125;</span>;`</span>;</span><br><span class="line">          <span class="keyword">return</span> db.<span class="title function_">execute</span>(sql);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果没有匹配的模式，可以返回 undefined 或抛出错误</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`[Proxy] <span class="subst">$&#123;<span class="built_in">String</span>(propKey)&#125;</span> 不是一个支持的 ORM 方法。`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用我们简单的 ORM ---</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--- 创建 Users 模型 ---&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Users</span> = <span class="title function_">createModel</span>(<span class="string">&#x27;users&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\n--- 调用 findByUsername ---&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> foundUsers = <span class="title class_">Users</span>.<span class="title function_">findByUsername</span>(<span class="string">&#x27;alice&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;查询结果:&quot;</span>, foundUsers);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\n--- 调用 findAll ---&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> allUsers = <span class="title class_">Users</span>.<span class="title function_">findAll</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;查询结果:&quot;</span>, allUsers);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\n--- 尝试一个不支持的方法 ---&quot;</span>);</span><br><span class="line"><span class="title class_">Users</span>.<span class="title function_">deleteEverything</span>();</span><br></pre></td></tr></table></figure>
<h2 id="Iterator">Iterator</h2>
<blockquote>
<p>核心理解：ITERATOR 为数据结构提供了一个统一的访问机制的接口。</p>
</blockquote>
<h3 id="1-简要概述-3">1. 简要概述</h3>
<ol>
<li>
<p>解释：Iterator（遍历器）是一种为各种不同的数据结构提供<strong>统一的访问机制</strong>的接口。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</li>
<li>
<p>Iterator 的作用</p>
<ul>
<li>为各种数据结构，提供一个统一的、简便的<strong>访问接口</strong></li>
<li>使得数据结构的成员能够按<strong>某种次序排列</strong></li>
<li>为 <code>for...of</code> 循环提供支持</li>
</ul>
</li>
<li>
<p>Iterator 的遍历原理：Iterator 是一个<strong>指针对象</strong>，最初指向数据结构的起始位置。它具有一个 <code>next</code> 方法。每次调用 <code>next</code> 方法时，指针会移动到下一个成员，并返回一个对象，其中包含两个属性：<code>value</code> 表示当前成员的值，<code>done</code> 是一个布尔值，用于指示遍历是否已结束。</p>
</li>
<li>
<p>Iterator 接口的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>](): <span class="title class_">Iterator</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">next</span>(value?: <span class="built_in">any</span>): <span class="title class_">IterationResult</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IterationResult</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-Iterator-接口">2. Iterator 接口</h3>
<h4 id="2-1-Symbol-iterator">2.1 Symbol.iterator</h4>
<ol>
<li>
<p>解释：只要一个数据结构具有 <code>Symbol.iterator</code> 属性，就可以被视为“<strong>可遍历的</strong>”（iterable），这意味着该数据结构<strong>部署了 Iterator 接口</strong>。<code>Symbol.iterator</code> 属性是一个函数，它是该数据结构默认的<strong>迭代器生成函数</strong>。调用这个函数会返回一个迭代器。</p>
</li>
<li>
<p>遍历方式：对于一个可遍历的数据结构 ITERABLE，有以下两种方式遍历其中的数据成员，</p>
<ul>
<li>
<p><code>for...of</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable constant_">ITERABLE</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>while</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iterator = <span class="variable constant_">ITERABLE</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">while</span> (!$result.<span class="property">done</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $result.<span class="property">value</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>原生部署 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象</p>
<blockquote>
<p>对象没有原生部署 Iterator 接口，因为对象的数据是无序的。因此，给对象部署遍历器接口，就相当于部署一种<strong>线性变换</strong>。</p>
<p><code>for...of</code> 遍历字符串时，甚至会正确识别 32 位的 UTF-16 字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;a\uD83D\uDC0A\u9CC4\u9C7C&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;a&quot;，&quot;🐊&quot;，&quot;鳄&quot;，&quot;鱼&quot; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 1, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 2, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 3, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: undefined, &quot;done&quot;: true &#125; </span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-2-接口部署">2.2 接口部署</h4>
<ol>
<li>
<p>解释：为了让数据结构是可遍历的，就要为其部署 Iterator 接口，即在数据结构的 <code>Symbol.iterator</code> 属性上添加<strong>遍历器生成方法</strong>（原型链上添加也奏效）。</p>
</li>
<li>
<p>Iterator 接口部署示例</p>
</li>
</ol>
<ul>
<li>
<p><strong>对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">data</span>: [ <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span> ],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类数组对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果一个对象存在数值键名和 <code>length</code> 属性，就称之为类数组对象，此时部署 Iterator 接口时可以<strong>直接引用数组的 Iterator 接口</strong>。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>
<p>使用说明</p>
<ul>
<li>普通对象部署数组的 <code>Symbol.iterator</code> 方法，并无效果。</li>
<li>如果 <code>Symbol.iterator</code> 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</li>
</ul>
</li>
</ol>
<h4 id="2-3-调用场合">2.3 调用场合</h4>
<ol>
<li>
<p><strong>数组和 Set 的解构赋值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [x, y] = arr; <span class="comment">// x = 1,  y = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> [a, b] = set; <span class="comment">// a = &quot;hello&quot;,  b = &quot;world&quot; </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>扩展运算符 <code>...</code></strong>（只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...str]); <span class="comment">// [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">0</span>, ...arr, <span class="number">4</span>]); <span class="comment">// [0, 1, 2, 3, 4] </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>yield*</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 1, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 2, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 3, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 4, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: 5, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: undefined, &quot;done&quot;: true &#125; </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>数组的遍历</strong>（包括以数组作为参数的场合）</p>
<ul>
<li>
<p><code>for ... of</code> 循环</p>
</li>
<li>
<p><code>Array.from()</code></p>
</li>
<li>
<p><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code></p>
</li>
<li>
<p><code>Promise.all()</code>、<code>Promise.race()</code></p>
</li>
<li>
<p>······</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-4-几个概念">2.4 几个概念</h4>
<p><code>Symbol.iterator</code>、Iterator 接口、可遍历的、<code>for...of</code></p>
<ul>
<li>数据结构具有 <code>Symbol.iterator</code> 属性，亦即数据结构部署了 Iterator 接口，亦即数据结构是可遍历的，亦即数据结构可以使用 <code>for...of</code> 遍历其数据成员。</li>
<li><code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。</li>
</ul>
<h3 id="3-Iterator-结构">3. Iterator 结构</h3>
<ol>
<li>
<p>解释：Iterator 本质上是一个对象，<strong>必须</strong>包含 <code>next()</code> 方法，<strong>可选</strong>包含 <code>return()</code> 和 <code>throw()</code> 方法。</p>
<ul>
<li><code>next()</code>：用于遍历数据结构中的所有数据成员，返回值是一个对象，其结构为 <code>&#123;value: any, done: boolean&#125;</code>，其中 <code>value</code> 表示当前遍历的数据成员，<code>done</code> 表示数据结构是否遍历完毕。</li>
<li><code>return()</code>：当 <code>for...of</code> 循环因为 <code>break</code> 或 <code>throw</code> 语句提前退出时，就会调用该方法。</li>
<li><code>throw()</code>：主要配合 Generator 函数使用，详见下述关于 Generator 函数的笔记。</li>
</ul>
</li>
<li>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">value</span>: number;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                    value = self.<span class="property">data</span>[index++];</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`正在遍历数据 <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">                    <span class="keyword">return</span> &#123; value, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据结构遍历结束&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">return</span>() &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`return 方法在遍历 <span class="subst">$&#123;value&#125;</span> 时被调用了`</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123; value &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterableObj) &#123;</span><br><span class="line">    <span class="comment">// &quot;正在遍历数据 1&quot; </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// &quot;return 方法在遍历 1 时被调用了&quot; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterableObj) &#123;</span><br><span class="line">        <span class="comment">// &quot;正在遍历数据 1&quot; </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1 </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error in for...of&#x27;</span>); <span class="comment">// &quot;return 方法在遍历 1 时被调用了&quot; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="attr">e</span>:any) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>); <span class="comment">// &quot;error in for...of&quot; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果在 <code>for...of</code> 循环中，由于 <code>throw</code> 语句导致调用了可迭代对象的 Iterator 的 <code>return()</code> 方法，那么会先执行 <code>return()</code> 方法，然后再抛出错误。</p>
</blockquote>
</li>
</ol>
<h3 id="4-生成数据结构">4. 生成数据结构</h3>
<p>数组、Set、Map 都具有以下方法，调用后返回一个遍历器，用于遍历生成数据结构的数据成员。</p>
<ul>
<li><code>entries()</code>：返回一个遍历器对象，用于遍历形如 <code>[键名，键值]</code> 的数组。对于数组，每次遍历的是 <code>[索引值，元素值]</code>；对于 Set，每次遍历的是 <code>[元素值，元素值]</code>；对于 Map，每次遍历的是 <code>[键名，键值]</code>。</li>
<li><code>keys()</code>：返回一个遍历器对象，用于遍历所有的键名。</li>
<li><code>values()</code>：返回一个遍历器对象，用于遍历所有的键值。</li>
</ul>
<h3 id="5-遍历语法比较">5. 遍历语法比较</h3>
<p>这里展示其他循环的缺点，与 <code>for...of</code> 循环的优点。</p>
<ol>
<li>
<p><code>for</code> 循环</p>
<ul>
<li>写法比较麻烦</li>
</ul>
</li>
<li>
<p>数组的 <code>forEach</code> 方法</p>
<ul>
<li>无法中途跳出 <code>forEach</code> 循环</li>
</ul>
</li>
<li>
<p><code>for...in</code> 循环（用于遍历键名）</p>
<ul>
<li>
<p>遍历数组时，遍历的键名是索引数字对应的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;boo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;zoo&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> idx <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(idx); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>会遍历原型上的键名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1);</span><br><span class="line">obj2.<span class="property">gender</span> = <span class="string">&#x27;Male&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj2)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &quot;gender&quot;, &quot;name&quot;, &quot;age&quot; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>会以任意顺序遍历键名</p>
</li>
</ul>
</li>
<li>
<p><code>for...of</code> 循环（用于遍历可遍历对象的数据成员）</p>
<ul>
<li>简洁的语法</li>
<li>有序遍历</li>
<li>可中途跳出循环（与 <code>break</code>、<code>continue</code> 配合使用）</li>
<li>遍历所有数据结构的统一接口</li>
</ul>
</li>
</ol>
<h2 id="Generator-函数">Generator 函数</h2>
<blockquote>
<p>核心理解：GENERATOR 的执行结果是 ITERATOR，同时这个 ITERATOR 可以看作是 GENERATOR 的实例。</p>
</blockquote>
<h3 id="1-简要概述-4">1. 简要概述</h3>
<ol>
<li>
<p>解释：Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，可以从以下两种角度来理解，</p>
<ul>
<li>语法上
<ul>
<li>Generator 函数是一个<strong>状态机</strong>，封装了多个内部状态。</li>
<li>Generator 函数是一个<strong>遍历器生成函数</strong>，执行后返回一个遍历器，可以依次遍历 Generator 函数内部的每一个状态。</li>
</ul>
</li>
<li>形式上
<ul>
<li>Generator 函数使用 <code>function*</code> 来定义，即 <code>function</code> 关键字和函数名之间有一个星号 <code>*</code>。</li>
<li>Generator 函数内部使用 <code>yield</code> 表达式定义不同的内部状态。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Generator 函数的执行流程</p>
<ul>
<li>
<p>调用 Generator 函数时，该函数不会立即执行，而是返回一个<strong>遍历器对象</strong>，该对象是指向函数内部的指针。</p>
</li>
<li>
<p>每次调用遍历器对象的 <code>next()</code> 方法时，Generator 函数会<strong>从上次暂停的地方继续执行</strong>，直到遇到 <code>yield</code> 表达式或 <code>return</code> 语句。<code>next()</code> 方法返回一个对象，其结构为 <code>&#123;value: any, done: boolean&#125;</code>。其中，<code>value</code> 表示 Generator 函数当前执行位置的值（即 <code>yield</code> 或 <code>return</code> 后的表达式的值），而 <code>done</code> 是一个布尔值，指示遍历是否已完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: &quot;hello&quot;, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: &quot;world&quot;, &quot;done&quot;: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: &quot;ending&quot;, &quot;done&quot;: true &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>()); <span class="comment">// &#123; &quot;value&quot;: undefined, &quot;done&quot;: true &#125; </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>yield</code> 表达式：基于上述内容可知，Generator 函数是一种可以<strong>暂停执行的函数</strong>，而 <code>yield</code> 表达式就是<strong>暂停标志</strong>。</p>
<ul>
<li>
<p><strong>惰性求值</strong>（Lazy Evaluation）：<code>yield</code> 表达式后的表达式只有当调用 <code>next()</code> 方法、内部指针指向该语句时才会执行。</p>
</li>
<li>
<p><strong>暂缓执行函数</strong>：如果 Generator 函数中不使用 <code>yield</code> 表达式，那么只有调用该函数返回的遍历器对象的 <code>next()</code> 方法后，该函数的内部代码才会执行。</p>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p><code>yield</code> <strong>既是一个操作，也是一个有返回值的表达式</strong>。</p>
<ul>
<li>
<p><strong>暂停并返回值</strong>：<code>yield 123</code> 会暂停 Generator 函数，并把值 <code>123</code> “产出”到函数外部。</p>
<p><strong>接收输入值</strong>：当外部调用 <code>.next(inputValue)</code> 时，整个 <code>yield</code> 表达式（例如 <code>yield 123</code>）会<strong>被 <code>inputValue</code> 这个值所替代</strong>。</p>
</li>
</ul>
</li>
<li>
<p><code>yield</code> 表达式只能用在 Generator 函数里面。</p>
</li>
<li>
<p><code>yield</code> 表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>yield</code> 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>可以把 Generator 函数赋值给对象的 <code>Symbol.iterator</code> 属性，从而使得该对象具有 Iterator 接口，使其成为可遍历对象。</p>
</li>
<li>
<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code> 属性，执行后返回自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">numbers</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === iterator); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：JavaScript <strong>内置的可迭代对象（如 Array, Map, Set）所返回的迭代器</strong>，通常也遵循这个模式。</p>
</blockquote>
</li>
<li>
<p>在使用 <code>for...of</code> 循环遍历 Generator 函数返回的遍历器时，遍历结果不包括 Generator 函数中 <code>return</code> 语句返回的值。<strong><code>return</code> 语句仅用于标识迭代的结束</strong>，而其返回的值不会被 <code>for...of</code> 循环捕获。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="title function_">numbers</span>()]); <span class="comment">// [1, 2] </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>())); <span class="comment">// [1, 2] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [x, y] = <span class="title function_">numbers</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">numbers</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有与 <code>for...of</code> 遍历原理相同的语法，都会得到相同的结果。</p>
</blockquote>
</li>
<li>
<p>如果一个对象的属性是 Generator 函数，可以<strong>简写</strong>成下面的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Generator 函数执行返回的遍历器是 Generator 函数的实例</strong>，继承了 Generator 函数的 <code>prototype</code> 对象上的方法。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-next-方法的参数">2. next 方法的参数</h3>
<ol>
<li>
<p>解释：<code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code>。<code>next</code> 方法可以带一个参数，该参数就会被当作<strong>上一个 <code>yield</code> 表达式的返回值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="title function_">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="title function_">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>通过 <code>next()</code> 方法的参数，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</li>
<li>第一次调用 <code>next()</code> 方法时，传递参数是无效的。</li>
</ul>
</li>
</ol>
<h3 id="3-Generator-函数的原型方法">3. Generator 函数的原型方法</h3>
<p>Generator 函数的执行结果是一个遍历器，可以被视为 Generator 函数的实例对象。因此，下述的 <code>throw()</code>、<code>return()</code> 方法都是遍历器对象所调用的方法。</p>
<h4 id="3-1-Generator-prototype-throw">3.1 Generator.prototype.throw()</h4>
<ol>
<li>
<p>解释：在 Generator 函数体外<strong>抛出错误</strong>，该错误可以在 Generator 函数体内被捕获。</p>
</li>
<li>
<p>语法：<code>integrator.throw(e)</code></p>
<ul>
<li><code>e</code>：被抛出的错误，建议为 <code>Error</code> 对象的实例。</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p><code>throw</code> 方法抛出的错误要被内部捕获，前提是必须<strong>至少执行过一次 <code>next</code> 方法</strong>，否则，由于 Generator 函数还没有开始执行，<code>throw</code> 方法抛出的错误只能抛出在函数外部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>()))<span class="comment">// &quot;执行 JavaScript 失败:&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>throw</code> 方法被内部捕获以后，会附带执行到下一条 <code>yield</code> 表达式，这种情况下<strong>等同于执行一次 <code>next</code> 方法</strong>。也就是说，<code>throw</code> 方法执行后，也会返回一个结构为 <code>&#123;value: any, done: boolean&#125;</code> 的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())<span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>())) <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就<strong>不会再执行下去</strong>了。如果此后还调用 <code>next</code> 方法，将返回一个 <code>value</code> 属性等于 <code>undefined</code>、<code>done</code> 属性等于 <code>true</code> 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>()))</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="3-2-Generator-prototype-return">3.2 Generator.prototype.return()</h4>
<ol>
<li>
<p>解释：在 Generator 函数体外返回给定的值，并且终结遍历 Generator 函数。</p>
</li>
<li>
<p>语法：<code>integrator.return(value)</code></p>
<ul>
<li><code>value</code>：返回的值。如果不提供该参数，则默认 <code>value = undefined</code>。</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>如果 Generator 函数内部有 <code>try...finally</code> 代码块，且正在执行 <code>try</code> 代码块，那么 <code>return</code> 方法会导致立刻进入 <code>finally</code> 代码块，执行完以后，再返回 <code>return</code> 方法指定的返回值，此时整个函数才会结束。</p>
</li>
<li>
<p>与 <code>throw</code> 方法类似，<code>return</code> 方法执行后，也会返回一个结构为 <code>&#123;value: any, done: boolean&#125;</code> 的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())<span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>())) <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">100</span>)) <span class="comment">// &#123; value:5, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:100, done:true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="3-3-next-、throw-、return-对比">3.3 next()、throw()、return() 对比</h4>
<p><code>next()</code>、<code>throw()</code>、<code>return()</code> 本质上都是让 Generator 函数<strong>恢复执行</strong>，并且使用不同的语句替换 <code>yield</code> 表达式。假设遍历器对象当前指向 <code>let result = yield x + y</code>，那么以下方法的执行相当于将 <code>yield</code> 表达式替换为，</p>
<ul>
<li><code>next(para)</code>：<code>let result = para</code></li>
<li><code>throw(e)</code>：<code>let result = throw(e)</code></li>
<li><code>return(value)</code>：<code>let result = return value</code></li>
</ul>
<h3 id="4-yield-表达式">4. yield* 表达式</h3>
<ol>
<li>
<p>解释：在 Generator 函数中使用 <code>yield*</code> 表达式，相当于<strong>委托执行</strong>另一个遍历器对象或可遍历对象的所有元素。<code>yield*</code> 会自动遍历该对象的所有元素，并对每个元素<strong>单独使用 <code>yield</code> 表达式进行产出</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i = <span class="title function_">bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>().<span class="property">value</span>) <span class="comment">// &quot;x&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>().<span class="property">value</span>) <span class="comment">// &quot;a&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>().<span class="property">value</span>) <span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>().<span class="property">value</span>) <span class="comment">// &quot;y&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>().<span class="property">value</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法</p>
<ul>
<li><code>yield* 遍历器对象</code></li>
<li><code>yield* 可遍历对象</code></li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>如果 <code>yield*</code> 后面跟随的是一个 Generator 函数的遍历器，并且该 Generator 函数包含 <code>return</code> 语句，那么可以使用 <code>var value = yield* iterator</code> 的形式来<strong>获取 <code>return</code> 语句返回的值</strong>。</li>
</ul>
</li>
</ol>
<h3 id="5-Generator-与协程">5. Generator 与协程</h3>
<ol>
<li>协程（coroutine）：一种程序运行的方式，可以理解成 “协作的线程” 或 “协作的函数”。</li>
<li>协程的实现方式
<ul>
<li>单线程实现：特殊的子例程（subroutine）</li>
<li>多线程实现：特殊的线程</li>
</ul>
</li>
<li>协程 Vs 子例程
<ul>
<li>子例程
<ul>
<li>一个调用栈。</li>
<li>堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。</li>
</ul>
</li>
<li>协程
<ul>
<li>多个调用栈。</li>
<li>多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。</li>
</ul>
</li>
</ul>
</li>
<li>协程 Vs 普通线程
<ul>
<li>普通线程：同一时间可以有多个线程处于运行状态。</li>
<li>协程：同一时间运行的协程只能有一个，其他协程都处于暂停状态。</li>
</ul>
</li>
<li>Generator 函数 - 半协程：Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。此外，Generator 使用 <code>yield</code> 表达式交换控制权。</li>
<li>Generator 函数 - 上下文：Generator 函数执行产生的上下文环境，一旦遇到 <code>yield</code> 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会<strong>冻结</strong>在当前状态。等到对它执行 <code>next</code> 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</li>
</ol>
<h2 id="ArrayBuffer">ArrayBuffer</h2>
<h3 id="1-简要概述-5">1. 简要概述</h3>
<ol>
<li>
<p>解释：<code>ArrayBuffer</code> 对象代表<strong>内存之中的一段二进制数据</strong>，开发者可以通过<strong>视图</strong>（<code>TypedArray</code> 或 <code>DataView</code>）进行操作。由于视图部署了数组接口，因此可以<strong>使用数组的方法操作内存</strong>。<code>ArrayBuffer</code> 对象、<code>TypedArray</code> 视图和 <code>DataView</code> 视图统称为<strong>二进制数组</strong>。</p>
</li>
<li>
<p>视图：<code>TypedArray</code> 视图用于读写<strong>简单类型</strong>的二进制数据；<code>DataView</code> 视图支持自定义复合格式的视图，因此用于读写<strong>复杂类型</strong>的二进制数据。</p>
<ul>
<li>
<p><code>TypedArray</code> 视图：9 种类型，如 Uint8Array 数组视图、Int16Array 数组视图、Float32Array 数组视图等，对应 9 种数据类型。</p>
</li>
<li>
<p><code>DataView</code> 视图：可以自定义每个字节对应的数据类型，如第一个字节是 Uint8，第二、三个字节是 Int16，第四个字节开始是 Float32等，支持 8 种数据类型（与 <code>TypedView</code> 视图相比，不支持 Uint8C 数据类型）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">字节长度</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">对应的 C 语言类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Int8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8 位带符号整数</td>
<td style="text-align:center">signed char</td>
</tr>
<tr>
<td style="text-align:center">Uint8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8 位不带符号整数</td>
<td style="text-align:center">unsigned char</td>
</tr>
<tr>
<td style="text-align:center">Uint8C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8 位不带符号整数（自动过滤溢出）</td>
<td style="text-align:center">unsigned char</td>
</tr>
<tr>
<td style="text-align:center">Int16</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16 位带符号整数</td>
<td style="text-align:center">short</td>
</tr>
<tr>
<td style="text-align:center">Uint16</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16 位不带符号整数</td>
<td style="text-align:center">unsigned short</td>
</tr>
<tr>
<td style="text-align:center">Int32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位带符号整数</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">Uint32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位不带符号的整数</td>
<td style="text-align:center">unsigned int</td>
</tr>
<tr>
<td style="text-align:center">Float32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位浮点数</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">Float64</td>
<td style="text-align:center">8</td>
<td style="text-align:center">64 位浮点数</td>
<td style="text-align:center">double</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ol>
<h3 id="2-ArrayBuffer">2. ArrayBuffer</h3>
<ol>
<li>
<p>解释：<code>ArrayBuffer</code> 对象代表<strong>内存之中的一段二进制数据</strong>，仅支持通过<strong>视图</strong>进行读写操作。</p>
</li>
<li>
<p>基本使用</p>
<ul>
<li>
<p><strong><code>ArrayBuffer</code> 的创建</strong>：指定<strong>连续的</strong>内存区域大小为 <code>byteLength</code>，同时每个字节的默认值为 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(byteLength)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>ArrayBuffer</code> 的操作</strong>（通过视图）</p>
<ul>
<li>
<p><code>DataView</code> 视图：指定 <code>ArrayBuffer</code> 实例为参数创建视图实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dataView.<span class="title function_">getInt8</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>TypedArray</code> 视图：指定 <code>ArrayBuffer</code> 实例为参数创建视图实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> int8Array = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(buffer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(int8Array.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：与 DataView 视图不同，TypedArray 视图是一组构造函数，代表不同的数据格式</p>
</blockquote>
</li>
<li>
<p><code>TypedArray</code> 视图：指定 <code>Array</code> 实例为参数创建视图实例，此时会隐含地创建一个 <code>ArrayBuffer</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> int8Array2 = <span class="keyword">new</span> <span class="title class_">Int8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(int8Array2.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ArrayBuffer</code> 的属性和方法</p>
<ul>
<li>
<p><code>ArrayBuffer.prototype.byteLength: number</code> 返回 ArrayBuffer 所分配的<strong>内存区域的字节长度</strong>。内存区域要求<strong>连续</strong>，因此大内存区域可能会分配失败，因此可以通过如下方法<strong>检测内存是否分配成功</strong>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buffer.<span class="property">byteLength</span> === n) &#123;</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ArrayBuffer.prototype.slice(start[, end]): ArrayBuffer</code> <strong>创建一个新的 <code>ArrayBuffer</code> 对象，其内存区域数据拷贝自原 <code>ArrayBuffer</code> 内存区域 <code>[start end)</code> 部分的字节数据</strong>。这里的 <code>start</code>、<code>end</code> 是字节序号，如果不指定 <code>end</code>，则拷贝原 <code>ArrayBuffer</code> 从 <code>start</code> 字节开始的所有字节数据。</p>
</li>
<li>
<p><code>ArrayBuffer.isView(obj): boolean</code> 表示参数 <code>obj</code> <strong>是否为 <code>ArrayBuffer</code> 的视图实例</strong>，即是否为 <code>TypedArray</code> 实例或 <code>DataView </code>实例。</p>
</li>
</ul>
</li>
<li>
<p>Conversion：<code>ArrayBuffer</code> 及对应的 <code>TypedArray</code> &lt;–&gt; <code>string</code></p>
<ul>
<li>
<p><code>ArrayBuffer</code> 及其对应的 <code>TypedArray</code> --&gt; <code>string</code>：<code>TextDeocder</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step1. </span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">decoder</span>: <span class="title class_">TextDecoder</span> = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>(outputEncoding); <span class="comment">// outputEncoding 指定解码的编码格式，默认为 &#x27;utf-8&#x27;</span></span><br><span class="line"><span class="comment">// Step2. </span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">output</span>: string = decoder.<span class="title function_">decode</span>(input); <span class="comment">// input 的类型为 ArrayBuffer | Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>string</code> --&gt; <code>ArrayBuffer</code> 及其对应的 <code>TypedArray</code>：<code>TextEncoder</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step1. </span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">encoder</span>: <span class="title class_">TextEncoder</span> = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="comment">// Step2. </span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">view</span>: <span class="title class_">Uint8Array</span> = <span class="title function_">encoder</span>(input); <span class="comment">// input 的类型为 string</span></span><br><span class="line"><span class="comment">// Step3.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">buffer</span>: <span class="title class_">ArrayBuffer</span> = view.<span class="property">buffer</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="3-TypedArray">3. TypedArray</h3>
<h4 id="3-1-概念理解">3.1 概念理解</h4>
<ol>
<li>
<p>视图（view）：即对 <code>ArrayBuffer</code> 对象对应<strong>内存区域的字节数据的解读方式</strong>，分为 <code>TypedArray</code> 视图（将所有数组成员都解读为<strong>同一种</strong>数据类型）、<code>DataView</code> 视图（将所有数组成员都解读为<strong>不同的</strong>数据类型）。</p>
</li>
<li>
<p>TypedArray 视图：共计 9 种，对应 9 种<strong>构造函数</strong>，9 种数组成员的<strong>数据类型</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">构造函数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Int8Array</td>
<td style="text-align:center">8 位有符号整数，长度 1 个字节。</td>
</tr>
<tr>
<td style="text-align:center">Uint8Array</td>
<td style="text-align:center">8 位无符号整数，长度 1 个字节</td>
</tr>
<tr>
<td style="text-align:center">Uint8ClampedArray</td>
<td style="text-align:center">8 位无符号整数，长度 1 个字节，溢出处理不同。</td>
</tr>
<tr>
<td style="text-align:center">Int16Array</td>
<td style="text-align:center">16 位有符号整数，长度 2 个字节。</td>
</tr>
<tr>
<td style="text-align:center">Uint16Array</td>
<td style="text-align:center">16 位无符号整数，长度 2 个字节。</td>
</tr>
<tr>
<td style="text-align:center">Int32Array</td>
<td style="text-align:center">32 位有符号整数，长度 4 个字节。</td>
</tr>
<tr>
<td style="text-align:center">Uint32Array</td>
<td style="text-align:center">32 位无符号整数，长度 4 个字节。</td>
</tr>
<tr>
<td style="text-align:center">Float32Array</td>
<td style="text-align:center">32 位浮点数，长度 4 个字节。</td>
</tr>
<tr>
<td style="text-align:center">Float64Array</td>
<td style="text-align:center">64 位浮点数，长度 8 个字节。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>TypedArray Vs. Array</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异点</th>
<th style="text-align:center">TypedArray</th>
<th style="text-align:center">Array</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数组成员类型是否相同</strong></td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center"><strong>数组成员在内存空间是否连续</strong></td>
<td style="text-align:center">是</td>
<td style="text-align:center">不一定（密集数组连续，稀疏数组不连续）</td>
</tr>
<tr>
<td style="text-align:center"><strong>数组成员的默认值</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>undefined</code>（空位）</td>
</tr>
<tr>
<td style="text-align:center"><strong>数据存储位置</strong></td>
<td style="text-align:center"><code>TypedArray</code> 视图对应的 <code>ArrayBuffer</code> 对象（可通过视图的 <code>buffer</code> 属性获取）</td>
<td style="text-align:center"><code>Array</code> 对象自身</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="3-2-构造函数">3.2 构造函数</h4>
<blockquote>
<p>注：JavaScript <strong>允许基于同一 <code>ArrayBuffer</code> 对象建立多个视图</strong>，此时每个视图可以根据自己的理解去修改相应内存区域的数据，同时一个视图对内存的更改会在其他视图上反映出来。</p>
</blockquote>
<ol>
<li>
<p><code>TypedArray(buffer: ArrayBuffer, byteOffset: number=0[, length: number])</code> 表示从 <code>buffer</code> 的第 <code>byteOffset</code> 个字节开始创建视图，同时确保视图的成员数量为 <code>length</code>。其中 <code>byteOffset</code> 是 <code>0-based</code> 表示，表示视图开始的字节序号，默认值为 0；<code>length</code> 表示视图的成员数量，因此视图对应<strong>内存区域的长度 = <code>length</code> * 每个成员字节数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>); <span class="comment">// 对应 8 个字节的内存区域（第 0 ～ 7 个字节）</span></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buf); <span class="comment">// 可操作第 0 ~ 7 个字节，每 4 个字节被解析为一个 int32 类型的数组成员，因此视图数组长度为 2</span></span><br><span class="line"><span class="keyword">const</span> v2 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buf, <span class="number">2</span>); <span class="comment">// 可操作第 2 ~ 7 个字节，每 1 个字节被解析为一个 uint8 类型的数组成员，因此视图数组长度为 6</span></span><br><span class="line"><span class="keyword">const</span> v3 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(buf, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 可操作第 2 ~ 5（2 + 2 * 2 - 1） 个字节，每 2 个字节被解析为一个 int16 类型的数组成员，此时视图数组长度被指定为 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`v1.length=<span class="subst">$&#123;v1.length&#125;</span>, v2.length=<span class="subst">$&#123;v2.length&#125;</span>, v3.length=<span class="subst">$&#123;v3.length&#125;</span>`</span>); <span class="comment">// 2, 6, 2</span></span><br><span class="line">v1[<span class="number">0</span>] = <span class="number">0x12345678</span>; <span class="comment">// 修改第 0 ～ 3 个字节的值为 0x12345678，此时 v2[0] 表示第 2 个字节的值为 0x34, 表示第 2 ～ 3 个字节的值为 0x1234</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf); <span class="comment">// [Uint8Contents]: &lt;78 56 34 12 00 00 00 00&gt;（ArrayBuffer 十六进制表示的每个字节的值）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`v1[0]=0x<span class="subst">$&#123;v1[<span class="number">0</span>].toString(<span class="number">16</span>)&#125;</span>, v2[0]=0x<span class="subst">$&#123;v2[<span class="number">0</span>].toString(<span class="number">16</span>)&#125;</span>, v3[0]=0x<span class="subst">$&#123;v3[<span class="number">0</span>].toString(<span class="number">16</span>)&#125;</span>`</span>); <span class="comment">// 0x12345678, 0x34, 0x1234</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：创建视图时，byteOffset 必须与所建立的数据类型一致，即 byteOffset 必须是数组成员的字节数的整数倍，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v4 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(buf, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p><code>TypedArray(length)</code> 表示创建一个成员数量为 <code>length</code> 的视图，此时视图实际上创建了一个大小为 <strong><code>length</code> * 视图成员字节数</strong> 的 <code>ArrayBuffer</code>。其中 <code>length</code> 表示视图成员数量；视图创建的 <code>ArrayBuffer</code> 可以通过视图的 <code>buffer</code> 属性获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f64a = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(<span class="number">8</span>); <span class="comment">// 视图成员数量为 8，对应的内存区域大小为 8 * 8 = 64 字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`f64a.length=<span class="subst">$&#123;f64a.length&#125;</span>, f64a.buffer.byteLength=<span class="subst">$&#123;f64a.buffer.byteLength&#125;</span>`</span>); <span class="comment">// 8, 64</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f64a.<span class="property">buffer</span>); <span class="comment">// [Uint8Contents]: &lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;（ArrayBuffer 十六进制表示的每个字节的值）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>TypedArray(typedArray)</code> 表示基于给定视图创建一个新的视图，此时新视图对应的 <code>ArrayBuffer</code> 与给定视图的 <code>ArrayBuffer</code> 不是同一个，可以理解为两个 <code>ArrayBuffer</code> 内存区域不同，但是数据相同，即数据发生了拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> view1 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> view2 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(view1);</span><br><span class="line">view1[<span class="number">0</span>] = <span class="number">123</span>; <span class="comment">// 此时 view1 对应的内存区域数据为 123 2 3 4，view2 对应的内存区域的数据为 1 2 3 4，即两个视图的内存区域相互独立互不干扰</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`view1[0]=<span class="subst">$&#123;view1[<span class="number">0</span>]&#125;</span>, view2[0]=<span class="subst">$&#123;view2[<span class="number">0</span>]&#125;</span>`</span>); <span class="comment">// 123, 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>TypedArray(arrayLikeObject)</code> 表示基于给定类数组对象创建一个视图，此时视图实际上开辟了一个新的 <code>ArrayBuffer</code>，与给定类数组对象无关，即数据发生了拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// 视图的成员数量为给定的类数组对象的成员数量。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`view.length=<span class="subst">$&#123;view.length&#125;</span>`</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：TypedArray 视图可以通过以下三种方法转换为普通数组：<code>[...typedArray]</code>, <code>Array.from(typedArray)</code>, <code>Array.prototype.slice.call(typedArray)</code>。</p>
</blockquote>
</li>
</ol>
<h4 id="3-3-数组方法">3.3 数组方法</h4>
<ol>
<li>
<p>TypedArray 可用的数组方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">copyWithin</span>(target, start[, end=<span class="variable language_">this</span>.<span class="property">length</span>])</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">entries</span>()</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">every</span>(callbackfn, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">fill</span>(value, start=<span class="number">0</span>, end=<span class="variable language_">this</span>.<span class="property">length</span>)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">filter</span>(callbackfn, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">find</span>(predicate, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">findIndex</span>(predicate, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">forEach</span>(callbackfn, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">indexOf</span>(searchElement, fromIndex=<span class="number">0</span>)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">join</span>(separator)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">keys</span>()</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">lastIndexOf</span>(searchElement, fromIndex?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">map</span>(callbackfn, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">reduce</span>(callbackfn, initialValue?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">reduceRight</span>(callbackfn, initialValue?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">slice</span>(start=<span class="number">0</span>, end=<span class="variable language_">this</span>.<span class="property">length</span>)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">some</span>(callbackfn, thisArg?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">sort</span>(comparefn)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toLocaleString</span>(reserved1?, reserved2?)</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">values</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p><code>TypedArray</code> 数组没有 <code>concat</code> 方法，可以通过以下函数实现多个 <code>TypedArray</code> 数组的<strong>合并</strong>操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">concatenate</span>(<span class="params">resultConstructor, ...arrays</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> totalLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arr <span class="keyword">of</span> arrays) &#123;</span><br><span class="line">    totalLength += arr.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title function_">resultConstructor</span>(totalLength);</span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arr <span class="keyword">of</span> arrays) &#123;</span><br><span class="line">    result.<span class="title function_">set</span>(arr, offset);</span><br><span class="line">    offset += arr.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">concatenate</span>(<span class="title class_">Uint8Array</span>, <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<code>TypedArray</code> 可以称之为<strong>数组</strong>，因为其实现了数组接口；也可称之为<strong>视图</strong>，因为其可以对 <code>ArrayBuffer</code> 对应的内存区域进行操作。</p>
</blockquote>
</li>
<li>
<p><code>TypedArray</code> 数组部署了 <code>Iterator</code> 接口，即 <code>TypedArray</code> 数组是可迭代对象，可以通过 <code>for...of</code> 遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ui8 = <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> byte <span class="keyword">of</span> ui8) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="3-4-字节序">3.4 字节序</h4>
<ol>
<li>
<p><strong>大端字节序</strong>（Big-Endian）：重要的字节排在前边，不重要的字节排在后边。换句话说，高位字节排在内存低位，低位字节排在内存高位。</p>
<ul>
<li>示例：<code>0x12345678</code> 的大端字节序的存储为 <code>12</code> <code>34</code> <code>56</code> <code>78</code>（内存地址从低到高）。</li>
<li>场景：网络传输（TCP/IP 协议等）。</li>
</ul>
</li>
<li>
<p><strong>小端字节序</strong>（Little-Endian，默认）：不重要的字节排在前边，重要的字节排在后边。换句话说，低位字节在内存低位，高位字节在内存高位。</p>
<blockquote>
<p>注：<code>TypedArray</code> 视图采取<strong>小端字节序</strong>读写数据，不支持修改字节序。但是，<code>DataView</code> 视图支持以指定的字节序读写数据。</p>
</blockquote>
<ul>
<li>示例：<code>0x12345678</code> 的小端字节序的存储为 <code>78</code> <code>56</code> <code>34</code> <code>12</code>（内存地址从低到高）。</li>
<li>场景：x86 处理器、Windows 系统。</li>
</ul>
</li>
<li>
<p>字节序判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">BIG_ENDIAN</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;BIG_ENDIAN&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LITTLE_ENDIAN</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;LITTLE_ENDIAN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPlatformEndianness</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr32 = <span class="title class_">Uint32Array</span>.<span class="title function_">of</span>(<span class="number">0x12345678</span>);</span><br><span class="line">  <span class="keyword">let</span> arr8 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(arr32.<span class="property">buffer</span>);</span><br><span class="line">  <span class="keyword">switch</span> ((arr8[<span class="number">0</span>]*<span class="number">0x1000000</span>) + (arr8[<span class="number">1</span>]*<span class="number">0x10000</span>) + (arr8[<span class="number">2</span>]*<span class="number">0x100</span>) + (arr8[<span class="number">3</span>])) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x12345678</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">BIG_ENDIAN</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x78563412</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">LITTLE_ENDIAN</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown endianness&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-5-属性和方法">3.5 属性和方法</h4>
<ol>
<li>
<p>静态属性</p>
<ul>
<li>
<p><code>TypedArray.BYTES_PER_ELEMENT</code> 获取指定视图的数组成员所占据的字节数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Int8Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Uint8Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Uint8ClampedArray</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Int16Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Uint16Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Int32Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Uint32Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Float32Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Float64Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>实例属性</p>
<ul>
<li><code>TypedArray.prototype.BYTES_PER_ELEMENT</code> 与 <code>TypedArray.BYTES_PER_ELEMENT</code> 相同。</li>
</ul>
</li>
</ol>
<h3 id="4-DataView">4. DataView</h3>
<p>More in <a target="_blank" rel="noopener" href="https://netmarket.oss.aliyuncs.com/35cdb5c1-9e70-4562-a245-2664416d784b.pdf">阮一峰 ES6（第三版）</a></p>
<details class="toggle" ><summary class="toggle-button" style="">本贴参考</summary><div class="toggle-content"><p><a target="_blank" rel="noopener" href="https://netmarket.oss.aliyuncs.com/35cdb5c1-9e70-4562-a245-2664416d784b.pdf">阮一峰 ES6（第三版）</a></p>
</div></details>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Nasir1423">yiTuChuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zhengzehua.top/2025/02/08/ES6%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/">https://zhengzehua.top/2025/02/08/ES6%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zhengzehua.top" target="_blank">川一土的博客视界</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/butterfly_avatar_img.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/01/14/Git/" title="📖Git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">📖Git</div></div><div class="info-2"><div class="info-item-1">系统介绍 Git 的核心概念和常用命令，包括配置管理、版本控制、分支操作、远程协作、标签管理等内容。通过详细的命令说明和图文并茂的原理解释，帮助读者掌握 Git 在实际开发中的应用，建立起完整的 Git 知识体系。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-Map"><span class="toc-text">Set &amp; Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Set"><span class="toc-text">1. Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WeakSet"><span class="toc-text">2. WeakSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Map"><span class="toc-text">3. Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-WeakMap"><span class="toc-text">4. WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect"><span class="toc-text">Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2. 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">3. 应用：观察者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-2"><span class="toc-text">1. 简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%A6%E6%88%AA%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 拦截操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84-Proxy"><span class="toc-text">3. 可取消的 Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-this-%E9%97%AE%E9%A2%98"><span class="toc-text">4. this 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93"><span class="toc-text">5. 对象属性检测总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BA%94%E7%94%A8%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93-ORM"><span class="toc-text">6. 应用：数据库 ORM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator"><span class="toc-text">Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-3"><span class="toc-text">1. 简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Iterator-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2. Iterator 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Symbol-iterator"><span class="toc-text">2.1 Symbol.iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%8E%A5%E5%8F%A3%E9%83%A8%E7%BD%B2"><span class="toc-text">2.2 接口部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%B0%83%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-text">2.3 调用场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-text">2.4 几个概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Iterator-%E7%BB%93%E6%9E%84"><span class="toc-text">3. Iterator 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4. 生成数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-text">5. 遍历语法比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-%E5%87%BD%E6%95%B0"><span class="toc-text">Generator 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-4"><span class="toc-text">1. 简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-next-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">2. next 方法的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">3. Generator 函数的原型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Generator-prototype-throw"><span class="toc-text">3.1 Generator.prototype.throw()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Generator-prototype-return"><span class="toc-text">3.2 Generator.prototype.return()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-next-%E3%80%81throw-%E3%80%81return-%E5%AF%B9%E6%AF%94"><span class="toc-text">3.3 next()、throw()、return() 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4. yield* 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Generator-%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-text">5. Generator 与协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBuffer"><span class="toc-text">ArrayBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-5"><span class="toc-text">1. 简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ArrayBuffer"><span class="toc-text">2. ArrayBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TypedArray"><span class="toc-text">3. TypedArray</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="toc-text">3.1 概念理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.3 数组方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">3.4 字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">3.5 属性和方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-DataView"><span class="toc-text">4. DataView</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By yiTuChuan</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.0-b2"></script><script src="/js/main.js?v=5.4.0-b2"></script><div class="js-pjax"><script>(() = {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs@6.4.4/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'Nasir1423/blog-comment',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/click-show-text.min.js" data-mobile="false" data-text="Prosperity,Democracy,Civility,Harmony,Freedom,Equality,Justice,Rule of Law,Patriotism,Dedication,Integrity,Friendliness" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>