<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>📖TypeScript 教程 @阮一峰 | 川一土的博客视界</title><meta name="author" content="yiTuChuan"><meta name="copyright" content="yiTuChuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="全面介绍 TypeScript 的核心知识，涵盖类型系统、模块化、命名空间、装饰器、类型声明、配置文件等内容。文章通过大量代码示例和详细说明，帮助读者深入理解 TypeScript 的类型检查机制和高级特性，掌握 TypeScript 在实际开发中的应用。">
<meta property="og:type" content="article">
<meta property="og:title" content="📖TypeScript 教程 @阮一峰">
<meta property="og:url" content="https://zhengzehua.top/2024/12/05/TypeScript%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/index.html">
<meta property="og:site_name" content="川一土的博客视界">
<meta property="og:description" content="全面介绍 TypeScript 的核心知识，涵盖类型系统、模块化、命名空间、装饰器、类型声明、配置文件等内容。文章通过大量代码示例和详细说明，帮助读者深入理解 TypeScript 的类型检查机制和高级特性，掌握 TypeScript 在实际开发中的应用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhengzehua.top/images/butterfly_avatar_img.svg">
<meta property="article:published_time" content="2024-12-05T11:37:00.000Z">
<meta property="article:modified_time" content="2025-06-05T07:35:38.317Z">
<meta property="article:author" content="yiTuChuan">
<meta property="article:tag" content="前端学习,前端开发,Web开发,技术分享,学习感悟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhengzehua.top/images/butterfly_avatar_img.svg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "📖TypeScript 教程 @阮一峰",
  "url": "https://zhengzehua.top/2024/12/05/TypeScript%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/",
  "image": "https://zhengzehua.top/images/butterfly_avatar_img.svg",
  "datePublished": "2024-12-05T11:37:00.000Z",
  "dateModified": "2025-06-05T07:35:38.317Z",
  "author": [
    {
      "@type": "Person",
      "name": "yiTuChuan",
      "url": "https://github.com/Nasir1423"
    }
  ]
}</script><link rel="shortcut icon" href="/images/butterfly_favicon.svg"><link rel="canonical" href="https://zhengzehua.top/2024/12/05/TypeScript%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="VS0CYuuxqYH1AjmSVIi39UiBz0ubcCCtUtHMiSsRQXA"/><meta name="msvalidate.01" content="3C21ED06CE83FA63D0A6E0ADE00F1DEE"/><link rel="stylesheet" href="/css/index.css?v=5.4.0-b2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-JRLJPHP21V"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-JRLJPHP21V')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-JRLJPHP21V', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '📖TypeScript 教程 @阮一峰',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/styles/minimal.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/butterfly_avatar_img.svg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 实用站点</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to top, #2980b9, #6dd5fa, #ffffff);;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/butterfly_nav_logo.svg" alt="Logo"><span class="site-name">川一土的博客视界</span></a><a class="nav-page-title" href="/"><span class="site-name">📖TypeScript 教程 @阮一峰</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 实用站点</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">📖TypeScript 教程 @阮一峰</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-05T11:37:00.000Z" title="发表于 2024-12-05 19:37:00">2024-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-05T07:35:38.317Z" title="更新于 2025-06-05 15:35:38">2025-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">49.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>193分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="TS-概述">TS - 概述</h2>
<p>TypeScript 是由微软开发的一种基于 JavaScript 的编程语言，可看成是 JavaScript 的<strong>超集</strong>。相较于 JavaScript，TypeScript 增加了一个独立的<strong>类型系统</strong>。</p>
<p><strong>类型</strong>（type）指的是一组具有相同特征的值，是<strong>人为添加的一种编程约束和用法提示</strong>。由于变量的类型和对象的属性是<strong>动态</strong>的，JavaScript 是<strong>动态类型语言</strong>，与之相反，TypeScript 是<strong>静态类型语言</strong>。</p>
<h2 id="TS-基本使用">TS - 基本使用</h2>
<h3 id="1-类型声明">1. 类型声明</h3>
<ol>
<li>
<p>变量类型声明</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：TypeScript 规定，变量只有赋值后才能使用，否则就会报错</p>
</blockquote>
</li>
<li>
<p>函数类型声明（参数、返回值）</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params"><span class="attr">num</span>: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-类型推断">2. 类型推断</h3>
<ol>
<li>
<p>变量类型推断</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>; <span class="comment">// foo 被推断为 number 类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数类型推断（返回值）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params"><span class="attr">num</span>: <span class="built_in">number</span></span>) &#123; <span class="comment">// toString 返回值被推断为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-代码运行">3. 代码运行</h3>
<h4 id="3-1-tsc-编译器">3.1 tsc 编译器</h4>
<ol>
<li>
<p>解释：TypeScript 代码只有转换为 JavaScript 代码后，才能在浏览器和 Node.js 中运行，这个过程叫做<strong>编译</strong>（compile）。TypeScript 官方提供的编译器为 <code>tsc</code>，可以将 <code>.ts</code> 脚本转变为 <code>.js</code> 脚本。</p>
<ul>
<li>TypeScript 编译为 JavaScript 时，会<strong>删除全部类型声明和类型相关的代码</strong>，只留下可以运行的 JavaScript 代码。</li>
<li>TypeScript 的类型检查是<strong>编译时</strong>的类型检查，而不是运行时的类型检查。</li>
</ul>
</li>
<li>
<p>安装 <code>npm install -g typescript</code></p>
<blockquote>
<p>补充：安装后，可以使用 <code>tsc -v</code> 或 <code>tsc --version</code> 查看 <code>tsc</code> 版本，从而检查是否安装成功；使用 <code>tsc -h</code> 或 <code>tsc --help</code> 查看基本帮助信息，<code>tsc --all</code> 查看完整帮助信息</p>
</blockquote>
</li>
<li>
<p>编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line">tsc app.ts <span class="comment"># 编译一个 ts 脚本，到当前目录</span></span><br><span class="line">tsc file1.ts file2.ts file3.ts <span class="comment"># 编译多个 ts 脚本，到当前目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带编译参数使用</span></span><br><span class="line"><span class="comment"># --outFile xxx.js 指定编译后的 js 脚本名（默认与源文件一一对应且同名）</span></span><br><span class="line">tsc file1.ts file2.ts --outFile app.js <span class="comment"># 编译多个 ts 脚本为一个 js 脚本，到当前目录</span></span><br><span class="line"><span class="comment"># --outDir xxx 指定编译后的 js 脚本的保存位置（默认保存在当前目录）</span></span><br><span class="line">tsc app.ts --outDir dist <span class="comment"># 编译一个 ts 脚本，到指定目录</span></span><br><span class="line"><span class="comment"># --target xxx 指定编译后的 js 脚本对应的版本（默认编译为低版本的 JavaScript，兼容性考量）</span></span><br><span class="line">tsc --target es2015 app.ts <span class="comment"># 编译一个 ts 脚本，到当前目录，同时控制编译后的 JavaScript 版本</span></span><br><span class="line"><span class="comment"># --noEmitOnError 一旦报错就停止编译，同时不生成编译产物（默认情况不会停止编译，且会生成编译产物）</span></span><br><span class="line">tsc --noEmitOnError app.ts <span class="comment"># 编译一个 ts 脚本，到当前目录，如果报错就停止编译，且不生成编译产物</span></span><br><span class="line"><span class="comment">## --noEmit 只检查类型是否正确，不生成 js 脚本</span></span><br><span class="line">tsc --noEmit app.ts <span class="comment"># 编译一个 ts 脚本，但是不生成 js 脚本</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：TypeScript 允许使用配置文件 <code>tsconfig.json</code>  存储 <code>tsc</code> 的编译参数。只要当前目录有该文件，那么 <code>tsc</code> 就会在编译时自动读取，而不需要再显式地指定参数。如果编译时指定了独立的命令行参数，这些参数会覆盖 <code>tsconfig.json</code> 文件。</p>
</blockquote>
<blockquote>
<p>补充：<code>tsc</code> 编译参数大多与 <code>tsconfig.json</code> 中的属性一一对应，可参考 《<code>tsconfig.json</code> 配置文件》。</p>
</blockquote>
<blockquote>
<p>依赖追踪：编译脚本时，tsc 会自动编译脚本所依赖的所有脚本。</p>
</blockquote>
<blockquote>
<p>注意：<code>tsc app.ts</code> 时，编译器忽略任何 <code>tsconfig.json</code>，使用默认编译选项！！！</p>
</blockquote>
</li>
</ol>
<h4 id="3-2-ts-node-模块">3.2 ts-node 模块</h4>
<ol>
<li>
<p>解释：<code>ts-node</code> 是一个非官方的，可以<strong>直接运行</strong> TypeScript 代码的模块。</p>
</li>
<li>
<p>安装 <code>npm install -g ts-node</code></p>
</li>
<li>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ts-node script.ts <span class="comment"># 方式一：运行 ts 脚本 script.ts</span></span><br><span class="line">npx ts-node script.ts <span class="comment"># 方式二：不安装 ts-node 时，使用 npx 来在线运行 ts 脚本</span></span><br><span class="line">ts-node <span class="comment"># 方式三：打开一个 ts 脚本地 REPL 运行环境</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用 <code>ts-node</code> 运行 <code>ts</code> 脚本时，需要全局安装 <code>typescript</code> 包，并在项目根目录下添加配置文件 <code>tsconfig.json</code>。</p>
</blockquote>
<blockquote>
<p>注意：使用 <code>ts-node</code> 运行 <code>ts</code> 脚本时，且该 <code>ts</code> 脚本是一个 ES6 模块，那么可能会报错！！这是因为 Node.js 支持 ES6 模块是一个实验性的功能，而 <code>ts-node</code> 是根据 Node.js 版本进行适配的。因此一个可行的策略是降低 Node.js 版本到 v18.17.1。（最好在 tsconfig.json 中也补充了配置 { <code>&quot;ts-node&quot;: &#123; esm: true &#125; &#125;</code>，以使得 <code>ts-node</code> 以 ES6 模块化解析 <code>ts</code> 脚本）</p>
</blockquote>
</li>
</ol>
<h2 id="TS-类型系统-1（特殊、基本、包装、Object、值、联合、交叉、type、typeof、作用域、兼容）">TS - 类型系统 1（特殊、基本、包装、Object、值、联合、交叉、type、typeof、作用域、兼容）</h2>
<h3 id="1-特殊类型">1. 特殊类型</h3>
<h4 id="1-1-any">1.1 any</h4>
<ol>
<li>
<p>解释：<code>any</code> 类型表示<strong>没有任何限制</strong>。一旦将变量类型设为 <code>any</code>，TypeScript 就会<strong>关闭对该变量的类型检查</strong>，并且此变量<strong>可以被赋予任意类型的值</strong>，一般不推荐使用该类型。<code>any</code> 类型可以看成是所有其他类型的<strong>全集</strong>，因此 TypeScript 将该类型称为<strong>顶层类型</strong>（top type）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量的类型检查被关闭（往往不是我们所希望的） */</span></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>); <span class="comment">// √</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="string">&quot;hello&quot;</span>; <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量可以被赋予任意类型的值 */</span></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// √</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>适用场景</p>
<ul>
<li>出于某些特殊原因，需要关闭部分变量的类型检查。</li>
<li>为适配老的 JavaScript 项目，使代码能快速迁移到 TypeScript 。</li>
</ul>
</li>
<li>
<p>存在的问题（不建议使用 any 类型的原因）</p>
<ul>
<li>
<p><strong>类型推断</strong>：我们知道，TypeScript 会推断那些没有进行类型声明的变量，如果无法推断，TypeScript 就会将相应变量的类型认定为 <code>any</code>。为了避免这种问题，可以在使用 <code>tsc</code> 编译器进行编译时，使用编译参数 <code>--noImplicitAny</code>，此时只要推断出 <code>any</code> 类型就会报错。但需要注意的是，使用 <code>let</code> 和 <code>var</code> 声明变量时，如果不赋值，也不指定类型，TypeScript 就会推断其类型为 <code>any</code>，且不会报错，为了解决这个安全隐患，<strong>使用 <code>let</code> 和 <code>var</code> 声明变量时，要么赋值，要么显式声明类型</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y; <span class="comment">// 函数参数和返回值都被推断为 any 类型，可能会导致错误</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --noImplicitAny app.ts <span class="comment"># 编译 app.ts 脚本，当推断出 any 类型的变量时报错</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类型污染</strong>：<code>any</code> 类型的变量能够赋值给其他任何类型的变量，进而污染具有正确类型的变量，<strong>把错误留到了运行时</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 类型污染，number 类型的变量 y 此时的值是一个字符串，可能会导致错误</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="1-2-unknown">1.2 unknown</h4>
<ol>
<li>
<p>解释：<code>unknown</code> 类型可被视作<strong>严格版的 <code>any</code> 类型</strong> ，它与 <code>any</code> 类型存在相似之处，同时也增添了一些限制。<code>unknown</code> 类型可以看成是所有其他类型（除了 <code>any</code> 类型）的<strong>全集</strong>，因此 TypeScript 也将该类型称为<strong>顶层类型</strong>（top type）。</p>
<ul>
<li>
<p>相似之处：<strong>所有类型的值均可赋值给 <code>unknown</code> 类型的变量</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// √</span></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制之处</p>
<ul>
<li>
<p><strong><code>unknown</code> 类型的变量不能直接赋值给其他类型的变量</strong>（除了 <code>any</code> 和 <code>unknown</code> 类型），从而避免了 any 类型中存在的类型污染问题。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>: <span class="built_in">unknown</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>: <span class="built_in">boolean</span> = v; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>unknown</code> 类型的变量的属性和方法不能直接被调用</strong>，从而避免了 <code>any</code> 类型的类型检查关闭所带来的问题。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>: <span class="built_in">unknown</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line">v.<span class="property">foo</span>; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>unknown</code> 类型的变量只能进行有限类型的运算</strong>，如 <code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>、<code>!</code>、<code>typeof</code>、<code>instanceof</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>: <span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a + <span class="number">1</span>; <span class="comment">// ×</span></span><br><span class="line">a === <span class="number">1</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>unknown</code> 类型的变量只有经过类型缩小才可以使用</strong>，所谓类型缩小，就是缩小 <code>unknown</code> 类型变量的类型范围，以确保不会出错。通常使用条件判断语句和 <code>typeof</code> 运算符来缩小 <code>unknown</code> 类型变量的类型范围。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = a + <span class="number">10</span>; <span class="comment">// ✓</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>); <span class="comment">// ✓</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>适用场景：<code>unknown</code> 类型可以被看作是更安全的 <code>any</code> 类型，因此<strong>凡是需要设定为 <code>any</code> 类型的变量，通常都应优先考虑设为 <code>unknown</code> 类型</strong>。</p>
</li>
</ol>
<h4 id="1-3-never">1.3 never</h4>
<p>解释：<code>never</code> 类型表示<strong>空类型</strong>，即该类型<strong>不包含任何值</strong>。<code>never</code> 类型可以看成是<strong>空集</strong>，因此该类型是任何其他类型所共有的，TypeScript 将该类型称为<strong>底层类型</strong>（bottom type）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不可以赋任何值给 never 类型的变量 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 场景1：对于不可达的条件分支，其变量类型可能是 never */</span></span><br><span class="line"><span class="keyword">const</span> fn = (<span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// never 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 场景2：对于不可能返回值的函数（如报错），其返回值的类型是 never */</span></span><br><span class="line"><span class="keyword">const</span> fn2 = (): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* never 类型是其他类型所共有的 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>: <span class="built_in">number</span> = <span class="title function_">fn2</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>: <span class="built_in">boolean</span> = <span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>
<h3 id="2-基本类型">2. 基本类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">可取值</th>
<th style="text-align:center">类型声明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>boolean</code></td>
<td style="text-align:center"><code>true</code> 和 <code>false</code></td>
<td style="text-align:center"><code>const x: boolean = true</code></td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center">所有字符串</td>
<td style="text-align:center"><code>const x: string = 'hello'</code></td>
</tr>
<tr>
<td style="text-align:center"><code>number</code></td>
<td style="text-align:center">所有整数和浮点数</td>
<td style="text-align:center"><code>const x: number = 0xffff</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bigint</code></td>
<td style="text-align:center">所有大整数</td>
<td style="text-align:center"><code>const x: bigint = 123n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>symbol</code></td>
<td style="text-align:center">所有的 <code>Symbol</code> 值</td>
<td style="text-align:center"><code>const x: symbol = Symbol();</code></td>
</tr>
<tr>
<td style="text-align:center"><code>object</code></td>
<td style="text-align:center">所有的对象、数组和函数</td>
<td style="text-align:center"><code>const x: object = &#123; foo: 123 &#125;</code><br /><code>const y: object = [1, 2, 3]</code><br /><code>const z: object = (n: number) =&gt; n + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>undefined</code></td>
<td style="text-align:center"><code>undefined</code>，表示未定义</td>
<td style="text-align:center"><code>const x: undefined = undefined</code></td>
</tr>
<tr>
<td style="text-align:center"><code>null</code></td>
<td style="text-align:center"><code>null</code>，表示空</td>
<td style="text-align:center"><code>const x: null = null</code></td>
</tr>
</tbody>
</table>
<p>补充说明</p>
<ul>
<li><code>bigint</code> 类型与 <code>number</code> 类型<strong>不兼容</strong>。</li>
<li><code>bigint</code> 类型由 ES2020 标准引入，如果使用该类型，<strong><code>tsc</code> 编译器的目标 JavaScript 版本不能低于 ES2020</strong>（即 <code>target</code> 参数不低于 <code>es2020</code>）。</li>
<li><code>undefined</code> 和 <code>null</code> 即可以作为<strong>值</strong>，也可以作为<strong>类型</strong>。</li>
<li><code>undefined</code> 和 <code>null</code> 能够赋值给其他任何类型的变量。可以使用 <code>--strictNullChecks</code> 编译选项来规避这种情况，此时 <code>undefined</code> 和 <code>null</code> 无法赋值给其他类型的变量了（除了 <code>any</code> 和 <code>unknown</code> 类型的变量）</li>
<li>当一个没有声明类型的变量被赋值 <code>undefined</code> 或 <code>null</code> 时，<strong>不同的编译选项可能会导致不同的类型推断</strong>。
<ul>
<li>关闭 <code>--noImplicitAny</code> 和 <code>--strictNullChecks</code>，变量被推断为 <code>any</code>。</li>
<li>打开 <code>--strictNullChecks</code>，值为 <code>undefined</code> 的变量被推断为 <code>undefined</code> 类型，值为 <code>null</code> 的变量被推断为 <code>null</code> 类型。</li>
</ul>
</li>
</ul>
<h3 id="3-包装对象类型">3. 包装对象类型</h3>
<ol>
<li>
<p>原始类型（primitive type）：表示<strong>最基本的、不可再分</strong>的值，包括：<code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>。</p>
</li>
<li>
<p>包装对象（wrapper object）：五种原始类型的值均有其对应的包装对象，也就是原始类型的值在必要时会<strong>自动转换</strong>而成的对象。</p>
<blockquote>
<p>补充：可以通过 <code>new Boolean()</code>、<code>new String()</code>、<code>new Number()</code> 的方式获取 <code>boolean</code>、<code>string</code>、<code>number</code> 类型的值所对应的包装对象；可以通过 <code>Object(Symbol())</code>、<code>Object(BigInt())</code> 的方式获取 <code>symbol</code> 和 <code>bigint</code> 类型的值对应的包装对象。</p>
<p>补充：原始类型的值及其包装对象又可称之为<strong>字面量</strong>和<strong>包装对象</strong>，如 <code>&quot;hello&quot;</code> 是字面量，其包装对象为 <code>new String(&quot;hello&quot;)</code>。</p>
</blockquote>
</li>
<li>
<p>包装对象类型：五种原始类型对应的包装对象的类型，用大写表示，包括 <code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>BigInt</code>、<code>Symbol</code>。<strong>包装对象类型包含包装对象和字面量两种情况，原始类型只包含字面量</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>: <span class="title class_">String</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// √ 包装类型 - 字面量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>: <span class="title class_">String</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// √ 包装类型 - 包装对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s3</span>: <span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// √ 原始类型 - 字面量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s4</span>: <span class="built_in">string</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// × 原始类型 - 包装对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：建议只使用原始类型，不使用包装对象类型。</p>
<p>补充：<code>symbol</code> 和 <code>Symbol</code> 之间，以及 <code>bigint</code> 和 <code>BigInt</code> 之间没有差异。</p>
</blockquote>
</li>
</ol>
<h3 id="4-Object-object">4. Object/object</h3>
<ol>
<li>
<p><code>Object</code> 类型：表示 JavaScript 中的<strong>广义对象</strong>，即所有能够转变为对象的值皆为 <code>Object</code> 类型（除了 <code>undefined</code> 和 <code>null</code>）。空对象 <code>&#123;&#125;</code> 是 <code>Object</code> 类型的简写形式。</p>
<blockquote>
<p>补充：<code>Object</code> 类型的对象可以接受各种类型的属性，但是不能读取，否则会报错。</p>
</blockquote>
</li>
<li>
<p><code>object</code> 类型：表示 JavaScript 中的<strong>狭义对象</strong>，仅包含对象、数组和函数。</p>
</li>
</ol>
<h3 id="5-值类型">5. 值类型</h3>
<ol>
<li>
<p>值类型：将单个值作为一种类型，称其为 “值类型”。当使用 <code>const</code> 声明变量，并给该变量赋一个原始值时，TypeScript 就会推断该变量的类型为值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">&#x27;https&#x27;</span>; <span class="comment">// x 的类型被自动推断为 &quot;https&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：如果 <code>const</code> 声明的变量所赋的值为对象，那么 TypeScript 则不会推断该变量的类型为值类型。</p>
</blockquote>
</li>
<li>
<p>与值类型有关的报错</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: <span class="number">5</span> = <span class="number">4</span> + <span class="number">1</span>; <span class="comment">// ×，因为 x 的类型被认定是 5，而 4 + 1 的类型被推测为 number，5 是 number 的子类型，number 是 5 的父类型，父类型不能赋值给子类型，子类型能够赋值给父类型。在此由于将 number 这个父类型赋值给 5 这个子类型，所以发生报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修正方式：使用 “类型断言”，即告诉 TypeScript 4 + 1 的类型是 5，而不是 number */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: <span class="number">5</span> = (<span class="number">4</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="number">5</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-联合类型">6. 联合类型</h3>
<ol>
<li>
<p>解释：多个类型通过符号 <code>|</code> 能够组成一个新的类型，称作联合类型（union types）。任意一个值只要属于 <code>A</code> 类型<strong>或者</strong> <code>B</code> 类型，那么也就属于联合类型 <code>A | B</code>，其中 <code>A</code> 和 <code>B</code> 是合法的 TypeScript 类型。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p>单行书写</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: A | B | C | ...;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多行书写</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: </span><br><span class="line">	| A</span><br><span class="line">	| B</span><br><span class="line">	| C</span><br><span class="line">	| ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="7-交叉类型">7. 交叉类型</h3>
<ol>
<li>
<p>解释：多个类型通过符号 <code>&amp;</code> 能够组成一个新的类型，称作交叉类型（intersection tyoe）。任意一个值<strong>同时</strong>属于 A 类型<strong>和</strong> B 类型，那么也就属于交叉类型 <code>A &amp; B</code>，其中 <code>A</code> 和 <code>B</code> 是合法的 TypeScript 类型。</p>
</li>
<li>
<p>语法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: A &amp; B &amp; C &amp; ...;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>适用场景：为对象类型添加新属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>: <span class="built_in">number</span> &#125;; <span class="comment">// A 类型表示具有 number 类型的 foo 属性的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = A &amp; &#123; <span class="attr">bar</span>: <span class="built_in">number</span> &#125;; <span class="comment">// B 类型对 A 类型进行扩展，要求对象还要有 number 类型的 bar 属性</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="8-类型别名-type">8. 类型别名 - type</h3>
<ol>
<li>
<p>解释：TypeScript 中允许通过 <code>type</code> 关键字来定义一个<strong>类型的别名</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="string">&quot;Male&quot;</span> | <span class="string">&quot;Female&quot;</span>; <span class="comment">// Gender 类型，取值范围为 &quot;Male&quot; 和 &quot;Female&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Weather</span> = <span class="string">&quot;Sunny&quot;</span> | <span class="string">&quot;Clear&quot;</span> | <span class="string">&quot;Rainy&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>类型别名的作用域是<strong>块级作用域</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;blue&#x27;</span>; <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在同一作用域中，类型别名<strong>不允许重名</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;blue&#x27;</span>; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型别名<strong>允许嵌套</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Province</span> = <span class="string">&quot;Shaan&#x27;xi&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Address</span> = <span class="string">`Xi&#x27;an <span class="subst">$&#123;Province&#125;</span> <span class="subst">$&#123;Country&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Address</span> = <span class="string">&quot;Xi&#x27;an Shaan&#x27;xi China&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="9-类型运算-typeof">9. 类型运算 - typeof</h3>
<ol>
<li>
<p>解释：<code>typeof</code> 运算符在 JavaScript 和 TypeScript 中具有不同的功能。在 JavaScript 中，<code>typeof</code> 接受一个操作数，返回一个<strong>字符串</strong>，代表操作数的类型。在 TypeScript 中，<code>typeof</code> 也接受一个操作数，但是返回的是操作数的 <strong>TypeScript 类型</strong>。前者称之为<strong>值运算</strong>，后者称之为<strong>类型运算</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 值运算 - JavaScript 中的 typeof */</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">13</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;foo&quot;</span>; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">parseInt</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(); <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">13n</span>; <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类型运算 - TypeScript 中的 typeof */</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="keyword">typeof</span> a; <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="keyword">typeof</span> a.<span class="property">x</span>; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>TypeScript 代码中，可能<strong>同时存在两种 <code>typeof</code> 运算符</strong>，即一种用于<strong>值运算</strong>，一种用于<strong>类型运算</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="keyword">typeof</span> a; <span class="comment">// 类型运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    b = a; <span class="comment">// 值运算</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TypeScript 代码编译后，用于<strong>值运算</strong>的 <code>typeof</code> 运算符会被<strong>保留</strong>，用于<strong>类型运算</strong>的 <code>typeof</code> 运算符会被<strong>全部删除</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 上一个 ts 示例代码的编译结果 */</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b; <span class="comment">// 类型运算 - typeof 被删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    b = a; <span class="comment">// 值运算 - typeof 被保留</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TypeScript 代码在编译时不会进行 JavaScript 的值运算，所以用于<strong>类型运算</strong>的 <code>typeof</code> 运算符的操作数<strong>不能是需要进行运算的表达式</strong>。此外，用于<strong>类型运算</strong>的 <code>typeof</code> 操作符的操作数<strong>不能是类型</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> <span class="title class_">Date</span>(); <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyAge</span> = <span class="keyword">typeof</span> <span class="title class_">Age</span>; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="10-类型作用域-块级">10. 类型作用域 - 块级</h3>
<p>解释：TypeScript 支持<strong>块级类型声明</strong>，即类型可以声明在代码块中，并且只在当前代码块中生效。</p>
<h3 id="11-类型兼容">11. 类型兼容</h3>
<p>解释：TypeScript 中规定<strong>子类型兼容父类型，<strong>即</strong>凡是可以使用父类型的地方，都可以使用子类型</strong>，反之则不行。如 <code>number | string</code> 就是 <code>number</code> 的父类型。</p>
<h2 id="TS-类型系统-2（数组、元组、symbol）">TS - 类型系统 2（数组、元组、symbol）</h2>
<h3 id="1-数组">1. 数组</h3>
<h4 id="1-1-基本使用">1.1 基本使用</h4>
<ol>
<li>
<p>数组（array）：TypeScript 中的数组规定<strong>所有成员的类型必须相同，成员数量不定</strong>。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><code>elementType[]</code> 或 <code>(elementType)[]</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3</span>]; <span class="comment">// 考虑到运算符优先级，复杂的成员类型需要写在括号中</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Array&lt;elementType&gt;</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>数组成员的数量可以动态变化，因此<strong>对数组进行越界访问并不会报错</strong>。</p>
</li>
<li>
<p>TypeScript 使用 <code>elementType[][]</code> 的形式表示<strong>二维数组</strong>。</p>
</li>
<li>
<p>TypeScript 允许<strong>通过索引读取数组成员的类型</strong>，也就是对数组类型进行索引访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 情况一：访问指定索引的成员类型 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="number">0</span>]; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况二：访问指定类型的索引的成员类型 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Names2</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name2</span> = <span class="title class_">Names2</span>[<span class="built_in">number</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当变量的初始值为<strong>空数组</strong>时，TypeScript 会推断该变量的类型为 <code>any[]</code> ，之后每当给该数组赋值，TypeScript 都会<strong>自动更新对该变量的类型推断</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []; <span class="comment">// 推断类型为 any[]</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>); <span class="comment">// 推断类型为 number[];</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&quot;HELLO&quot;</span>); <span class="comment">// 推断类型为 (string | number)[]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="1-2-只读数组">1.2 只读数组</h4>
<ol>
<li>
<p>只读数组：相较于普通数组，TypeScript 规定只读数组没有 <code>pop()</code>、<code>push()</code> 等会改变原数组的方法，因此也称<strong>只读数组为普通数组的父类型（成员类型需相同），普通数组是只读数组的子类型</strong>。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><code>readonly elementType[]</code> 或 <code>readonly (elementType)[]</code></p>
</li>
<li>
<p><code>ReadonlyArray&lt;elementType&gt;</code></p>
</li>
<li>
<p><code>Readonly&lt;elementType[]&gt;</code></p>
</li>
<li>
<p><code>[] as const</code>（<code>const</code> 断言，<strong>只读的值类型</strong>）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>: <span class="title class_">Readonly</span>&lt;<span class="built_in">number</span>[]&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 不能写成 let arr4: number[] = [1, 2, 3] as const !</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意事项：由于只读数组是普通数组的父类型（成员类型相同），因此如果在需要普通数组的地方使用只读数组，则应使用 <code>as</code> 关键字进行类型断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"><span class="attr">arr</span>: <span class="built_in">number</span>[]</span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">func</span>(arr <span class="keyword">as</span> <span class="built_in">number</span>[]); <span class="comment">// 父类型 readonly number[]，子类型 number[]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-元组">2. 元组</h3>
<h4 id="2-1-基本使用">2.1 基本使用</h4>
<ol>
<li>
<p>元组（tuple）：TypeScript 中的元组就是<strong>成员类型可以自由设置的数组</strong>，因此元组的<strong>每个成员的类型都必须明确声明</strong>。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><code>[elementType1, elementType2, elementType3]</code></p>
</li>
<li>
<p><code>[elementType1, elementType2, elementType3?]</code>（<strong>可选成员</strong>，必须位于必选成员之后）</p>
</li>
<li>
<p><code>[elementType1, ...elementType2, elementType3[]]</code>（<strong>不限数量的成员</strong>，可以位于任意位置）</p>
</li>
<li>
<p><code>[elementName1: elementType1, elementName2: elementType2, elementName3: elementType3]</code>（<strong>指定成员名</strong>，仅起到说明作用）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">t1</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">t2</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>?] = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">t3</span>: [<span class="built_in">number</span>, ...<span class="built_in">string</span>[], <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">t4</span>: [<span class="attr">num</span>: <span class="built_in">number</span>, <span class="attr">msg</span>: <span class="built_in">string</span>, <span class="attr">flag</span>: <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>TypeScript 中<strong>数组的成员类型写在方括号外</strong>（如 <code>number[]</code>），<strong>元组的成员类型写在方括号里</strong>（如 <code>[number]</code>）。</p>
</li>
<li>
<p>使用元组时<strong>必须给出类型声明</strong>，不然 TypeScript 会将其自动推断为一个数组。</p>
</li>
<li>
<p>TypeScript 会<strong>根据元组的成员类型推断成员数量</strong>（或元组长度）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. 元组没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">t1.<span class="property">length</span> === <span class="number">3</span>; <span class="comment">// ×，只能是 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 元组包含可选成员，TypeScript 会推断出元组的可能的成员数量 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t2</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">0</span>];</span><br><span class="line">t2.<span class="property">length</span> === <span class="number">3</span>; <span class="comment">// ×，可以是 1 或 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 元组中包含使用了扩展运算符的数组或元组，TypeScript 无法推断出元组的成员数量 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t3</span>: [...<span class="built_in">number</span>[]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">t3.<span class="property">length</span> === <span class="number">9</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>扩展运算符可以将<strong>数组或元组</strong>转换为一个逗号分隔的序列。TypeScript <strong>无法确定</strong>数组转换的序列的成员数量，但是<strong>可以确定</strong>元组转换的序列的成员数量，以及 <code>const</code> 断言的值类型转换的序列的成员数量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span></span>) =&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 数组转换的序列的成员数量无法确定 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">func</span>(...a); <span class="comment">// ×，因为 TypeScript 无法确定 a 转换的序列的成员数量为 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 元组转换的序列的成员数量可以确定 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">func</span>(...b); <span class="comment">// √，因为 TypeScript 可以确定 b 转换的序列的成员数量为 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. const 断言转换的序列的成员数量可以确定 */</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// c 的 类型为 readonly [1, 2]</span></span><br><span class="line"><span class="title function_">func</span>(...c);; <span class="comment">// √，因为 TypeScript 可以确定 c 转换的序列的成员数量为 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>[] as const</code> 断言的类型是<strong>只读的值类型</strong>，即可以当作<strong>只读数组</strong>，也可以当作<strong>只读元组</strong>。</p>
</blockquote>
</li>
<li>
<p>因为在使用元组时需要声明每个成员的类型，<strong>大多数情况下元组的成员数量有限</strong>，所以此时<strong>不允许对元组进行越界访问</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">t</span>: [<span class="built_in">number</span>, <span class="built_in">boolean</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;hello&quot;</span>];</span><br><span class="line">t[<span class="number">1</span>]; <span class="comment">// √</span></span><br><span class="line">t[<span class="number">3</span>]; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TypeScript 允许<strong>通过索引读取元组成员的类型</strong>，也就是对元组类型进行索引访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 情况一：访问指定索引的成员类型 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Eles</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Ele</span> = <span class="title class_">Eles</span>[<span class="number">1</span>]; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况二：访问指定类型的索引的成员类型 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Eles2</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Ele2</span> = <span class="title class_">Eles2</span>[<span class="built_in">number</span>]; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-只读元组">2.2 只读元组</h4>
<ol>
<li>
<p>只读元组：与只读数组类似，<strong>只读元组是普通元组的父类型（成员类型需对应相同），普通元组是只读元组的子类型</strong>。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><code>readonly [elementType1, elementType2, elementType3]</code></p>
</li>
<li>
<p><code>Readonly&lt;[elementType1, elementType2, elementType3]&gt;</code></p>
</li>
<li>
<p><code>[] as const</code>（<code>const</code> 断言，只读的值类型）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">t2</span>: <span class="title class_">Readonly</span>&lt;[<span class="built_in">number</span>, <span class="built_in">boolean</span>]&gt; = [<span class="number">1</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">let</span> t3 = [<span class="number">1</span>, <span class="literal">true</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意事项：由于只读元组是普通元组的父类型（成员类型需对应相同），因此如果在需要普通元组的地方使用只读元组，则应使用 <code>as</code> 关键字进行类型断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"><span class="attr">t</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) =&gt; &#123; &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">t</span>: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">func</span>(t <span class="keyword">as</span> [<span class="built_in">number</span>, <span class="built_in">number</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-symbol">3. symbol</h3>
<h4 id="3-1-基本介绍">3.1 基本介绍</h4>
<p>JavaScript 中的 <code>Symbol</code> 是 ES2015 引入的一种新的原始类型的值，其特点是：每一个 <code>Symbol</code> 值都是<strong>唯一的</strong>，与其他任何值都不相等。</p>
<p>JavaScript 中的 <code>Symbol</code> 值可以通过 <code>Symbol()</code> 函数生成。也可以通过 <code>Symbol.for(key: string)</code> 函数生成，相同的 <code>key</code> 对应相同的 <code>Symbol</code> 值。</p>
<p>TypeScript 中使用 <code>symbol</code> 类型来表示 <code>Symbol</code> 值。</p>
<h4 id="3-2-unique-symbol">3.2 unique symbol</h4>
<ol>
<li>
<p>解释：<code>unique symbol</code> 是 <code>symbol</code> 的一个<strong>子类型</strong>，用于表示<strong>单个的，某个具体的</strong> <code>Symbol</code> 值。类型为 <code>unique symbol</code> 的变量只能使用 <code>const</code> 命令声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(); <span class="comment">// √</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(); <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>使用 <code>const</code> 关键字声明变量，并赋 <code>Symbol</code> 值时，变量类型被自动推断为 <code>unique symbol</code>。可以简化 <code>unique symbol</code> 类型的变量声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> z = <span class="title class_">Symbol</span>(); <span class="comment">// 等价于 const z: unique symbol = Symbol();</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>每个声明为 <code>unique symbol</code> 类型的变量的<strong>值不同，类型也不同</strong>！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">a === b; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>因为 <code>Symbol.for(key)</code> 在 <code>key</code> 相同时返回相同的 <code>Symbol</code> 值，因此<strong>可能会导致多个 <code>unique symbol</code> 类型的变量的值相同</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">q</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p === q; <span class="comment">// 虽然 p 和 q 的值相同，但是其类型不同，因此不能作 === 运算</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>unique symbol</code> 类型是 <code>symbol</code> 类型的<strong>子类型</strong>，因此在使用 <code>symbol</code> 的时候可以使用 <code>unique symbol</code>，反之则不行。</p>
</li>
<li>
<p><code>unique symbol</code> 类型的值可以作为<strong>对象的属性名</strong>，而 <code>symbol</code> 类型的值不行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">m</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">    [m]: <span class="built_in">string</span>; <span class="comment">// unique symbol 可以作为属性名</span></span><br><span class="line">    [n]: <span class="built_in">string</span>; <span class="comment">// symbol 不可以作为属性名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以通过 <code>static readonly fieldName: unique symbol = Symbol()</code> 的方式声明一个类型为 <code>unique symbol</code> 的<strong>静态只读属性</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="attr">foo</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将 <code>Symbol()</code> 函数的值赋给一个 <code>let</code> 声明的变量，其类型将会被推断为 <code>symbol</code>；赋给一个 <code>const</code> 声明的变量，其类型将会被推断为 <code>unique symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j = <span class="title class_">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">const</span> k = <span class="title class_">Symbol</span>(); <span class="comment">// unique symbol</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将 <code>symbol</code> 或 <code>unique symbol</code> 类型的变量赋值给 <code>const</code> 或 <code>let</code> 声明的变量，其类型<strong>都会</strong>被推断为 <code>symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> f = e; <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> h = g; <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="TS-类型系统-3（函数、对象）">TS - 类型系统 3（函数、对象）</h2>
<h3 id="1-函数">1. 函数</h3>
<h4 id="1-1-基本使用-2">1.1 基本使用</h4>
<ol>
<li>
<p>解释：函数类型声明，即在声明函数时，给出<strong>参数</strong>的类型和<strong>返回值</strong>的类型。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><code>function(para1: paraType1, para2: paraType2, ...): returnType&#123;&#125;</code>（函数声明）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> speakHi = <span class="keyword">function</span> (<span class="params"><span class="attr">msg</span>: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>(para1: paraType1, para2: paraType2,...) =&gt; returnType</code>（函数类型，一般写法）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">speakHello</span>: <span class="function">(<span class="params"><span class="attr">msg</span>: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span> (<span class="params">msg</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>&#123; (para1: paraType1, para2: paraType2,...): returnType &#125;</code>（函数类型，对象写法）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">speakWelcome</span>: &#123; (<span class="attr">msg</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#125; = <span class="keyword">function</span> (<span class="params">msg</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg) &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：当<strong>函数本身存在属性</strong>时，多使用这种函数类型声明方式</p>
</blockquote>
</li>
<li>
<p><code>type FuncTypeName = (para1: paraType1, para2: paraType2,...) =&gt; returnType</code> 或 <code>type FuncTypeName = &#123; (para1: paraType1, para2: paraType2,...): returnType &#125;</code>（函数类型，<code>type</code> 写法）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> func = &#123; (<span class="attr">msg</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">speakWelcome</span>: func = <span class="keyword">function</span> (<span class="params">msg</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>interface FuncTypeName &#123; (para1: paraType1, para2: paraType2,...): returnType &#125;</code>（函数类型，<code>interface</code> 写法）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IFunc</span> &#123; (<span class="attr">msg</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">speakYes</span>: <span class="title class_">IFunc</span> = <span class="keyword">function</span> (<span class="params">msg</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>如果不指定参数类型，TypeScript 会推断参数类型为 <code>any</code>；返回值类型通常可以被 TypeScript 自动推断而得出。</p>
</li>
<li>
<p>函数类型中的参数名称<strong>可以</strong>与实际函数的参数名称<strong>不一致</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">printf</span>: <span class="function">(<span class="params"><span class="attr">a</span>: <span class="built_in">any</span>, <span class="attr">b</span>: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="function">(<span class="params">para1, para2</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(para1, para2) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数类型中的参数数量可以<strong>多于</strong>实际函数的参数数量，但不能小于。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> func = <span class="function">(<span class="params"><span class="attr">a</span>: <span class="built_in">any</span>, <span class="attr">b</span>: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">printf1</span>: func = <span class="function">(<span class="params">para1</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(para1) &#125; <span class="comment">// √，实际函数参数数量可以少于</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">printf2</span>: func = <span class="function">(<span class="params">para1, para2, para3</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(para1, para2, para3) &#125; <span class="comment">// ×，实际函数参数数量不能多余！</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用 <code>typeof</code> 运算符计算一个函数变量的函数类型，并将其用作另一个变量的类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="function">(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">del</span>: <span class="keyword">typeof</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数内部允许声明其他类型，并只在该函数内部有效，称之为<strong>局部类型</strong>。</p>
</li>
<li>
<p>如果一个函数的返回值是一个函数，那么该函数称之为<strong>高阶函数</strong>（higher-order function）。</p>
</li>
</ul>
</li>
</ol>
<h4 id="1-2-Function">1.2 Function</h4>
<p><code>Function</code> 也是一种函数类型，任何函数都归属于该类型。<code>Function</code> 表示对函数<strong>不做任何约束</strong>，接受任意数量的参数，参数和返回值的类型皆为 <code>any</code>。</p>
<h4 id="1-3-特殊参数">1.3 特殊参数</h4>
<h5 id="可选参数">可选参数</h5>
<p>解释：参数名后加问号（<code>?</code>）意味着该参数为可选参数，即调用函数时该参数能够省略。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">sum</span>: <span class="function">(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y === <span class="literal">undefined</span>) <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的可选参数只能处于<strong>参数列表的尾部</strong>，在必选参数之后。</li>
<li>可选参数的类型实际上为<strong>原始类型<code>|undefined</code></strong>。</li>
</ul>
<h5 id="参数解构">参数解构</h5>
<p>解释：元组参数或对象参数在函数的参数列表中被拆解为若干参数，称其为参数解构。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解构元组 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">string</span>]</span>): <span class="built_in">void</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解构对象 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">&#123; name, age, gender &#125;: &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="built_in">string</span> &#125;</span>): <span class="built_in">string</span> &#123; <span class="keyword">return</span> name + age + gender &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解构对象（对象类型由 type 别名定义） */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Stu</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>, <span class="attr">grade</span>: <span class="built_in">number</span>, <span class="attr">className</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params">&#123; name, age, grade, className &#125;: <span class="title class_">Stu</span></span>): <span class="built_in">string</span> &#123; <span class="keyword">return</span> name + age + grade + className &#125;</span><br></pre></td></tr></table></figure>
<h5 id="rest-参数">rest 参数</h5>
<p>解释：参数名前加省略号（<code>...</code>）意味着该参数为 <code>rest</code> 参数，表示函数中剩余的所有参数，该参数可分为<strong>数组</strong>（剩余参数类型相同）和<strong>元组</strong>（剩余参数类型不同）两种类型。其中，元组类型的 <code>rest</code> 参数需要声明每一个成员的类型，同时元组中的成员也可以标记为可选的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组类型的 rest 参数 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, ...<span class="attr">b</span>: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b) &#125;;</span><br><span class="line"><span class="title function_">func1</span>(<span class="number">1</span>); <span class="comment">// 1,  [] </span></span><br><span class="line"><span class="title function_">func1</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1,  [2] </span></span><br><span class="line"><span class="title function_">func1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 1,  [2, 3] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元组类型的 rest 参数 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, ...<span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>]</span>): <span class="built_in">void</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b) &#125;;</span><br><span class="line"><span class="title function_">func2</span>(<span class="number">1</span>); <span class="comment">// ×</span></span><br><span class="line"><span class="title function_">func2</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// ×</span></span><br><span class="line"><span class="title function_">func2</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>); <span class="comment">// 1,  [2, &quot;3&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元组类型的 rest 参数，包含可选的成员 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, ...<span class="attr">b</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>?]</span>): <span class="built_in">void</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b) &#125;;</span><br><span class="line"><span class="title function_">func3</span>(<span class="number">1</span>); <span class="comment">// ×</span></span><br><span class="line"><span class="title function_">func3</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1,  [2] </span></span><br><span class="line"><span class="title function_">func3</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>); <span class="comment">// 1,  [2, &quot;3&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元组类型的 rest 参数 + 参数解构 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func4</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, ...[b1, b2]: [<span class="built_in">number</span>, <span class="built_in">string</span>]</span>): <span class="built_in">void</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b1, b2) &#125;;</span><br><span class="line"><span class="title function_">func4</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>); <span class="comment">// 1,  2,  &quot;3&quot; </span></span><br></pre></td></tr></table></figure>
<h5 id="只读参数">只读参数</h5>
<p>解释：参数类型前边加上 <code>readonly</code> 关键字意味着该参数为只读参数。目前，<code>readonly</code> 关键字只允许在<strong>数组和元组</strong>类型的参数上应用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"><span class="attr">arr</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-特殊返回值">1.4 特殊返回值</h4>
<h5 id="void">void</h5>
<p>解释：该类型表示函数<strong>没有返回值</strong>。</p>
<ul>
<li>
<p><code>void</code> 类型<strong>允许函数返回 <code>undefined</code> 或 <code>null</code></strong>。但如果打开了 <code>strictNullChecks</code> 编译选项，此时函数只能返回 <code>undefined</code>，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// √</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果打开 strictNullChecks 编译选项，则会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>; <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果<strong>变量、对象方法、函数参数</strong>的类型是一个返回值为 <code>void</code> 类型的函数，此时可以给其赋值一个有返回值的函数，并且不会报错。这是因为 TypeScript 认为此时的 <code>void</code> 类型表示该函数的<strong>返回值没有利用价值</strong>，或者<strong>不应该使用该函数的返回值</strong>。因此，<strong>一旦使用了该函数的返回值，就会报错</strong>。</p>
<blockquote>
<p>联想：这样设计是具有现实意义的，比如数组方法 <code>Array.prototype.forEach(fn)</code> 的参数 <code>fn</code> 就是一个返回值为 <code>void</code> 的函数，其可以被赋值为一个有返回值的函数，其返回值不会被使用。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回值为 void 类型的函数变量被赋值为一个有返回值的函数 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">func1</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">123</span> &#125;;</span><br><span class="line"><span class="comment">/* 返回值为 void 类型的对象方法被赋值为一个有返回值的函数 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">func2</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">123</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回值为 void 类型的函数参数被赋值为一个有返回值的函数 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"><span class="attr">func3</span>: () =&gt; <span class="built_in">void</span></span>) &#123; <span class="title function_">func3</span>() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* void 类型的函数，表示其返回值不应该被使用，否则就会报错 */</span></span><br><span class="line"><span class="title function_">func1</span>() * <span class="number">2</span>; <span class="comment">// ×</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Person</span>()).<span class="title function_">func2</span>() * <span class="number">2</span>; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果<strong>函数字面量</strong>的类型是一个返回值为 <code>void</code> 类型的函数，此时是不能有返回值的（<code>undefined</code> 和 <code>null</code> 除外）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>): <span class="built_in">void</span> &#123; <span class="keyword">return</span> <span class="number">123</span> &#125;; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果函数在运行中必定会<strong>报错</strong>，则可以将返回值类型写为 <code>void</code> 。</p>
</li>
<li>
<p>如果将一个变量类型设置为 <code>void</code>，此时只能将其赋值为 <code>undefined</code> 或 <code>null</code>（没有打开 <code>strictNullChecks</code> 编译选项）。</p>
</li>
</ul>
<h5 id="never">never</h5>
<p>解释：该类型表示<strong>肯定不会出现的值</strong>。如果函数<strong>抛出异常</strong>或<strong>陷入了死循环</strong>，那么该函数就无法正常返回一个值，此时函数的返回值类型就是 <code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数抛出异常 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;never-test&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数陷入死循环 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;never-test&#x27;</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>函数返回值类型为 <code>never</code>，表示函数<strong>无法正常执行结束</strong>，不可能有返回值；函数返回值类型为 <code>void</code>，表示函数<strong>可以正常执行结束</strong>，但是不返回值（或者返回 <code>undefined</code>）。</p>
</li>
<li>
<p>程序中调用一个返回值类型为 <code>never</code> 的函数，会导致程序在该函数调用的位置终止，即不会继续执行后续的代码。</p>
</li>
<li>
<p>如果函数在某些情况下能够正常执行并返回值，在另一些情况下无法正常执行，此时其返回值类型可以是正常执行情况下的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下函数的返回值类型实际上为 never|number，但是由于 never 是底层类型，never|number 等价于 number */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-5-函数重载">1.5 函数重载</h4>
<ol>
<li>
<p>解释：有些函数（包含对象的方法）可以根据参数<strong>类型</strong>或<strong>个数</strong>不同而执行不同逻辑，称之为<strong>函数重载</strong>（function overload）。函数重载该有利于精确描述函数参数与返回值之间的对应关系。</p>
</li>
<li>
<p>语法：为了实现函数重载，TypeScript 要求提供<strong>多个函数重载声明</strong>和<strong>一个函数具体实现</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"><span class="attr">a</span>: paraType1, <span class="attr">b</span>: par2Type2</span>): returnType1; <span class="comment">// 重载声明 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"><span class="attr">a</span>: paraType3, <span class="attr">b</span>: paraType4</span>): returnType2; <span class="comment">// 重载声明 2</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	重载声明的对象写法</span></span><br><span class="line"><span class="comment">	type func = &#123;</span></span><br><span class="line"><span class="comment">		(a: paraType1, b: par2Type2): returnType1;</span></span><br><span class="line"><span class="comment">		(a: paraType3, b: paraType4): returnType2;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"><span class="attr">a</span>: paraType1 | paraType2, <span class="attr">b</span>: paraType2 | paraType4</span>): returnType1 | returnType2 &#123; <span class="comment">// 具体实现</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> paraType1 === <span class="string">&quot;paraType1&quot;</span> &amp;&amp; <span class="keyword">typeof</span> paraType2 === <span class="string">&quot;paraType2&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/* 重载声明 1 的具体实现 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> paraType3 === <span class="string">&quot;paraType3&quot;</span> &amp;&amp; <span class="keyword">typeof</span> paraType4 === <span class="string">&quot;paraType4 &quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/* 重载声明 2 的具体实现 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;非法的函数参数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>函数的<strong>重载声明</strong>和函数的<strong>具体实现</strong>之间不能包含其他代码，否则会报错。</li>
<li>因为 TypeScript 按顺序从上到下检查函数的重载声明，因此<strong>要将类型最宽的重载声明放在最下边</strong>，以防覆盖其他类型声明。</li>
<li><strong>不使用重载声明也能够实现函数重载</strong>，但是此时会丧失<strong>参数与返回值之间存在的对应关系</strong>，所以如果参数的选择不影响返回值类型时，可以省略重载声明。</li>
</ul>
</li>
</ol>
<h4 id="1-6-构造函数">1.6 构造函数</h4>
<p>构造函数的类型声明</p>
<ul>
<li>语法1 <code>type ConstructorTypeName = new (para1： paraType1, para2: paraType2, ...) =&gt; ObjectType</code></li>
<li>语法2 <code>type ConstructorTypeName = &#123; new (para1： paraType1, para2: paraType2, ...): ObjectType&#125;</code></li>
</ul>
<blockquote>
<p>补充：如果一个函数即可以当作构造函数使用，又可以当作普通函数使用，则可以使用以下语法进行类型声明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FuncTypeName</span> = &#123; </span><br><span class="line">    <span class="title function_">new</span> (para1： paraType1, <span class="attr">para2</span>: paraType2, ...): <span class="title class_">ObjectType</span>; <span class="comment">// 构造函数类型</span></span><br><span class="line">    (para1： paraType1, <span class="attr">para2</span>: paraType2, ...): returnType; <span class="comment">// 普通函数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-对象">2. 对象</h3>
<h4 id="2-1-基本使用-2">2.1 基本使用</h4>
<ol>
<li>
<p>解释：对象类型声明，即在声明对象时，指定对象<strong>属性</strong>的类型和<strong>方法</strong>的类型。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p>一般写法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 语法 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">propertyName</span>: propertyType; <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">methodName1</span>: <span class="function">(<span class="params"><span class="attr">para1</span>: paraType1, <span class="attr">para2</span>: paraType2</span>) =&gt;</span> returnType1; <span class="comment">// 方法 - 方式 I</span></span><br><span class="line">    <span class="title function_">methodName2</span>(<span class="attr">para1</span>: paraType1, <span class="attr">para2</span>: paraType2): returnType2; <span class="comment">// 方法 - 方式 II</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">speak</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">introduce</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi! Nice to meet you~&quot;</span>) &#125;,</span><br><span class="line">    <span class="attr">introduce</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is Jack and I&#x27;m 19 years old!&quot;</span>) &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>type</code> 写法（即给对象类型起一个别名）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 语法 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectTypeName</span> = &#123;</span><br><span class="line">    <span class="attr">propertyName</span>: propertyType; <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">methodName1</span>: <span class="function">(<span class="params"><span class="attr">para1</span>: paraType1, <span class="attr">para2</span>: paraType2</span>) =&gt;</span> returnType1; <span class="comment">// 方法 - 方式 I</span></span><br><span class="line">    <span class="title function_">methodName2</span>(<span class="attr">para1</span>: paraType1, <span class="attr">para2</span>: paraType2): returnType2; <span class="comment">// 方法 - 方式 II</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Lucky&quot;</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">9</span>,</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WangWang!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>interface</code> 写法（即将对象类型提炼为一个接口）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 语法 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjectTypeName</span> &#123;</span><br><span class="line">    <span class="attr">propertyName</span>: propertyType; <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">methodName1</span>: <span class="function">(<span class="params"><span class="attr">para1</span>: paraType1, <span class="attr">para2</span>: paraType2</span>) =&gt;</span> returnType1; <span class="comment">// 方法 - 方式 I</span></span><br><span class="line">    <span class="title function_">methodName2</span>(<span class="attr">para1</span>: paraType1, <span class="attr">para2</span>: paraType2): returnType2; <span class="comment">// 方法 - 方式 II</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">className</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">grade</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">welcome</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">IStudent</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">121313</span>,</span><br><span class="line">    <span class="attr">className</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">grade</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="title function_">welcome</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Good Morning~&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>TypeScript 使用大括号 <code>&quot;&#123;&#125;&quot;</code> 表示对象类型，同时在大括号内部声明每个属性和方法的类型。每个属性/方法的类型可以以分号 <code>&quot;;&quot;</code> 或逗号 <code>&quot;,&quot;</code> 结尾，最后一个属性/方法后边可以省略分号或逗号。</p>
</li>
<li>
<p>与数组类似，TypeScript 允许<strong>通过属性/方法名读取对应属性/方法的类型</strong>，也就是对对象类型进行索引访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">User</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 TypeScript 里，若想在对对象进行解构赋值时明确解构变量的类型，得给所有要解构的变量添加上对象类型声明，不能直接给解构变量加类型，因为直接加类型的语法是用来设置解构变量别名的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: user_name, <span class="comment">// 给解构变量 x 设置别名</span></span><br><span class="line">    <span class="attr">y</span>: user_age <span class="comment">// 给解构变量 y 设置别名</span></span><br><span class="line">&#125;: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">string</span>, <span class="comment">// 给解构变量 x 声明类型</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span> <span class="comment">// 给解构变量 y 声明类型</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="string">&quot;Zhang&#x27;san&quot;</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;abdscdwhv12&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-特殊属性">2.2 特殊属性</h4>
<h5 id="可选属性">可选属性</h5>
<ol>
<li>
<p>解释：对象类型中，属性名后加一个问号 <code>&quot;?&quot;</code> 表示可选属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, age?: <span class="built_in">number</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>可选属性的类型等同于<strong>属性本身类型 | <code>undefined</code></strong>，即可选属性允许被赋值为 <code>undefined</code>。同时，一个未被赋值的可选属性的值为 <code>undefined</code>。因此，在使用对象的可选属性时，必须检查其是否为 <code>undefined</code>。</p>
</li>
<li>
<p>在使用可选属性前，可以使用<strong>三元运算符</strong> <code>&quot;?:&quot;</code> 或<strong>空值合并运算符</strong> <code>&quot;??&quot;</code> 来判断其值是否为 <code>undefined</code>，并设置默认值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>,</span><br><span class="line">  firstName?: <span class="built_in">string</span>,</span><br><span class="line">  lastName?: <span class="built_in">string</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">12341</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Brown&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstName = user.<span class="property">firstName</span> === <span class="literal">undefined</span> ? <span class="string">&quot;Tom&quot;</span> : user.<span class="property">firstName</span>;</span><br><span class="line"><span class="keyword">const</span> lastName = user.<span class="property">lastName</span> ?? <span class="string">&quot;Wood&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>空值合并运算符 <code>??</code>：左侧操作数为 <code>null</code> 或 <code>undefined</code> 时，返回其右侧的操作数，否则返回左侧的操作数。</p>
</blockquote>
</li>
<li>
<p>如果同时使用编译选项 <code>ExcatOptionsPropertyTypes</code> 和 <code>strictNullChecks</code>，TypeScript 将不允许可选属性设置为 <code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">student</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="literal">undefined</span> <span class="comment">// 报错，在打开 ExcatOptionsPropertyTypes 和 strictNullChecks 编译选项时，可选属性不能赋值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="只读属性">只读属性</h5>
<ol>
<li>
<p>解释：对象类型中，属性名前面加上 <code>readonly</code> 关键字，表示只读属性，其只能在对象初始化期间赋值，之后不能被再修改。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">13</span>; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>如果只读的属性是一个对象，TypeScript 不会禁止对该对象的属性进行修改，但会禁止对该对象进行替换。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">Student</span> = &#123; <span class="attr">score</span>: &#123; <span class="attr">chinese</span>: <span class="number">80</span>, <span class="attr">math</span>: <span class="number">80</span>, <span class="attr">english</span>: <span class="number">80</span>, <span class="attr">average</span>: <span class="number">80</span> &#125; &#125;;</span><br><span class="line">stu.<span class="property">score</span>.<span class="property">average</span> = <span class="number">90</span>; <span class="comment">// ✓，允许修改只读的对象属性的属性</span></span><br><span class="line">stu.<span class="property">score</span> = &#123; <span class="attr">chinese</span>: <span class="number">80</span>, <span class="attr">math</span>: <span class="number">80</span>, <span class="attr">english</span>: <span class="number">80</span>, <span class="attr">average</span>: <span class="number">80</span> &#125;; <span class="comment">// ×，不允许替换只读的对象属性</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果两个变量（引用）指向同一个对象，且一个变量规定对象属性可写，另一个变量规定对象属性只读，此时，前者对对象属性的修改会影响到后者对对象属性的访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">WritablePerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPerson</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">w</span>: <span class="title class_">WritablePerson</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>: <span class="title class_">ReadonlyPerson</span> = w;</span><br><span class="line"></span><br><span class="line">w.<span class="property">age</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">age</span>); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了让对象的所有属性都是只读的（<strong>深度只读</strong>），在将对象赋值给变量时可以使用 <code>as const</code>。但要注意，如果对变量添加了类型声明，TypeScript 会优先采用声明的类型，导致 <code>as const</code> 失效。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用只读断言的对象是深度只读的 */</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;He&#x27;nan&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;Xin&#x27;xiang&quot;</span>,</span><br><span class="line">        <span class="attr">detail</span>: &#123;</span><br><span class="line">            <span class="attr">district</span>: <span class="string">&quot;Xin&#x27;cheng&quot;</span>,</span><br><span class="line">            <span class="attr">street</span>: <span class="number">2001</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span>; <span class="comment">// ×</span></span><br><span class="line">obj1.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&quot;Xin&#x27;yang&quot;</span>; <span class="comment">// ×</span></span><br><span class="line">obj1.<span class="property">address</span>.<span class="property">detail</span>.<span class="property">street</span> = <span class="number">9011</span>; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类型声明会和只读断言发生冲突，以类型声明为准，只读断言失效 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">detail</span>: &#123;</span><br><span class="line">            <span class="attr">district</span>: <span class="built_in">string</span>,</span><br><span class="line">            <span class="attr">street</span>: <span class="built_in">number</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;He&#x27;nan&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;Xin&#x27;xiang&quot;</span>,</span><br><span class="line">        <span class="attr">detail</span>: &#123;</span><br><span class="line">            <span class="attr">district</span>: <span class="string">&quot;Xin&#x27;cheng&quot;</span>,</span><br><span class="line">            <span class="attr">street</span>: <span class="number">2001</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span>; <span class="comment">// √</span></span><br><span class="line">obj2.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&quot;Xin&#x27;yang&quot;</span>; <span class="comment">// √</span></span><br><span class="line">obj2.<span class="property">address</span>.<span class="property">detail</span>.<span class="property">street</span> = <span class="number">9011</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="索引签名">索引签名</h5>
<ol>
<li>
<p>解释：允许对象拥有<strong>任意数量</strong>的属性，同时使这些属性满足<strong>特定的键值约束</strong>，即索引签名。</p>
</li>
<li>
<p>语法：<code>&#123; [indexName: indexType]: valueType &#125;</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用索引签名时还可以起一个类型别名（type），或将其提炼为一个接口（interface） */</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = &#123; [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = &#123; [<span class="attr">property</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = &#123; [<span class="attr">property</span>: <span class="built_in">symbol</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">t1</span>: <span class="variable constant_">T1</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;ZhangSan&quot;</span>, <span class="attr">gender</span>: <span class="string">&quot;Male&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">t2</span>: <span class="variable constant_">T2</span> = &#123; <span class="number">0</span>: <span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>: <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> [first, second] = [<span class="title class_">Symbol</span>(), <span class="title class_">Symbol</span>()];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">t3</span>: <span class="variable constant_">T3</span> = &#123; [first]: <span class="string">&quot;Happy&quot;</span>, [second]: <span class="string">&quot;New Year&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：<code>indexName</code> 表示属性名，可以随便起；<code>indexType</code> 是属性名的类型，可以是 <code>string</code>、<code>number</code> 和 <code>symbol</code>；<code>valueType</code> 是属性值的类型。</p>
</blockquote>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>使用索引签名时，可以同时存在多种类型（属性名的类型不同）的索引。如果同时存在字符串索引和数值索引，必须以字符串索引的属性值类型为准，否则会引发冲突，这是因为 JavaScript 中会自动将数值属性名转换为字符串属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T2 &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">number</span>]: <span class="built_in">boolean</span>; <span class="comment">// 需要为 string</span></span><br><span class="line">&#125; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T3 &#123;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">symbol</span>]: <span class="built_in">number</span></span><br><span class="line">&#125; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：这里的字符串索引和数值索引，指的是索引签名中属性名的类型，即 <code>indexType</code>。</p>
</blockquote>
</li>
<li>
<p>同时使用索引签名和特定属性的类型声明时，如果该属性与存在的索引的属性名的类型相同，则属性值的类型一定也要相同，否则会引发冲突。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 需为 number；name 属性的属性名类型为 string，其属性值类型与字符串索引的属性值类型产生冲突，从而报错。</span></span><br><span class="line">    [<span class="attr">detail</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;; <span class="comment">// ×，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T2 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">detail</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;; <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T3 &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="built_in">string</span>; <span class="comment">// 需为 number；属性名类型为 number 的属性也会和字符串索引产生冲突！</span></span><br><span class="line">    [<span class="attr">detail</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">interface</span> T4 &#123;</span><br><span class="line">    [x]: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">detail</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T5 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 属性名类型为 string 的属性不会和数值串索引产生冲突！（但是运行时可能会暴露问题，因此不推荐！）</span></span><br><span class="line">    [<span class="attr">detail</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用索引签名定义一个表示<strong>没有任何属性的对象</strong>的类型，代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">WithoutProperties</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>]: <span class="built_in">never</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="2-3-结构类型">2.3 结构类型</h4>
<ol>
<li>
<p>结构类型原则（structural typing）：在 TypeScript 中，若对象 B 具备对象 A 的<strong>结构特征</strong>，即认为对象 B 的类型<strong>兼容</strong>对象 A 的类型，这就是<strong>结构类型原则</strong>。若对象 B 的类型兼容对象 A 的类型，则使用对象A 的地方皆可使用对象 B，即对象 B 可赋值给对象 A 所对应的变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Student 类型的对象兼容 Person 类型的对象 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">grade</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">grade</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> p = s;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：TypeScript 根据<strong>结构类型原则</strong>检查某个值是否符合指定类型。</p>
<p>补充-2：如果类型 B 兼容类型 A，那么类型 B 就是类型 A 的<strong>子类型</strong>，类型 A 是类型 B 的<strong>父类型</strong>，即<strong>子类型兼容父类型</strong>。子类型具有父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型。</p>
</blockquote>
</li>
<li>
<p>严格字面量检查（strict object literal）：将对象字面量赋给声明了对象类型的变量时，二者类型必须完全一致，否则会触发严格字面量检查报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">190</span>, <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>规避严格字面量检查的方式</p>
<ul>
<li>
<p>方式一：使用<strong>中间变量</strong>（要确保类型兼容！）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">190</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125; = temp; <span class="comment">// √，temp 兼容 p，也就是说 temp 是 p 的子类型，p 是 temp 的父类型。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式二：使用<strong>类型断言</strong>（要确保类型兼容！）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">190</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">Person</span>; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式三：使用<strong>索引签名</strong>（要确保类型兼容！）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">190</span>,</span><br><span class="line">&#125;; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式四：<strong>打开 <code>suppressExcessPropertyErrors</code> 编译选项</strong>，以关闭多余属性检查（要确保类型兼容，且只适用于函数传参！）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logInfo</span>(<span class="params"><span class="attr">p</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`info: <span class="subst">$&#123;p.name&#125;</span>-<span class="subst">$&#123;p.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">logInfo</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">190</span>,</span><br><span class="line">&#125;); <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：Option ‘suppressExcessPropertyErrors’ is deprecated and will stop functioning in TypeScript 5.5（编译选项 <code>suppressExcessPropertyErrors</code> 在 TypeScript 5.5 中被废除）。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="2-4-最小可选属性">2.4 最小可选属性</h4>
<ol>
<li>
<p>解释：如果某个对象类型的所有属性都是可选的，那么该类型的对象<strong>必须至少存在一个可选属性</strong>，即<strong>最小可选属性原则</strong>，又称<strong>弱类型检测</strong>（weak type detection）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coordinate</span> = &#123;</span><br><span class="line">    x?: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp1 = &#123; <span class="attr">d</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cor1</span>: <span class="title class_">Coordinate</span> = temp1; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp2 = &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">d</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cor2</span>: <span class="title class_">Coordinate</span> = temp2; <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp3 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cor3</span>: <span class="title class_">Coordinate</span> = temp3; <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充 - 1：<strong>最小可选属性原则</strong>是对<strong>结构类型原则</strong>的补充，否则上述示例中的 <code>cor1</code> 变量不应该报错。</p>
<p>补充 - 2：当某一类型所对应的对象，既 ① 未涵盖该类型下的所有可选属性，又 ② 存在超出其类型声明范围的其他属性，同时还需 ③ 满足结构类型原则，也就是类型兼容的要求时，此原则才会生效。</p>
</blockquote>
</li>
<li>
<p>规避方式</p>
<ul>
<li>
<p>方式一：使用<strong>索引签名</strong>（要确保类型兼容！）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coordinate</span> = &#123;</span><br><span class="line">    x?: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp = &#123; <span class="attr">d</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cor</span>: <span class="title class_">Coordinate</span> = temp;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式二：使用<strong>类型断言（要确保类型兼容！）</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coordinate</span> = &#123;</span><br><span class="line">    x?: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp = &#123; <span class="attr">d</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cor</span>: <span class="title class_">Coordinate</span> = temp <span class="keyword">as</span> <span class="title class_">Coordinate</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="TS-类型系统-4（interface、类）">TS - 类型系统 4（interface、类）</h2>
<h3 id="1-interface">1. interface</h3>
<h4 id="1-1-基本使用-3">1.1 基本使用</h4>
<ol>
<li>
<p>解释：<code>interface</code> 是<strong>对象的模板</strong>，用于指定对象的类型结构，译为接口。接口的使用又称为接口的<strong>实现</strong>，即将接口当作对象类型来使用。TypeScript 中通过 <code>interface</code> 关键字来定义接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">jack</span>: <span class="title class_">IStudent</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法：<code>interface 接口名 = &#123; 接口成员 &#125;</code></p>
<blockquote>
<p>补充：TypeScript 中使用 <code>interface</code> 关键字定义接口，同时接口成员有以下五种形式：① <strong>对象属性</strong> ② <strong>对象的属性索引</strong> ③ <strong>对象方法</strong> ④ <strong>函数</strong> ⑤ <strong>构造函数</strong></p>
</blockquote>
<ul>
<li>
<p><strong>对象属性</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口成员 - 对象属性</span></span><br><span class="line"><span class="comment">    - 属性之间使用分号 &quot;;&quot; 或逗号 &quot;,&quot; 分隔，最后一个属性结尾的分号或逗号可以省略</span></span><br><span class="line"><span class="comment">    - 允许定义可选属性、只读属性 */</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isFullTime</span>: <span class="built_in">boolean</span>; <span class="comment">// 只读属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对象的属性索引</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口成员 - 对象的属性索引</span></span><br><span class="line"><span class="comment">    - 对象的属性索引的一般格式为 [indexName: indexType]: valueType，其中 indexType 表示属性名类型，可选 string、number、symbol</span></span><br><span class="line"><span class="comment">    - 属性的数值索引，即 indexType 为 number，表示指定数组的类型，如接口 B 所示</span></span><br><span class="line"><span class="comment">    - 接口中同时定义了属性的字符串索引和数值索引，则数值索引必须服从于字符串索引，如接口 C、D 所示。这是因为 JavaScript 中，数值属性名最终会自动转换为字符串属性名 */</span></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: B = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> D &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>; <span class="comment">// 这里应该修改为 string</span></span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对象方法</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口成员 - 对象方法</span></span><br><span class="line"><span class="comment">    - 对象方法一共有三种写法，如接口 E、F、G 所示</span></span><br><span class="line"><span class="comment">    - 对象方法名可以采用表达式，如接口 H 所示</span></span><br><span class="line"><span class="comment">    - 对象方法可以重载，interface 中定义的重载的函数只需要给出重载声明，而不需要给出重载实现，但在使用该接口时，需要给出对应重载的函数的重载声明和重载实现，如 I 所示 */</span></span><br><span class="line"><span class="keyword">interface</span> E &#123;</span><br><span class="line">    <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> F &#123;</span><br><span class="line">    <span class="attr">f</span>: <span class="function">(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> G &#123;</span><br><span class="line">    <span class="attr">f</span>: &#123; (<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"><span class="keyword">interface</span> H &#123;</span><br><span class="line">    [f](<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只给出重载声明 */</span></span><br><span class="line"><span class="keyword">interface</span> I &#123;</span><br><span class="line">    <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>, <span class="attr">y</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 使用接口 I 时，定义的对象方法要给出重载声明 + 重载实现 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">boolean</span>, <span class="attr">y</span>: <span class="built_in">boolean</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>, <span class="attr">y</span>: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;boolean&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;boolean&#x27;</span>) <span class="keyword">return</span> x || y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;worng parameters&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: I = &#123;</span><br><span class="line">    <span class="attr">f</span>: add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>函数</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口成员 - 函数</span></span><br><span class="line"><span class="comment">    - 使用接口表示函数的语法如接口 J 所示 */</span></span><br><span class="line"><span class="keyword">interface</span> J &#123;</span><br><span class="line">    (<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">speak</span>: J = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> x.<span class="title function_">toUpperCase</span>() &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>构造函数</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口成员 - 构造函数</span></span><br><span class="line"><span class="comment">	- 使用接口表示构造函数的语法如接口 K 所示</span></span><br><span class="line"><span class="comment">    - 在 TypeScript 中，构造函数特指具有 constructor 属性的类 */</span></span><br><span class="line"><span class="keyword">interface</span> K &#123;</span><br><span class="line">    <span class="title function_">new</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>与对象类似，TypeScript 允许<strong>通过属性/方法名读取对应属性/方法的类型</strong>，也就是对 <code>interface</code> 进行索引访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">IStudent</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="1-2-接口继承">1.2 接口继承</h4>
<ol>
<li>
<p>解释：接口可以使用 <code>extends</code> 关键字继承<strong>接口、对象类型、类</strong>身上的属性，从而避免书写重复的属性。</p>
</li>
<li>
<p><code>interface</code> 继承 <code>interface</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123; <span class="attr">y</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: B = &#123; <span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">y</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>接口允许<strong>多重继承</strong>，即允许有多个父接口</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; <span class="attr">y</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A, B &#123; <span class="attr">z</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: C = &#123; <span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">y</span>: <span class="string">&quot;world&quot;</span>, <span class="attr">z</span>: <span class="string">&quot;!&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>子接口与父接口的同名属性必须<strong>类型兼容</strong>，多个父接口之间的同名属性必须<strong>类型一致</strong>，否则会报错</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父子接口的同名属性需兼容 */</span></span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125; <span class="comment">// √</span></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A &#123; <span class="attr">x</span>: <span class="built_in">boolean</span>; &#125; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 父接口之间的同名属性需一致 */</span></span><br><span class="line"><span class="keyword">interface</span> M &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> N &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> P <span class="keyword">extends</span> M, N &#123; &#125;; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>interface</code> 继承 <code>type</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">x</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123; <span class="attr">z</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: B = &#123; <span class="attr">x</span>: <span class="string">&quot;Hello&quot;</span>, <span class="attr">y</span>: <span class="string">&quot;World&quot;</span>, <span class="attr">z</span>: <span class="string">&quot;!&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：<code>interface</code> 继承 <code>type</code> 的前提是，<strong><code>type</code> 关键字定义的类型是对象</strong>。</p>
</blockquote>
</li>
<li>
<p><code>interface</code> 继承 <code>class</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="title function_">y</span>(): <span class="built_in">boolean</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123; <span class="attr">z</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: B = &#123; <span class="attr">x</span>: <span class="string">&quot;Hello&quot;</span>, <span class="title function_">y</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;, <span class="attr">z</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：当 <code>class</code> 定义的类中包含 <code>private</code> 或 <code>protected</code> 的成员时，<code>interface</code> 继承 <code>class</code> 的意义不大！</p>
</blockquote>
</li>
</ol>
<h4 id="1-3-接口合并">1.3 接口合并</h4>
<ol>
<li>
<p>解释：在 TypeScript 中，同名接口会<strong>自动合并</strong>为一个接口。这一特性旨在兼容 JavaScript 中向全局对象或外部库扩展属性和方法的常见做法。通过定义同名接口，TypeScript 会自动将新增的属性和方法与原始接口合并，从而实现<strong>类型的无缝扩展</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 接口合并 */</span></span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">y</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: A = &#123; <span class="attr">x</span>: <span class="string">&quot;Hello&quot;</span>, <span class="attr">y</span>: <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类型扩展，以下代码执行后，允许在 document 对象上添加自定义属性 x */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">x</span> = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>接口合并时，同名属性必须<strong>类型一致</strong>，否则会报错</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125; <span class="comment">// ×</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口合并时，同名方法可以有不同的类型声明，即<strong>方法重载</strong>，此时：后边定义的接口的方法声明优先级更高；包含字面量参数的方法声明优先级最高。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">boolean</span> | <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码等价于</span></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">boolean</span> | <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>两个 <code>interface</code> 的联合类型中的同名属性也是联合类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> C &#123; <span class="attr">x</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> D &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> E = C | D; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="1-4-interface-Vs-type">1.4 interface Vs. type</h4>
<ol>
<li>
<p>相同点：<code>interface</code> 和 <code>type</code> 都可以定义对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不同点</p>
<table>
<thead>
<tr>
<th style="text-align:center">概述</th>
<th style="text-align:center"><code>interface</code></th>
<th style="text-align:center"><code>type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>类型范围</strong></td>
<td style="text-align:center">对象类型（包括数组、函数等）</td>
<td style="text-align:center">对象类型 + 非对象类型</td>
</tr>
<tr>
<td style="text-align:center"><strong>继承方式</strong></td>
<td style="text-align:center">使用 <code>extends</code> 关键字继承接口、对象类型或类</td>
<td style="text-align:center">使用 <code>&amp;</code> 运算符继承接口、对象类型</td>
</tr>
<tr>
<td style="text-align:center"><strong>合并允许</strong></td>
<td style="text-align:center">同名 <code>interface</code> 会自动合并（开放）</td>
<td style="text-align:center">同名 <code>type</code> 会报错（封闭）</td>
</tr>
<tr>
<td style="text-align:center"><strong>属性映射</strong></td>
<td style="text-align:center">不能包含属性映射</td>
<td style="text-align:center"><strong>可以</strong>包含属性映射</td>
</tr>
<tr>
<td style="text-align:center"><strong><code>this</code> 允许</strong></td>
<td style="text-align:center"><strong>允许</strong>使用 <code>this</code></td>
<td style="text-align:center">不允许使用 <code>this</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>原始数据类型扩展</strong></td>
<td style="text-align:center">不允许扩展原始数据类型</td>
<td style="text-align:center"><strong>允许</strong>扩展原始数据类型</td>
</tr>
<tr>
<td style="text-align:center"><strong>复杂类型表示</strong></td>
<td style="text-align:center">不可以表示复杂类型</td>
<td style="text-align:center"><strong>可以</strong>表示复杂类型（如交叉类型和联合类型）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>补充：一般情况下，由于 <code>interface</code> 灵活度较高，建议优先使用~</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 属性映射 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Copy1</span> = &#123;</span><br><span class="line">    [key <span class="keyword">in</span> keyof <span class="title class_">Data</span>]: <span class="title class_">Data</span>[key];</span><br><span class="line">&#125; <span class="comment">// √，Copy1 是一种基于映射类型的方式来精确复制 Data 的结构。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Copy2</span> &#123;</span><br><span class="line">    [key <span class="keyword">in</span> keyof <span class="title class_">Data</span>]: <span class="title class_">Data</span>[key];</span><br><span class="line">&#125; <span class="comment">// ×</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原始数据类型扩展 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyStr1</span> <span class="keyword">extends</span> <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;new&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// ×，An interface cannot extend a primitive type like &#x27;string&#x27;. It can only extend other named object types.(2840)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyStr2</span> = <span class="built_in">string</span> &amp; &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;new&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str</span>: <span class="title class_">MyStr2</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) <span class="keyword">as</span> <span class="title class_">MyStr2</span>;</span><br><span class="line">str.<span class="property">type</span> = <span class="string">&quot;new&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str, str.<span class="property">type</span>) <span class="comment">// String: &quot;hello&quot;,  &quot;new&quot; </span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-类">2. 类</h3>
<h4 id="2-1-基本使用-3">2.1 基本使用</h4>
<ol>
<li>
<p>解释：类是面向对象编程的核心构建单元，它通过封装属性（数据）和方法（行为）来实现对现实世界实体的抽象和建模。TypeScript 中通过 <code>class</code> 关键字定义类。</p>
</li>
<li>
<p>基本语法：<code>class 类名 &#123; 属性; 方法; /* ... */ &#125;</code></p>
<blockquote>
<p>补充：TypeScript 中使用 <code>class</code> 关键字定义类，同时类成员有以下五种形式：① <strong>属性</strong> ② <strong>只读属性</strong> ③ <strong>方法</strong> ④ <strong>访问器方法</strong> ⑤ <strong>属性索引</strong></p>
</blockquote>
<ul>
<li>
<p><strong>属性</strong>：可以在<strong>类顶部</strong>声明属性及其类型。在未指定属性类型的情况下，如果属性被赋初值，TypeScript 会自动推断该属性类型，否则会认为该属性类型为 <code>any</code>。一般情况下，编译选项 <code>--strictPropertyInitialization</code> 被打开，此时 TypeScript 会检查属性是否设置了初值，没有就报错（如果在构造函数中进行了赋值，也不会报错）。为了避免因为属性未赋值而产生的报错，可以使用非空断言 <code>&quot;!&quot;</code>，表示对应的属性肯定不会为空。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span> = <span class="number">10</span>; <span class="comment">// 标准写法</span></span><br><span class="line">    y = <span class="number">10</span>; <span class="comment">// 自动推断属性 y 为 number 类型</span></span><br><span class="line">    z; <span class="comment">// 认为属性 z 为 any 类型</span></span><br><span class="line">    isValid!: <span class="built_in">boolean</span>; <span class="comment">// 非空断言，表示属性 isValid 一定不会为 null 或 undefined</span></span><br><span class="line">    <span class="attr">isOrigin</span>: <span class="built_in">boolean</span>; <span class="comment">// 因为在构造函数中对 isOrigin 进行了赋值，所以这里不会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>, <span class="attr">z</span>: <span class="built_in">number</span>, <span class="attr">isValid</span>: <span class="built_in">boolean</span>, <span class="attr">isOrigin</span>: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">z</span> = z;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isValid</span> = isValid;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isOrigin</span> = isOrigin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非空断言（Non-null Assertion）：TypeScript 中通过在表达式末尾添加一个感叹号 <code>&quot;!&quot;</code> 实现非空断言，告诉编译器该表达式的值绝对不是 <code>null</code> 或 <code>undefined</code>。</p>
</blockquote>
</li>
<li>
<p><strong>只读属性</strong>：属性名前使用 <code>readonly</code> 修饰符以表示该属性是只读属性。可以在<strong>类顶部</strong>给只读属性赋值，也可以在<strong>构造函数</strong>中给只读属性赋值，如果两处同时赋值，以构造函数中的为准。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">z</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">20</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">z</span> = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">/* 此时属性为 x = 10, y = 20, z = 30 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>方法</strong>：声明方法的语法为 <code>methodName(paraName1: paraType1, /* ... */) &#123;&#125;</code>，其中可以省略返回值类型，让 TypeScript 自行推断。方法的参数与普通函数的参数一样，可以使用参数默认值。同时，方法也可以进行重载（包括构造方法）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 参数默认值 */</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params"><span class="attr">point</span>: <span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">1</span>)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span> + point.<span class="property">x</span>,</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> + point.<span class="property">y</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法重载 */</span></span><br><span class="line">    <span class="title function_">mul</span>(<span class="attr">times</span>: <span class="built_in">number</span>): <span class="title class_">Point</span>;</span><br><span class="line">    <span class="title function_">mul</span>(<span class="attr">point</span>: <span class="title class_">Point</span>): <span class="title class_">Point</span>;</span><br><span class="line">    <span class="title function_">mul</span>(<span class="attr">para</span>: <span class="built_in">number</span> | <span class="title class_">Point</span>): <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> para === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">x</span> * para,</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">y</span> * para</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (para <span class="keyword">instanceof</span> <span class="title class_">Point</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">x</span> * para.<span class="property">x</span>,</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">y</span> * para.<span class="property">y</span></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid parameter type. Expected number or Point.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：构造方法不能声明返回值类型，因为其总是返回实例对象。</p>
</blockquote>
</li>
<li>
<p><strong><code>getter / setter</code>（存取器方法）</strong>：存取器（accessor）是特殊的方法，包括<strong>取值器</strong>（getter）和<strong>存值器</strong>（setter），其中取值器用于<strong>读取属性</strong>，存值器用于<strong>写入属性</strong>（这里读取或写入的属性称之为<strong>访问器属性</strong>）。一般来说，存取器对类中的某个属性进行代理，从而对其读取和写入操作添加更加更加详细的控制。取值器语法为 <code>get 属性名()&#123; return 被代理属性 &#125;</code>，存值器语法为 <code>set 属性名(value: valueType)&#123; 被代理属性 = value &#125;</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">_data</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">data</span>(<span class="params"><span class="attr">value</span>: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_data</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：如果一个访问器属性只有 <code>getter</code>，那么该属性就是只读属性。</p>
<p>补充-2：TypeScript 5.1 之前要求 <code>getter</code> 的返回值型必须<strong>兼容</strong> <code>setter</code> 的参数类型。</p>
<p>补充-3：访问器属性的 <code>getter</code> 和 <code>setter</code> 的可访问性必须一致！要么都公开，要么都私有！</p>
</blockquote>
</li>
<li>
<p><strong>属性索引</strong>：在 TypeScript 中，类允许定义属性索引（如字符串、数字或 <code>Symbol</code>），用于约束对应属性值的类型。方法和存取器被视为特殊的<strong>字符串</strong>属性索引。例如，<code>[s: string]: boolean | ((s: string) =&gt; boolean)</code> 约束了类中所有以字符串为属性名的属性：这些属性的值必须是布尔值，方法必须是返回布尔值的函数，而存取器必须返回布尔值。一旦不满足约束，就会报错。</p>
</li>
</ul>
</li>
<li>
<p><strong>静态成员</strong>：类的内部能够使用 <code>static</code> 关键字来定义静态成员（包括属性或方法）。静态成员只能通过类本身来使用，并且可以使用 <code>public</code>、<code>private</code>、<code>protected</code> 修饰符来修饰静态成员。</p>
</li>
</ol>
<h4 id="2-2-类的实现">2.2 类的实现</h4>
<ol>
<li>
<p>解释：TypeScript 中，可以通过 <code>interface</code> 或 <code>type</code> 以对象的形式对类的成员进行约束，类可以使用 <code>implements</code> 关键字应用这些约束，称之为<strong>类的实现</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">city</span>: <span class="built_in">string</span> = <span class="string">&quot;Bei&#x27;jing&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：<code>interface</code> 定义的类成员约束与类自身的类型声明并不等同，所以类在符合 <code>interface</code> 所提供的约束条件时，<strong>还需补充相应的类型声明</strong>。</p>
<p>补充-2：类可以定义 <code>interface</code> 中没有声明的属性和方法。</p>
<p>补充-3：如果 <code>implements</code> 关键字后边是一个类，此时这个<strong>类被当做接口使用</strong>。</p>
</blockquote>
</li>
<li>
<p><strong>多重实现</strong>：在 TypeScript 中，类能够实现多个接口，这意味着它可以接受来自多个接口的约束。当类实现多个接口时，接口之间用逗号分隔。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> A, B, C &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：若一个类同时实现多个接口，可能会导致代码管理变得困难，此时可借助<strong>类的继承或者接口的继承</strong>来对这种情况加以改写。</p>
<p>补充-2：当一个类实现多个接口时，各接口之间<strong>不能存在会引发冲突的属性</strong>。</p>
</blockquote>
</li>
<li>
<p><strong>类的合并</strong>：TypeScript 中不允许出现两个同名的类，但是如果一个类和一个接口同名，那么<strong>接口会被合并进类的定义</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="attr">isNew</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span> = <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">car.<span class="property">isNew</span> = <span class="literal">true</span>; <span class="comment">// 如果这里不给 isNew 属性赋值，则默认为 undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-3-类的类型">2.3 类的类型</h4>
<ol>
<li>
<p><strong>实例类型</strong>：在 TypeScript 里，类（名）本身就属于一种类型，它代表的是该类的<strong>实例类型</strong>，而非类自身的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 这里 Point 被当做实例类型使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;; <span class="comment">// 这里 Point 被当做对象类型使用</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：若类 A 实现了接口 B，在声明引用类 A 实例的变量时，既可将变量类型声明为 A，也能声明为 B。二者唯一的区别在于，当声明类型为 B 时，该变量无法访问类 A 中定义的那些属性和方法。</p>
<p>补充-2：在 TypeScript 中，存在三种可充当对象类型的方式，分别是 <code>type</code>、<code>interface</code> 以及 <code>class</code>。</p>
</blockquote>
</li>
<li>
<p><strong>自身类型</strong>：可通过以下三种方式获得一个类的自身类型。</p>
<ul>
<li>
<p>方式一 <code>typeof 类名</code></p>
</li>
<li>
<p>方式二 <code>new (paraName1: paraType1, paraName2: paraType2) =&gt; 类名</code></p>
<blockquote>
<p>补充：方式二的合理性在于，在 JavaScript 中，类是构造函数的语法糖，即构造函数的另一种写法，因此类的自身类型可以写成构造函数的形式。</p>
</blockquote>
</li>
<li>
<p>方式三 <code>&#123; new (paraName1: paraType1, paraName2: paraType2): 类名 &#125;</code></p>
<blockquote>
<p>补充：可以参照方式三将类的自身类型提炼为一个 <code>interface</code>，便于使用。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>结构类型</strong></p>
<ul>
<li>
<p>如果一个对象满足类的<strong>实例结构</strong>，便认为此对象和该类是同一类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">19</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">isAdult</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>, <span class="attr">age</span>: <span class="number">41</span> &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：确定对象和类的兼容关系时，<strong>只检查实例成员</strong>，不考虑静态成员和构造方法。</p>
<p>补充-2：当对象和类属于同一类型时，不可以使用 <code>对象 instanceof 类名</code> 的方式判断某个对象是否跟某个类属于同一类型。</p>
</blockquote>
</li>
<li>
<p>如果类 A 具备类 B 的全部结构，即便类 A 还有额外的属性和方法，也会认为类 A 是<strong>兼容</strong>类 B 的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">19</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">isAdult</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">89</span>;</span><br><span class="line">  <span class="attr">grade</span>: <span class="built_in">number</span> = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">isAdolescent</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：确定两个类的兼容关系时，<strong>只检查实例成员</strong>，不考虑静态成员和构造方法。</p>
<p>补充-2：若类中包含私有成员或保护成员，在判定两个类的兼容关系时，需保证这些私有或保护成员源自同一个类，也就是说，这两个类之间得存在继承关系。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="2-4-类的继承">2.4 类的继承</h4>
<ol>
<li>
<p>解释：一个类（子类）可以使用 <code>extends</code> 关键字继承另一个类（父类、基类）的所有属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eat food...&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Creature</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.<span class="title function_">eat</span>(); <span class="comment">// &quot;eat food...&quot; </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>依照结构类型原则，因为子类涵盖了父类的全部结构，<strong>子类兼容父类</strong>。</p>
</li>
<li>
<p>子类能够对父类里的同名方法进行<strong>重写</strong>，但其类型定义务必要兼容父类中该同名方法的类型定义。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eat food...&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Creature</span> &#123;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params">n?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="literal">undefined</span>) <span class="variable language_">super</span>.<span class="title function_">eat</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`eat <span class="subst">$&#123;n&#125;</span> fish...`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.<span class="title function_">eat</span>(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：当子类重写父类的方法时，若在重写的方法前添加 <code>override</code> 关键字，TypeScript 便会检查父类中是否存在对应的同名方法，若不存在，就会报错。</p>
<p>补充-2：在 TypeScript 编译过程中，若开启了 <code>noImplicitOverride</code> 编译选项，那么当子类重写父类里的同名方法时，要是不添加 <code>override</code> 关键字，就会出现报错。</p>
</blockquote>
</li>
<li>
<p>在子类中，能够将父类的保护成员的可访问性修改为公开，但不能把它设为私有。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">protected</span> y = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">protected</span> z = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> x = <span class="number">1</span>; <span class="comment">// √</span></span><br><span class="line">  <span class="keyword">private</span> y = <span class="number">2</span>; <span class="comment">// ×</span></span><br><span class="line">  <span class="keyword">protected</span> z = <span class="number">3</span>; <span class="comment">// √</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>extends</code> 关键字后不一定是类名，可以是一个类型为构造函数的表达式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">  speed = <span class="string">&quot;slow&quot;</span>;</span><br><span class="line">  <span class="title function_">drive</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Bike rides slowly&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  speed = <span class="string">&quot;fast&quot;</span>;</span><br><span class="line">  <span class="title function_">drive</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Car drives quickly&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Transportation</span> &#123;</span><br><span class="line">  <span class="attr">speed</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">drive</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TransportationConstructor</span> &#123;</span><br><span class="line">  <span class="title function_">new</span>(): <span class="title class_">Transportation</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTransportation</span>(<span class="params"></span>): <span class="title class_">TransportationConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="title class_">Bike</span> : <span class="title class_">Car</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getTransportation() 是一个表达式，执行返回 Bike 或 Car */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">getTransportation</span>() &#123;</span><br><span class="line">  <span class="title function_">sayInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The speed is <span class="subst">$&#123;<span class="variable language_">this</span>.speed&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">drive</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">v.<span class="title function_">sayInfo</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="2-5-可访问性修饰符">2.5 可访问性修饰符</h4>
<p>类的内部成员的<strong>外部可访问性</strong>由三个<strong>可访问性修饰符</strong>（access modifiers）控制：<code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">可访问性修饰符</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">外部（实例）可访问</th>
<th style="text-align:center">类内部可访问</th>
<th style="text-align:center">子类可访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public</code></td>
<td style="text-align:center">公开成员（默认修饰符）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code></td>
<td style="text-align:center">私有成员</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code></td>
<td style="text-align:center">保护成员</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>private</code></p>
<ul>
<li>
<p>子类中不能定义<strong>父类私有成员的同名成员</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;creature&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">gender</span>: <span class="built_in">string</span> = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;dog&quot;</span>; <span class="comment">// ×</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">0</span>; <span class="comment">// ×</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">gender</span>: <span class="built_in">string</span> = <span class="string">&quot;male&quot;</span>; <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>private</code> 修饰符定义的私有成员并<strong>不是真正意义上的私有成员</strong>，实例对象可以通过方括号 <code>&quot;[]&quot;</code> 或 <code>in</code> 运算符访问对应的私有成员。因此，更推荐使用 ES2022 引入的私有成员写法 <code>#propName</code>，即<strong>真正意义上的私有成员</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;creature&quot;</span>;</span><br><span class="line">  #<span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Creature</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="property">name</span>; <span class="comment">// ×</span></span><br><span class="line">c[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &quot;creature&quot;</span></span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> c; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">c.<span class="property">age</span>; <span class="comment">// ×</span></span><br><span class="line">c[<span class="string">&#x27;age&#x27;</span>]; <span class="comment">// ×</span></span><br><span class="line"><span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> c; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数设为私有后，不能用 <code>new</code> 操作符生成实例对象，只能在类内创建。类内创建实例的<strong>静态方法</strong>叫<strong>工厂函数</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> instance?: <span class="title class_">Creature</span>; <span class="comment">// Creature 类的唯一实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 工厂函数，用于获取 Creature 类实例（单例） */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Creature</span>.<span class="property">instance</span>)</span><br><span class="line">      <span class="title class_">Creature</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Creature</span>(<span class="string">&quot;lucky&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Creature</span>.<span class="property">instance</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>protected</code></p>
<ul>
<li>
<p>子类中可以定义<strong>父类保护成员的同名成员</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;creature&quot;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">gender</span>: <span class="built_in">string</span> = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;dog&quot;</span>; <span class="comment">// √</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">0</span>; <span class="comment">// √</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">gender</span>: <span class="built_in">string</span> = <span class="string">&quot;male&quot;</span>; <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>实例属性的简写形式：在 TypeScript 中，支持将以下代码 <code>(1)</code> 简写为代码 <code>(2)</code>，即<strong>可访问性修饰符</strong> <code>public</code>、<code>private</code>、<code>protected</code> 以及<strong>只读修饰符</strong> <code>readonly</code> 移动到构造函数中去。</p>
<blockquote>
<p>补充：<code>readonly</code> 可以和 <code>public</code>、<code>private</code>、<code>protected</code> 混合使用。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">x</span>: <span class="built_in">number</span>, <span class="keyword">public</span> <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-6-顶层属性的初始化问题">2.6 顶层属性的初始化问题</h4>
<ol>
<li>
<p>背景：对于类的顶层属性，在早期 TypeScript 中，① 在类顶层声明属性，② <strong>运行构造方法，同时完成初始化</strong>；在 ES2022 及以后，① <strong>在类顶层声明属性，同时完成初始化</strong>，② 运行构造方法。因此，同一段代码在 TypeScript 和 JavaScript 中的运行结果可能会有所不同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 顶层属性在构造方法中初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里隐含了代码</span></span><br><span class="line">    <span class="comment">// this.x = 1;</span></span><br><span class="line">    <span class="comment">// this.y = 2;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript 顶层属性在类顶层初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>问题：因为顶层属性初始化位置不一致而导致代码运行结果不一致的情况通常发生在以下两种情形。</p>
<ul>
<li>
<p><strong>顶层属性的初始化依赖于其他实例属性</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  age = <span class="variable language_">this</span>.<span class="property">currentYear</span> - <span class="number">1998</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="attr">currentYear</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里隐含了</span></span><br><span class="line">    <span class="comment">// this.currentYear = currentYear;</span></span><br><span class="line">    <span class="comment">// this.age = this.currentYear - 1998;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current age:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2023</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  age = <span class="variable language_">this</span>.<span class="property">currentYear</span> - <span class="number">1998</span>; <span class="comment">// undefined - 1998 = NaN</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">currentYear</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current age:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2023</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>子类声明的顶层属性在父类完成初始化</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">animal</span>: <span class="title class_">Animal</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里隐含了</span></span><br><span class="line">    <span class="comment">// this.resident = undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">dog</span>: <span class="title class_">Dog</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里隐含了</span></span><br><span class="line">    <span class="comment">// this.resident = undefined</span></span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="string">&#x27;dog&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> dogHouse = <span class="keyword">new</span> <span class="title class_">DogHouse</span>(dog);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dogHouse.<span class="property">resident</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;animalStuff&quot;: &quot;animal&quot;,</span></span><br><span class="line"><span class="comment">  &quot;dogStuff&quot;: &quot;dog&quot;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  resident;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  resident;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="string">&#x27;dog&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> dogHouse = <span class="keyword">new</span> <span class="title class_">DogHouse</span>(dog);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dogHouse.<span class="property">resident</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>解决方式</p>
<ul>
<li>使用 TypeScript 3.7 开始提供的编译选项 <code>useDefineForClassFields</code>，该编译选项为 <code>true</code>，则表示采用 ES2022 标准的处理方法，否则采用 TypeScript 早期的处理方法。编译选项 <code>useDefineForClassFields</code> 的默认值与编译选项 <code>target</code> 有关，如果 <code>target</code> 的取值为 ES2022 或更高，那么 <code>useDefineForClassFields</code> 的取值为 <code>true</code>，否则为 <code>false</code>。</li>
<li><strong>将所有顶层属性的初始化都放到构造方法中</strong>。</li>
<li>对于<strong>类的继承</strong>导致的问题，可以使用 <code>declare</code> 命令，<strong>去声明子类的顶层属性的初始化由父类实现</strong>。</li>
</ul>
</li>
</ol>
<h4 id="2-7-抽象类">2.7 抽象类</h4>
<p>抽象类：一种特殊的类，其类名前需加上 <code>abstract</code> 关键字。<strong>抽象类是其他类的模板</strong>，用于定义一些共有的接口，<strong>不能进行实例化</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">/* 非抽象成员 */</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;Point&quot;</span>;</span><br><span class="line">  <span class="title function_">logDescription</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Point Abstract Class&quot;</span>) &#125;;</span><br><span class="line">  <span class="comment">/* 抽象成员 */</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">isOrigin</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">x</span>: <span class="built_in">number</span>, <span class="keyword">public</span> <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isOrigin</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123; <span class="keyword">return</span> x === <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类包括<strong>抽象成员和非抽象成员</strong>，抽象成员是未实现的属性和方法，使用 <code>abstract</code> 关键字修饰，需要在非抽象子类中实现；非抽象成员是已实现好的属性和方法。</li>
<li>抽象类的子类也可以是抽象类。</li>
<li>抽象成员不能被 <code>private</code> 修饰符修饰。</li>
</ul>
<h4 id="2-8-this-之用">2.8 this 之用</h4>
<p>类的方法中使用的 <code>this</code> 表示<strong>该方法当前所在的对象</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> a2 = &#123; <span class="attr">name</span>: <span class="string">&quot;world&quot;</span>, <span class="attr">getName</span>: a1.<span class="property">getName</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="title function_">getName</span>()); <span class="comment">// &quot;hello&quot;，getName() 中的 this 指向 a1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2.<span class="title function_">getName</span>()); <span class="comment">// &quot;world&quot;，getName() 中的 this 指向 a2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>TypeScript 允许<strong>函数</strong>增添一个名为 <code>this</code> 的参数，位于<strong>参数列表的首位</strong>，用于描述函数内部 <code>this</code> 的类型。在编译时，TypeScript 会对函数进行检查，如果函数参数列表的第一个参数名为 <code>this</code>，那么编译的结果将会删除这个参数。</p>
</li>
<li>
<p>TypeScript 中提供编译选项 <code>noImplicitThis</code>，打开这个编译选项后，如果 <code>this</code> 的值被推断为 <code>any</code> 类型就会报错。</p>
</li>
<li>
<p>在类内部，<code>this</code> 可以当作类型（返回值）来使用，表示当前类的实例对象。如果某个方法的返回值是一个布尔值，用于表明 <code>this</code> 是否属于某种类型，此时可以将 <code>this is Type</code> 作为方法的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">arr</span>: T[]</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">reverse</span>(): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">reverse</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">slice</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">slice</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isMyArray</span>(): <span class="variable language_">this</span> is <span class="title class_">MyArray</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">MyArray</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reverse</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">isMyArray</span>());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="TS-类型系统-5（泛型、Enum）">TS - 类型系统 5（泛型、Enum）</h2>
<h3 id="1-泛型">1. 泛型</h3>
<h4 id="1-1-基本使用-4">1.1 基本使用</h4>
<ol>
<li>
<p>解释：<strong>泛型</strong>（Generics）是一种特殊的编程逻辑，它通过引入<strong>类型参数</strong>（type parameter）来建立输入类型和输出类型之间的<strong>关联</strong>。在 TypeScript 中，泛型应用于<strong>函数、接口、类和类型别名</strong>中，类型参数放置在<strong>尖括号</strong> <code>&lt;&gt;</code> 中。类型参数必须是合法的标识符，常用 T、U、V 等字母命名，各个类型参数之间使用逗号 <code>,</code> 分隔。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getRandomElement&lt;T&gt;(<span class="attr">arr</span>: T[]): T &#123;</span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[randomIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getRandomElement&lt;<span class="built_in">string</span>&gt;([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRandomElement</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])); <span class="comment">// 有时可以省略类型参数的值，让 TypeScript 自行推断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> combine&lt;T&gt;(<span class="attr">arr1</span>: T[], <span class="attr">arr2</span>: T[]): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(combine&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])); <span class="comment">// 有时类型过于复杂，TypeScript 无法推断，此时需要显示给出类型参数的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> map&lt;T, U&gt;(<span class="attr">arr</span>: T[], <span class="attr">f</span>: <span class="function">(<span class="params"><span class="attr">arg</span>: T</span>) =&gt;</span> U): U[] &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">parseInt</span>(x))); <span class="comment">// 可使用多个类型参数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><strong>函数</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：函数声明</span></span><br><span class="line"><span class="keyword">function</span> func1&lt;T&gt;(<span class="attr">msg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：函数类型 - 一般写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func2</span>: &lt;T&gt;<span class="function">(<span class="params"><span class="attr">arg</span>: T</span>) =&gt;</span> T = func1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：类型声明 - 对象写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func3</span>: &#123; &lt;T&gt;(<span class="attr">arg</span>:T): T &#125; = func1;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>接口</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情形一：接口定义属性类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">contents</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情形二：接口定义方法或函数类型</span></span><br><span class="line"><span class="comment">// 2-1：类型参数定义在接口，实现该接口时需要给出类型参数的值。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">compareTo</span>(<span class="attr">value</span>: T): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2-2：类型参数定义在方法或函数中，实现该接口时不需要给出类型参数的值，使用对应方法或函数时才需要给出类型参数的值。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">    &lt;T&gt;(<span class="attr">arg</span>: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：一般写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="attr">key</span>: K;</span><br><span class="line">    <span class="attr">value</span>: V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：类表达式</span></span><br><span class="line"><span class="comment">// 补充：类表达式包含匿名类表达式和具名类表达式，后者更有利于调试，这里使用了匿名类表达式作为示例</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> &lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>, <span class="keyword">public</span> <span class="attr">age</span>: <span class="built_in">number</span>, <span class="keyword">public</span> <span class="attr">info</span>: T</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：构造函数类型写法</span></span><br><span class="line"><span class="comment">// 解释：JavaScript 中的类本质上是一个构造函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyClass1</span>&lt;T&gt; = <span class="title function_">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; T;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Myclass2</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意事项</span></span><br><span class="line"><span class="comment">    - 泛型类描述的是类的实例，因此类型参数不可应用于类中的静态属性和静态方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类型别名</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一：定义联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Nullable</span>&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二：定义对象类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例三：定义二叉树类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>类型参数至少需要出现两次，否则可能是非必要的。</p>
</li>
<li>
<p>泛型允许嵌套，即类型参数可以是另一个泛型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;T&gt; = T | <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;T&gt; = T | T[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;T&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;T&gt;&gt;; <span class="comment">// 等价于 T | T[] | null</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="1-2-可选的类型参数">1.2 可选的类型参数</h4>
<p>解释：在TypeScript中，类型参数可以设置默认值。</p>
<ul>
<li>当使用泛型但未指定类型参数时，将使用这个默认值。然而，如果 TypeScript 能够推断出类型参数的值，那么推断出的值将<strong>覆盖</strong>默认值。</li>
<li>类型参数的默认值在<strong>类</strong>中非常常见。</li>
<li>设置了默认值的类型参数也被称为<strong>可选</strong>类型参数。在多个类型参数列表中，可选类型参数必须位于<strong>最后</strong>。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">arr</span>: T[]): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getFirst</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 此时类型参数 T 被 TypeScript 推断为 number，覆盖了 T 的默认值 string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T = <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">    <span class="attr">list</span>: T[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(<span class="params"><span class="attr">t</span>: T</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">s1.<span class="title function_">add</span>(<span class="number">1</span>); <span class="comment">// ❌</span></span><br><span class="line">s1.<span class="title function_">add</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span>&lt;T, V = <span class="string">&#x27;yellow&#x27;</span>&gt; = T | V | <span class="string">&quot;red&quot;</span> | <span class="string">&quot;green&quot;</span> | <span class="string">&quot;blue&quot;</span>; <span class="comment">// ✅</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span>&lt;T = <span class="string">&#x27;up&#x27;</span>, V&gt; = T | V | <span class="string">&#x27;down&#x27;</span>; <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-类型参数的约束条件">1.3 类型参数的约束条件</h4>
<p>解释：在 TypeScript 中，可以为类型参数设置约束条件，语法为 <code>&lt;TypeParameter extends ConstraintType&gt;</code>。这表示类型参数<code>TypeParameter</code> 必须是约束类型 <code>ConstraintType</code> 的子类型。</p>
<ul>
<li>同时，类型参数可以设置默认值和约束条件，但默认值必须满足约束条件。</li>
<li>也可以使用其他类型参数作为约束条件，如 <code>&lt;T, U extends T&gt;</code>。然而，类型参数不能以自身作为约束条件，如 <code>&lt;T extends T&gt;</code> 是不允许的。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123; <span class="comment">// 这里约束类型参数 T 必须包含 number 类型的属性 length</span></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">comp</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">comp</span>(<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;ABCD&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tupleType&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, U <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&#x27;world&#x27;</span>&gt; = [T, U];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">t</span>: tupleType&lt;<span class="string">&#x27;hello&#x27;</span>&gt; = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="2-Enum">2. Enum</h3>
<h4 id="1-1-基本使用-5">1.1 基本使用</h4>
<ol>
<li>
<p>解释：Enum 是 TypeScript 新增的一种<strong>数据结构和类型</strong>，译为<strong>枚举</strong>，用于<strong>集中管理一组有关系的常量</strong>，从而增加代码的可读性和可维护性。枚举通过 <code>enum</code> 关键字定义，分为<strong>数值枚举</strong>、<strong><code>const</code> 枚举</strong>和<strong>字符串枚举</strong>。</p>
<blockquote>
<p>补充-1：可以通过<strong>点运算符</strong>或者<strong>方括号运算符</strong>来访问枚举中的某个成员。</p>
<p>补充-2：枚举既是一种<strong>类型</strong>，也是一个<strong>值</strong>。编译之后的枚举是一个 JavaScript 对象。</p>
<p>补充-3：由于枚举编译后是一个对象，因此建议谨慎使用枚举。一般来说，枚举可以被对象的 <code>as const</code> 断言所取代。同时，不能存在与枚举同名的变量（包括对象、函数、类等）。</p>
</blockquote>
</li>
<li>
<p>数值 Enum：数值 Enum 即枚举成员的值为<strong>数值</strong>的枚举，如果枚举成员未赋值，每个成员的值默认从 0 开始<strong>有序递增</strong>，如 0、1、2、……</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Down</span>, <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Left</span>, <span class="comment">// 2</span></span><br><span class="line">  <span class="title class_">Right</span> <span class="comment">// 3，枚举成员的值默认是数值，且从 0 开始有序递增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>); <span class="comment">// 0，点运算符访问枚举成员</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="string">&#x27;Down&#x27;</span>]); <span class="comment">// 1，方括号运算符访问枚举成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">up1</span>: <span class="built_in">number</span> = <span class="title class_">Direction</span>.<span class="property">Up</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">up2</span>: <span class="title class_">Direction</span> = <span class="title class_">Direction</span>.<span class="property">Up</span>; <span class="comment">// 枚举不仅仅是一个值，也是一种类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Direction</span> = <span class="number">1</span>; <span class="comment">// ×，不能有与枚举同名的变量</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：数值 Enum 支持为成员<strong>显式赋数值</strong>，但不能是大整数。其中，成员的值可以相同。</p>
<p>补充-2：数值 Enum 中，如果只设定某一个成员的值，后续成员的值就会以这个值为基准<strong>有序递增</strong>，如 N、N + 1、N + 2、……</p>
<p>补充-3：数值 Enum 中成员的值可以是<strong>表达式</strong>。</p>
<p>补充-4：数值 Enum 中成员的值都是<strong>只读的</strong>，无法重新赋值。</p>
</blockquote>
</li>
<li>
<p>const Enum：const Enum 即特殊的 Enum，其与一般 Enum 的区别在于 ① const Enum 使用 <code>const enum</code> 进行定义；② TypeScript <strong>不会将 const Enum 编译为一个对象</strong>，而是会将所有 Enum 成员出现的场合替换为对应成员的值，有利于提高性能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Down</span>, <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Left</span>, <span class="comment">// 2</span></span><br><span class="line">  <span class="title class_">Right</span> <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Up</span>; <span class="comment">// 被编译为 0 /* Direction.Up */;</span></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Down</span>; <span class="comment">// 被编译为 1 /* Direction.Down */; </span></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Left</span>; <span class="comment">// 被编译为 2 /* Direction.Left */;</span></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Right</span>; <span class="comment">// 被编译为 3 /* Direction.Right */;</span></span><br><span class="line"><span class="title class_">Direction</span>; <span class="comment">// ×，因为 Direction 没有编译产物，TypeScript 只会把代码中 Direction 成员替换为对应的值 </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：如果希望 const Enum 编译产物仍为对象，那么就要打开编译选项 <code>preserveConstEnum</code>。</p>
</blockquote>
</li>
<li>
<p>字符串 Enum：字符串 Enum 即枚举成员的值为<strong>字符串</strong>的枚举，与数值 Enum 不同，字符串 Enum 成员值必须<strong>显式设置</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Down</span>, <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;Left&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;Right&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 = <span class="title class_">Direction</span>.<span class="property">Up</span>;</span><br><span class="line"><span class="keyword">let</span> d2 = <span class="title class_">Direction</span>.<span class="property">Left</span>;</span><br><span class="line">d1 = <span class="number">1</span>; <span class="comment">// 可以赋值数值，但是只能赋值 0 或 1（枚举中已有的成员的值）</span></span><br><span class="line">d2 = <span class="string">&quot;Left&quot;</span>; <span class="comment">// 不可以赋值字符串，即使赋值 &quot;Left&quot; 或 &quot;Right&quot;（枚举中已有的成员的值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d3</span>: <span class="title class_">Direction</span> = <span class="title class_">Direction</span>.<span class="property">Left</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">d4</span>: <span class="string">&quot;Left&quot;</span> | <span class="string">&quot;Right&quot;</span> = d3; <span class="comment">// 字符串 Enum 可以使用联合类型替代</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充-1：字符串 Enum 允许成员值包含<strong>数值和字符串</strong>，但是在字符串 Enum 中，如果设置了某个成员值为字符串，那么其后的成员都需要设置为字符串，其前的成员的值默认从 0 开始<strong>有序递增</strong>。</p>
<p>补充-2：Enum 的成员值<strong>只能是数值和字符串</strong>。</p>
<p>补充-3：如果一个变量类型是数值 Enum，那么还<strong>可以将其他数值赋值给该变量</strong>；如果一个变量类型是字符串 Enum，那么<strong>不能将其他字符串赋值给该变量</strong>。</p>
<p>补充-4：字符串 Enum 做类型用时，可以使用<strong>联合类型</strong>来替代。</p>
<p>补充-5：字符串 Enum 成员值不能使用表达式进行赋值。</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-Enum-合并">1.2 Enum 合并</h4>
<ol>
<li>
<p>解释：多个同名的 Enum 会自动合并。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  green = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  yellow = <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  blue = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  green = <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">  yellow = <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  blue = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>多个 Enum 合并时，只允许其中一个的首个成员省略显式赋值，否则会报错。</li>
<li>多个 Enum 合并时，不允许有同名成员，否则报错。</li>
<li>多个 Enum 合并时，要么都是 const Enum，要么都是非 const Enum。</li>
</ul>
</li>
</ol>
<h4 id="1-3-反向映射">1.3 反向映射</h4>
<p>解释：反向映射指的是能<strong>通过成员值获取成员名</strong>，不过只有数值 <code>Enum</code> 才有反向映射，这是因为 TypeScript 对不同<code>Enum</code>的编译结果不一样造成的。</p>
<ul>
<li>
<p>数值 Enum 的编译结果</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上述代码的编译结果为, */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">var Direction;</span></span><br><span class="line"><span class="comment">(function (Direction) &#123;</span></span><br><span class="line"><span class="comment">    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;</span></span><br><span class="line"><span class="comment">    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;</span></span><br><span class="line"><span class="comment">    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;</span></span><br><span class="line"><span class="comment">    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;</span></span><br><span class="line"><span class="comment">&#125;)(Direction || (Direction = &#123;&#125;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上述编译结果等价于, */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;0&quot;: &quot;Up&quot;,</span></span><br><span class="line"><span class="comment">    &quot;1&quot;: &quot;Down&quot;,</span></span><br><span class="line"><span class="comment">    &quot;2&quot;: &quot;Left&quot;,</span></span><br><span class="line"><span class="comment">    &quot;3&quot;: &quot;Right&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Up&quot;: 0,</span></span><br><span class="line"><span class="comment">    &quot;Down&quot;: 1,</span></span><br><span class="line"><span class="comment">    &quot;Left&quot;: 2,</span></span><br><span class="line"><span class="comment">    &quot;Right&quot;: 3</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串 Enum 的编译结果</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;Up&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;Down&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;Left&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;Right&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上述代码的编译结果为, */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">var Direction;</span></span><br><span class="line"><span class="comment">(function (Direction) &#123;</span></span><br><span class="line"><span class="comment">    Direction[&quot;Up&quot;] = &quot;Up&quot;;</span></span><br><span class="line"><span class="comment">    Direction[&quot;Down&quot;] = &quot;Down&quot;;</span></span><br><span class="line"><span class="comment">    Direction[&quot;Left&quot;] = &quot;Left&quot;;</span></span><br><span class="line"><span class="comment">    Direction[&quot;Right&quot;] = &quot;Right&quot;;</span></span><br><span class="line"><span class="comment">&#125;)(Direction || (Direction = &#123;&#125;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上述编译结果等价于, */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;Up&quot;: &quot;Up&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Down&quot;: &quot;Down&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Left&quot;: &quot;Left&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Right&quot;: &quot;Right&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-Enum-提取">1.4 Enum 提取</h4>
<ol>
<li>
<p>成员名提取：TypeScript 中，可通过 <code>keyof typeof 枚举名</code> 这种方式，提取指定枚举的<strong>全部成员名</strong>，并将其作为<strong>联合类型</strong>返回。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;up&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;down&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;left&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;right&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D = keyof <span class="keyword">typeof</span> <span class="title class_">Direction</span>; <span class="comment">// &quot;Up&quot; | &quot;Down&quot; | &quot;Left&quot; | &quot;Right&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>成员值提取：在 TypeScript 中，可通过 <code>in</code> 运算符提取指定枚举的<strong>全部成员值</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;up&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;down&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;left&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;right&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D = &#123; [key <span class="keyword">in</span> <span class="title class_">Direction</span>]: <span class="built_in">any</span> &#125;; <span class="comment">// &#123; up: any; down: any; left: any; right: any; &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TS-类型断言">TS - 类型断言</h2>
<h3 id="基本使用">基本使用</h3>
<ol>
<li>
<p>类型断言：TypeScript 支持类型断言，允许开发者在代码中指定某个值的类型，此时编译器会放弃对该值的类型推断。</p>
</li>
<li>
<p>语法</p>
<ul>
<li><code>&lt;Type&gt;value</code>（不推荐，因为与 TypeScript 支持的 React-JSX 语法冲突）</li>
<li><code>value as Type</code>（推荐）</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>可以使用类型断言解决对象类型的<strong>严格字面量检查</strong>报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125;; <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用类型断言指定 <code>unknown</code> 类型的变量的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">str1</span>: <span class="built_in">unknown</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">str2</span>: <span class="built_in">string</span> = str1 <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型断言必须满足 “<strong>实际类型是断言类型的子类型</strong>” 或 “<strong>断言类型是实际类型的子类型</strong>”。但是该条件可以通过 “<strong>先将指定值断言为 <code>any</code> 或 <code>unknown</code> 类型，再将其断言为目标类型</strong>” 来避免。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// ❌</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">k</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="as-const-断言">as const 断言</h3>
<ol>
<li>
<p><code>as const</code> 断言：这种断言只能应用于字面量，它将字面量的类型断言为<strong>不可变类型</strong>，进一步缩小为 TypeScript 允许的<strong>最具体的类型</strong>。</p>
</li>
<li>
<p>语法</p>
<ul>
<li><code>&lt;const&gt;value</code></li>
<li><code>value as const</code></li>
</ul>
</li>
<li>
<p>使用说明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. as const 断言将某个值推断为值类型，此时 let 变量不能再改变值</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;javascript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型为 &#x27;javascript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. as const 断言不能用于变量和表达式</span></span><br><span class="line"><span class="keyword">let</span> s1 = s <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// ❌</span></span><br><span class="line"><span class="keyword">let</span> s2 = (<span class="string">&#x27;java&#x27;</span> + <span class="string">&#x27;script&#x27;</span>) <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// ❌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. as const 断言可以应用于整个对象（只读类型），也可以应用于对象中的单个属性（值类型，不可变）。</span></span><br><span class="line"><span class="keyword">const</span> p1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> <span class="keyword">as</span> <span class="keyword">const</span> &#125;; <span class="comment">// 类型为 &#123; name: string, age: 12 &#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// &#123; readonly name: &quot;Jack&quot;, readonly age: 12 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. as const 断言应用于数组，将其断言为只读元组。（元组长度可定，数组长度不可定，因此可以使用扩展运算符 + 元组为函数传参）</span></span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型为 readonly [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. as const 断言应用于枚举成员，将其断言为枚举的指定成员，此时 let 变量不能再改变为其他枚举成员</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Directions</span> &#123; <span class="title class_">Up</span>, <span class="title class_">Down</span>, <span class="title class_">Left</span>, <span class="title class_">Right</span> &#125;</span><br><span class="line"><span class="keyword">let</span> d1 = <span class="title class_">Directions</span>.<span class="property">Down</span>; <span class="comment">// 类型为 Directions</span></span><br><span class="line"><span class="keyword">let</span> d2 = <span class="title class_">Directions</span>.<span class="property">Down</span> <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型为 Directions.Down</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="非空断言">非空断言</h3>
<ol>
<li>
<p>非空断言：这种断言用于断言某些可能为空（可能为 <code>undefined</code> 或 <code>null</code>）的变量<strong>不会为空</strong>，避免编译报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line">root!.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法：<code>变量!</code></p>
</li>
<li>
<p>使用说明</p>
<ul>
<li>非空断言需要开发者确保一个表达式的值不为空。更保险的方式是，使用可能为空的变量前先进行手动检查。</li>
<li>非空断言只有在打开编译选项 <code>strictNullChecks</code> 时才有意义，否则编译器不会检查某个变量是否可能为空（即 <code>undefined</code> 或 <code>null</code>）。</li>
</ul>
</li>
</ol>
<h3 id="断言函数">断言函数</h3>
<ol>
<li>
<p>断言函数：该函数是一种特殊函数，用于<strong>保证函数参数符合某种类型</strong>。如果函数参数符合指定类型，则不进行任何操作；否则，就会抛出错误，中断程序执行。</p>
<ul>
<li>断言函数命名为 <code>isType</code>，要断言的参数 <code>value</code> 的类型为 <code>unknown</code>，函数体中包含断言逻辑。</li>
<li>断言函数有两种写法，
<ul>
<li>旧写法的返回值类型为 <code>void</code></li>
<li>新写法的返回值类型为 <code>asserts value is type</code>（相当于 <code>void</code> 类型，<code>asserts</code> 和 <code>is</code> 都是关键字，<code>value</code> 时要断言的函数参数名，<code>type</code> 时函数参数的预期类型）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p>旧写法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新写法（推荐，更清晰地表达函数意图，即该函数为断言函数）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果断言函数内部的检查与预期类型不一致，TypeScript 不会报错。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString1</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 断言函数的 asserts 语句等同于 void 类型，所以如果返回 undefined 或 null 以外的值，TypeScript 就会报错。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString2</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// ❌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以借助工具类型 NonNullable&lt;T&gt; 来断言函数参数非空。</span></span><br><span class="line"><span class="comment">// 补充：NonNullable&lt;T&gt; 对应类型 T 去除空类型（undefined 或 null）后的剩余类型。</span></span><br><span class="line"><span class="keyword">function</span> assertsIsDefined&lt;T&gt;(<span class="attr">value</span>: T): asserts value is <span class="title class_">NonNullable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">undefined</span> || value === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not defined`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">assertsIsDefined</span>(x); <span class="comment">// 此时代码执行时会抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 与断言函数不同，类型保护函数也可用于检查函数参数是否符合某种类型，但是其返回值为布尔值。</span></span><br><span class="line"><span class="comment">// 补充：类型保护函数命名为 isType，要保护的参数 value 的类型为 unknown，返回值类型为 value is type（相当于 boolean 类型），函数体中包含检查逻辑。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString3</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 可以使用断言函数的简写形式（asserts value）来断言某个参数为真（即不等于 false，undefind，null）。</span></span><br><span class="line"><span class="comment">// 补充：断言函数的简写形式通常也可用来检查某个操作是否成功。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): asserts value &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> should be a truthy value.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6-模块">ES6 - 模块</h2>
<blockquote>
<p>注意：这里所说<strong>接口</strong>指的是模块向外暴露的<strong>变量、类、函数</strong>。</p>
</blockquote>
<h3 id="简要概述">简要概述</h3>
<ol>
<li>
<p>ES6 模块化与 CommonJS 和 AMD 模块化的区别</p>
<ul>
<li>ES6 模块化在<strong>编译时</strong>加载模块，其模块是通过 <code>export</code> 命令显式输出的<strong>代码</strong>，可以直接加载指定的接口。由于 ES6 模块在编译时加载，因此可以对代码进行<strong>静态分析</strong>，如引入宏和类型检验等。</li>
<li>CommonJS 和 AMD 模块化在<strong>运行时</strong>加载模块，其模块是一个<strong>对象</strong>，必须加载完整个对象后，再从该对象身上读取指定的接口。</li>
</ul>
</li>
<li>
<p>ES6 模块的特点</p>
<ul>
<li>
<p>ES6 使用 <code>export</code> 命令<strong>导出</strong>模块的接口，<code>import</code> 命令<strong>导入</strong>其他模块提供的接口。</p>
</li>
<li>
<p>ES6 中<strong>一个文件就是一个模块</strong>，该文件中的所有接口，外部都无法获取（除非使用 <code>export</code> 命令导出接口）。</p>
</li>
<li>
<p>ES6 模块<strong>自动采用严格模式</strong>，即默认在模块头部添加 <code>&quot;use strict&quot;</code>。</p>
<blockquote>
<p>补充：严格模式在 ES5 引入。</p>
</blockquote>
</li>
<li>
<p>ES6 模块的<strong>顶层作用域</strong>中 <code>this</code> 指向 <code>undefined</code>，因此不应该在顶层作用域中使用 <code>this</code>。</p>
</li>
</ul>
</li>
</ol>
<h3 id="模块语法">模块语法</h3>
<h4 id="具名导出与导入">具名导出与导入</h4>
<ol>
<li>
<p><strong>具名导出</strong></p>
<ul>
<li>
<p>语法</p>
<ul>
<li>
<p>写法一：<strong>声明时导出</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> day = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> month = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> year = <span class="number">2025</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写法二：<strong>先声明，再导出</strong>（推荐，因为可以写在脚本尾部，更清晰）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> day = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> month = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> year = <span class="number">2025</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; day, month, year &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写法三：<strong>先声明，再导出，同时设置别名</strong>（允许给一个变量指定多个别名）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    day <span class="keyword">as</span> iday,</span><br><span class="line">    month <span class="keyword">as</span> imonth,</span><br><span class="line">    year <span class="keyword">as</span> iyear,</span><br><span class="line">    year <span class="keyword">as</span> jyear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>与 CommonJS 不同，ES6 通过 <code>export</code> 命令导出的接口与其对应的值是<strong>动态绑定</strong>的，即<strong>可以通过该接口访问到模块内部实时的值</strong>。</li>
<li><code>export</code> 命令可以出现在模块中的<strong>任何位置</strong>，但一定要处于顶层作用域。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>具名导入</strong></p>
<ul>
<li>
<p>语法</p>
<ul>
<li>
<p>写法一：<strong>直接导入接口</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; day, month, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写法二：<strong>直接导入接口，同时设置别名</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; day <span class="keyword">as</span> iday, month <span class="keyword">as</span> imonth, year <span class="keyword">as</span> iyear &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p><code>import</code> 命令导入的接口是<strong>只读的</strong>。虽然可以修改接口的属性，但是千万不要这么做，因为其他模块导入该接口时，会访问到被改写后的属性！</p>
</li>
<li>
<p><code>from</code> 命令用于指定模块的位置，其可以是<strong>相对路径、绝对路径或模块名</strong>。如果使用模块名，则必须包含配置文件，以告诉 JavaScript 引擎该模块的位置。</p>
</li>
<li>
<p><code>import</code> 命令会被<strong>提升</strong>到整个模块顶部首先执行。</p>
</li>
<li>
<p><code>import</code> 命令会<strong>执行</strong>所加载的模块，因此允许直接使用 <code>import '模块位置'</code> 的方式执行模块。</p>
</li>
<li>
<p><strong>多次加载一个模块只会执行一次</strong>，可以理解为 <code>import</code> 语句是 singleton 模式的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>虽然 Babel 允许在同一模块中混用 CommonJS 的 <code>require</code> 和 ES6 的 <code>import</code>，但不推荐这样做。因为 <strong>ES6 模块（静态加载）总是早于 CommonJS 模块（动态加载）执行</strong>，可能导致意外结果。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="默认导出与导入">默认导出与导入</h4>
<ol>
<li>
<p>解释：不同于具名导出，ES6允许使用 <code>export default</code> 为模块设置<strong>默认导出接口</strong>。当其他模块加载此模块时，可以为此默认导出接口指定<strong>任何名称</strong>。</p>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p><strong>默认导出</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>默认导入</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p><strong>每个模块只能有一个默认输出</strong>，这意味着在一个模块中，<code>export default</code> 命令只能使用一次。</p>
</li>
<li>
<p><code>export default xxx</code> 本质上是将模块的特定接口<strong>赋值</strong>给一个名为 <code>default</code> 的变量并具名导出。当其他模块导入这个 <code>default</code> 变量时，ES6 允许使用任何名称来引用该变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; add <span class="keyword">as</span> <span class="keyword">default</span> &#125;; <span class="comment">// 等价于 export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example2</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">// 等价于 import foo from &quot;./xxx.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 等价于 var default = a; export &#123; default &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example4</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">124</span>; <span class="comment">// 等价于 var default = 124; export &#123;default&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example5</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// ❌，因为默认导出的本质是赋值，显然 var default = var a 的赋值方式是错误的，所以这里报错</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>默认导入和具名导入可以同时使用</strong>，表示同时导入默认接口和具名接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName, &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="整体导入">整体导入</h4>
<ol>
<li>
<p>解释：整体导入是指将模块的所有<strong>公开接口</strong>加载到一个以星号 <code>*</code> 表示的对象上。在使用时，需要为此对象<strong>设置别名</strong>。这样，被导入模块的所有公开接口都将被<strong>加载</strong>到这个别名对象上。</p>
</li>
<li>
<p>语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> customName <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<ul>
<li>通过模块整体导入创建的对象在<strong>运行时不可更改</strong>，因为这会破坏 ES6 的静态加载特性。</li>
</ul>
</li>
</ol>
<h3 id="重导出">重导出</h3>
<blockquote>
<p>注意：这里的默认接口指的是默认导出的接口，具名接口指的是具名导出的接口</p>
</blockquote>
<ol>
<li>
<p>解释：在 ES6 中，<code>import</code> 命令和 <code>export</code> 命令可以复合使用，这表示<strong>先导入然后再导出</strong>同一个模块的接口，称之为重导出。实际上，这些接口并<strong>没有真正被导入</strong>到当前模块，而只是在当前模块进行了<strong>接口的转发</strong>。</p>
</li>
<li>
<p>语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; xxx &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; xxx <span class="keyword">as</span> customName &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> customName <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span> <span class="comment">// ES2020 新增写法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>export customName from './xxx.js'</code> 的语法是非法的</p>
</blockquote>
</li>
<li>
<p>应用示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1 将具名接口改名后转发</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example2 将所有接口（具名接口）整体转发</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example3 将默认接口转发</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example4 将具名接口改为默认接口后转发</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example5 将默认接口改为具名接口后转发</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example5 将所有接口（默认接口 + 具名接口）封装为命名空间后转发</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> customName <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="跨模块常量">跨模块常量</h3>
<ol>
<li>
<p>解释：跨模块常量是指被<strong>导出</strong>并在<strong>多个模块间共享</strong>的常量。</p>
</li>
<li>
<p>实践：为了<strong>管理跨模块常量</strong>，我们通常在项目中创建一个 <code>constants</code> 目录，并将不同用途的常量保存在该目录下的不同文件中。在 <code>constants</code> 目录中，我们可以创建一个 <code>index.js</code> 文件，用于将其他文件导出的常量合并并重新导出（重导出）。这样，当需要使用跨模块常量时，只需要加载 <code>constants/index.js</code> 文件即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,</span><br><span class="line">  <span class="attr">admin_username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  <span class="attr">admin_password</span>: <span class="string">&#x27;admin password&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;staff&#x27;</span>, <span class="string">&#x27;ceo&#x27;</span>, <span class="string">&#x27;chief&#x27;</span>, <span class="string">&#x27;moderator&#x27;</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; db &#125; <span class="keyword">from</span> <span class="string">&#x27;./db&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; users &#125; <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants/index&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="运行时加载">运行时加载</h3>
<ol>
<li>
<p>解释：ES6 模块化通过 <code>import</code> 命令实现<strong>静态</strong>加载模块，也就是在<strong>编译时</strong>加载模块。 <code>import</code> 命令会在模块中<strong>最先执行</strong>，如果它位于<strong>代码块</strong>（如条件语句）中，将会引发<strong>语法错误</strong>。然而，为了实现<strong>动态</strong>加载模块，也就是在<strong>运行时</strong>加载模块，ES2020 引入了 <code>import()</code> 函数。这个函数接受一个参数 <code>specifier</code>，表示模块的位置，然后在<strong>运行时</strong>加载指定的模块，并返回一个 Promise 对象。<code>import()</code> 函数的功能类似于 Node.js 的 <code>require</code> 方法。</p>
</li>
<li>
<p>语法：<code>import(specifier)</code></p>
<blockquote>
<p><code>specifier</code> 指定了模块位置，与 <code>import</code> 命令相同，可以是相对路径、绝对路径或模块名。</p>
</blockquote>
</li>
<li>
<p>使用说明</p>
<ul>
<li><code>import()</code> 函数的使用时机有：<strong>按需加载模块</strong>、<strong>条件加载模块</strong>、<strong>模块的路径需要动态生成</strong>。</li>
<li><code>import()</code> 函数可以用在<strong>任何地方</strong>，包括非模块脚本（如 <code>type</code> 属性不为 <code>module</code> 的 <code>script</code> 标签中的脚本）。</li>
<li>当 <code>import()</code> 函数成功动态加载模块后，该模块会被作为一个<strong>对象</strong>传递给 <code>then</code> 方法作为参数。模块中导出的**所有接口（包括默认接口）**都会作为这个对象的属性存在。</li>
<li>如果需要<strong>同时动态加载多个模块</strong>，你可以使用 <code>Promise.all()</code> 方法。在这种情况下，<code>then</code> 方法的参数将是一个由这些模块对象构成的数组。</li>
</ul>
</li>
</ol>
<h3 id="模块元信息">模块元信息</h3>
<ol>
<li>
<p>解释：ES2020 引入了 <code>import.meta</code>，允许在当前模块中访问<strong>模块的元信息</strong>。<code>import.meta</code> 是一个<strong>只能在模块内部使用</strong>的对象，它的属性取决于<strong>运行环境</strong>，没有统一的规定。</p>
</li>
<li>
<p>常用属性</p>
<ul>
<li>
<p><code>import.meta.url</code>：当前模块的完整 URL。该属性可以用于构建与当前模块相关的资源路径。</p>
</li>
<li>
<p><code>import.meta.scriptElement</code>：加载当前模块的 <code>script</code> 元素，相当于 <code>document.currentScript</code>（浏览器特有）。</p>
</li>
<li>
<p><code>import.meta.filename</code>：当前模块的绝对路径，相当于 CommonJS 的 <code>__filename</code>（Deno 特有）。</p>
</li>
<li>
<p><code>import.meta.dirname</code>：当前模块所在目录的绝对路径，相当于 CommonJS 的 <code>__dirname</code>（Deno 特有）。</p>
<blockquote>
<p>补充：Deno 是一个 JavaScript 和 TypeScript 运行时，默认使用 ES 模块化，且内置 TypeScript 支持。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="ES6-模块加载">ES6 - 模块加载</h2>
<h3 id="浏览器加载">浏览器加载</h3>
<ol>
<li>
<p>加载非模块脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内嵌脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 脚本内容</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>浏览器脚本的<strong>默认语言</strong>是 JavaScript，因此 <code>type=&quot;application/javascript&quot;</code> 可以<strong>省略</strong>。</p>
</li>
<li>
<p>默认情况下，浏览器<strong>同步加载</strong> JavaScript 脚本，即当渲染引擎遇到 <code>&lt;script&gt;</code> 标签时就会停下来，等到执行完脚本，再继续向下渲染。对于外部脚本，还需要包含脚本下载的时间。</p>
</li>
<li>
<p>如果 <code>&lt;script&gt;</code> 标签使用 <code>defer</code> 或 <code>async</code> 属性，浏览器会<strong>异步加载</strong> JavaScript 脚本。</p>
<table>
<thead>
<tr>
<th style="text-align:center">比较</th>
<th style="text-align:center"><code>defer</code></th>
<th style="text-align:center"><code>async</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>执行时机</strong></td>
<td style="text-align:center">渲染完再执行<br />（脚本会在 DOM  结构完全生成后再执行）</td>
<td style="text-align:center">下载完就执行<br />（脚本会在下载完后立即执行，此时会使渲染引擎中断渲染）</td>
</tr>
<tr>
<td style="text-align:center"><strong>顺序执行</strong></td>
<td style="text-align:center">是<br />（多个 <code>defer</code> 脚本会根据其在页面出现的顺序执行）</td>
<td style="text-align:center">否<br />（多个 <code>async</code> 脚本不能保证执行顺序）</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>加载 ES6 模块脚本（使用 <code>type=&quot;module&quot;</code> 属性）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内嵌脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 脚本内容</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>浏览器<strong>异步加载</strong> ES6 模块，相当于<strong>自带了 <code>defer</code> 属性</strong>。此时，模块脚本会等待整个页面渲染完再执行，且多个模块脚本会按照其在页面出现的顺序执行。但是如果此时使用了 <code>async</code> 属性，模块脚本只要下载完成就会立即执行，且多个模块脚本之间的执行顺序也无法保证。</li>
<li>模块脚本的特点
<ul>
<li><strong>模块作用域</strong>：代码运行的作用域是模块作用域，而不是全局作用域。因此模块内部的顶层变量，外部不可见。</li>
<li><strong>严格模式</strong>：自动使用严格模式（相当于声明了 “use strict”），此时模块顶层 <code>this</code> 的值是 <code>undefined</code>。</li>
<li><strong>导入导出</strong>：可以使用 <code>import</code> 命令加载其他模块（不能省略 <code>.js</code> 后缀），使用 <code>export</code> 命令向外暴露接口。</li>
<li><strong>执行一次</strong>：同一个模块加载多次时，只执行一次。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Node-js-加载">Node.js 加载</h3>
<h4 id="加载区别">加载区别</h4>
<p>Node.js 支持 CommonJS 模块（CJS）和 ES6 模块（MJS），二者不兼容，区别有</p>
<ul>
<li>
<p>CommonJS 模块使用 <code>require</code> 和 <code>module.export</code>；ES6 模块使用 <code>import</code> 和 <code>export</code>。</p>
</li>
<li>
<p>CommonJS 模块采用 <code>.cjs</code> 后缀；ES6 模块采用 <code>.mjs</code> 后缀。</p>
<blockquote>
<p>package.json 文件中，如果指定 <code>&quot;type&quot;: &quot;module&quot;</code>，那么 <code>.js</code> 文件以 ES6 模块加载；如果指定 <code>&quot;type&quot;: &quot;commonjs&quot;</code> 或不指定，则 <code>.js</code> 文件以 CommonJS 模块加载。</p>
</blockquote>
<blockquote>
<p>ES6 模块与 CommonJS 模块不要混用！</p>
</blockquote>
</li>
</ul>
<hr>
<p>Node.js <strong>加载 ES6 模块的注意事项</strong>。</p>
<ul>
<li>
<p><strong>不能省略脚本的后缀名</strong>，包括 <code>import</code> 命令和 package.json 中 <code>main</code> 字段指定的脚本路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index.js&#x27;</span>; <span class="comment">// ✅</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>; <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>.mjs</code> 文件支持 URL 路径</strong>，即路径中可以包含查询参数。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。因此，只要文件名中含有 <code>:</code>、<code>%</code>、<code>#</code>、<code>?</code> 等特殊字符，最好对这些字符进行转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Node.js 的 <code>import</code> 命令仅支持加载本地模块</strong>（使用 <code>file:</code> 协议）和 <code>data:</code> 协议。远程模块加载（例如通过 <code>http:</code> 或 <code>https:</code>）是不支持的。</p>
</li>
<li>
<p><strong>在使用 <code>import</code> 时，只支持相对路径</strong>，也就是说路径必须以 <code>./</code> 或 <code>../</code> 开头。绝对路径（以 <code>/</code> 或 <code>//</code> 开头）是不支持的。</p>
</li>
</ul>
<hr>
<p>Node.js 中<strong>不能在 ES6 模块中使用</strong>，而<strong>可以在 CommonJS 模块中使用</strong>的<strong>内部顶层变量</strong>有，</p>
<ul>
<li><code>this</code>（在 ES6 模块中，顶层 <code>this</code> 指向 <code>undefined</code>；在 CommonJS 中，顶层 <code>this</code> 指向当前模块）</li>
<li><code>arguments</code></li>
<li><code>require</code></li>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>__filename</code></li>
<li><code>__dirname</code></li>
</ul>
<h4 id="入口配置">入口配置</h4>
<p><code>package.json</code> 有两个字段可以<strong>指定模块的入口文件</strong>：<code>main</code> 和 <code>exports</code>，其中 <code>exports</code> 字段的用法更加复杂，优先级<strong>高</strong>于 <code>main</code> 字段。</p>
<ol>
<li>
<p><code>main</code> 指定<strong>模块加载的入口</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>exports</code> 指定<strong>脚本或子目录别名</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span>, <span class="comment">// 脚本别名</span></span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span> <span class="comment">// 子目录别名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果没有通过 <code>exports</code> 关键字指定别名，此时就不能使用 “<strong>模块名+脚本名</strong>” 来加载模块中的指定脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 ❌</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错 ✅</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p><code>exports</code> 指定<strong>模块加载的主入口</strong>，优先级<strong>高</strong>于 <code>main</code> 字段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 完整写法，别名 &quot;.&quot; 表示模块的主入口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 简写形式，&quot;exports&quot; 直接表示模块的主入口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>exports</code> 字段只有支持 ES6 的 Node.js 才认识，因此可以搭配 <code>main</code> 字段，来<strong>兼容</strong>旧版本的 Node.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>, <span class="comment">// 老版本 Node.js 的入口文件</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span> <span class="comment">// 新版本 Node.js 的入口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p><code>exports</code> 指定 <strong>CommonJS 和 ES6 的模块加载的主入口</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 使用 require() 命令的入口文件 - CommonJS 入口</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 使用 import 命令的入口文件 - ES6 入口</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 简写形式</span></span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 简写形式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果通过 <code>exports</code> 关键字还设置了其他别名，此时就不能使用简写形式来进行条件加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错 ❌</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h4 id="兼容加载">兼容加载</h4>
<ol>
<li>
<p><strong>CommonJS 模块中加载 ES6 模块</strong>：使用 <code>import()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>ES6 模块中加载 CommonJS 模块</strong>：使用 <code>import</code> 命令<strong>整体加载</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确 ✅</span></span><br><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 ❌</span></span><br><span class="line"><span class="keyword">import</span> &#123; method &#125; <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确 ✅（加载单一的输出项）</span></span><br><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; method &#125; = packageMain;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种不建议的在 ES6 模块中加载 CommonJS 模块的方法是，使用 Node.js 内置的 <code>module.createRequire()</code> 方法。这种写法将 ES6 和 CommonJS 用法混合，因此不建议使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./xxx.cjs&#x27;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>Node.js 的内置模块使用 <code>import</code> 命令加载时，既可以<strong>整体加载</strong>，也可以<strong>加载指定的输出项</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">EventEmitter</span> <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="兼容支持">兼容支持</h4>
<ol>
<li>
<p><strong>ES6 模块允许被 CommonJS 模块加载</strong>：在 ES6 模块中添加一个<strong>整体输出接口</strong>，如 <code>export default obj</code>。</p>
</li>
<li>
<p><strong>CommonJS 模块允许被 ES6 模块加载</strong>：给 CommonJS 模块添加一个<strong>包装层</strong>（是一个符合 ES6 模块化规范的文件），该文件中<strong>先整体输入 CommonJS 模块，再根据需要输出具名接口</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.<span class="property">foo</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了让包装层符合 ES6 模块化规范，可以把这个文件的后缀名改为 <code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的 <code>package.json</code> 文件，指明 <code>&#123; type: &quot;module&quot; &#125;</code>。</p>
</blockquote>
</li>
<li>
<p>如果希望一个模块同时被 <code>require()</code> 或 <code>import</code> 加载，那么可以使用 package.json 中的 <code>exports</code> 字段设置<a href="#%E6%A8%A1%E5%9D%97%E5%85%A5%E5%8F%A3%E9%85%8D%E7%BD%AE">条件加载</a>，即指明<strong>不同格式的模块各自加载的入口</strong>。</p>
</li>
</ol>
<h3 id="ES6-模块化-Vs-CommonJS-模块化">ES6 模块化 Vs. CommonJS 模块化</h3>
<table>
<thead>
<tr>
<th style="text-align:center">区别</th>
<th style="text-align:center">ES6</th>
<th style="text-align:center">CommonJS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>输出类型</strong></td>
<td style="text-align:center">值的引用</td>
<td style="text-align:center">值的拷贝</td>
</tr>
<tr>
<td style="text-align:center"><strong>加载时机</strong></td>
<td style="text-align:center">编译时加载</td>
<td style="text-align:center">运行时加载</td>
</tr>
<tr>
<td style="text-align:center"><strong>加载方式</strong></td>
<td style="text-align:center"><code>import</code> 异步加载</td>
<td style="text-align:center"><code>require()</code> 同步加载</td>
</tr>
</tbody>
</table>
<p>进一步解释</p>
<ol>
<li>
<p>CommonJS 加载的模块是通过 <code>module.exports</code> 暴露出的<strong>对象</strong>，该对象在<strong>脚本运行完</strong>后生成。ES6 加载的模块是一种<strong>静态定义</strong>，在代码<strong>静态解析阶段</strong>生成。</p>
</li>
<li>
<p>CommonJS 模块输出的是值的<strong>拷贝</strong>，ES6 模块输出的是值的<strong>引用</strong>，通过以下代码可以清楚感知到其区别！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>); <span class="comment">// or import mod from &#x27;./lib&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>);  <span class="comment">// 3</span></span><br><span class="line">mod.<span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>); <span class="comment">// 3 for CommonJS; 4 for ES6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>CommonJS 输出分析：<code>mod.incCounter()</code> 方法的调用并未影响 <code>mod.counter</code> 的值，这是因为加载模块时，<strong>会对模块所有暴露的接口进行缓存</strong>。如果想通过 <code>lib.js </code>模块的 <code>incCounter()</code> 方法来修改暴露的 <code>counter</code>，需要将 <code>counter</code> 属性设置为一个 <code>getter</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">counter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ES6 输出分析：<code>mod.incCounter()</code> 方法的调用影响了 <code>mod.counter</code> 的值，这是因为 JS 在进行静态分析时，遇到 <code>import</code> 命令后，会生成一个<strong>只读引用</strong>。当脚本执行时，会<strong>通过这个只读引用去加载的模块取值</strong>。ES6 模块不会缓存运行结果，而是<strong>动态地从被加载的模块中取值</strong>，因此引入的模块接口都是只读的。</p>
</li>
</ul>
</li>
<li>
<p>其他关于 CommonJS-值的<strong>拷贝</strong> 与 ES6-值的<strong>引用</strong> 区别的示例代码如下，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sum</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.<span class="title function_">add</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.<span class="title function_">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./x&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./y&#x27;</span>; <span class="comment">// 0 for CommonJS; 1 for ES6</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="循环加载">循环加载</h3>
<p>循环加载（circular dependency）指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。</p>
<ol>
<li>
<p>CommonJS 模块化中的循环加载</p>
<ul>
<li>
<p><strong>模块加载原理</strong>：在 CommonJS 中，当你使用 <code>require</code> 命令<strong>第一次加载</strong>特定模块时，该模块会被<strong>执行</strong>，并在内存中生成一个<strong>对象</strong>。之后，当你需要使用这个模块时，就会从这个<strong>内存对象的 <code>exports</code> 属性</strong>中取值。即使你再次执行 <code>require</code> 命令，该模块也不会再次执行，而是直接从<strong>缓存</strong>中取值。因此，<strong>无论你加载一个 CommonJS 模块多少次，它都只会在第一次加载时运行一次，之后的加载都会返回第一次运行的结果</strong>，除非你手动清除系统缓存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;...&#x27;</span>, <span class="comment">// 模块名称</span></span><br><span class="line">  <span class="attr">exports</span>: &#123; ... &#125;, <span class="comment">// 模块输出的各个接口</span></span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">true</span>, <span class="comment">// 表示该模块的脚本是否执行完毕</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>循环加载策略</strong>：一旦出现某个模块被 “循环加载”，就<strong>只输出已经执行的部分</strong>，还未执行的部分不会输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>; <span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// &lt;2&gt;</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	模块 a 暂时挂起，等待模块 b 加载完成。</span></span><br><span class="line"><span class="comment">	此时 a 的 exports 属性已经初始化，但可能还未达到最终状态。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.<span class="property">done</span>); <span class="comment">// &lt;8&gt;</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>; <span class="comment">// &lt;9&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js 执行完毕&#x27;</span>); <span class="comment">// &lt;10&gt;</span></span><br><span class="line"><span class="comment">/* 模块 a 的执行完成 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>; <span class="comment">// &lt;3&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); <span class="comment">// &lt;4&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  此时模块 a 被循环加载，只能访问 a 的当前导出状态，即 exports: &#123; done: false &#125;。</span></span><br><span class="line"><span class="comment">  在循环加载时，不会暂停当前模块的执行，而是使用模块 a 已经导出的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.<span class="property">done</span>); <span class="comment">// &lt;5&gt;</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>; <span class="comment">// &lt;6&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js 执行完毕&#x27;</span>); <span class="comment">// &lt;7&gt;</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	模块 b 执行完毕后，控制权返回给模块 a，模块 a 继续执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="property">done</span>, b.<span class="property">done</span>);</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    在 b.js 之中，a.done = false</span></span><br><span class="line"><span class="comment">    b.js 执行完毕</span></span><br><span class="line"><span class="comment">    在 a.js 之中，b.done = true</span></span><br><span class="line"><span class="comment">    a.js 执行完毕</span></span><br><span class="line"><span class="comment">    在 main.js 之中, a.done=true, b.done=true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>安全的模块加载方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法 ✅</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).<span class="property">foo</span>; <span class="comment">// 危险的写法（如果发生循环加载，值后续可能会被改写） ❌</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>ES6 模块化中的循环加载</p>
<ul>
<li>
<p>循环加载策略：一旦某个模块被 “循环加载”，就会<strong>认为使用的该模块的相关接口已经存在</strong>，继续向下执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>; <span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>); <span class="comment">// &lt;6&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>()); <span class="comment">// &lt;7&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// &lt;8&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>; <span class="comment">// &lt;2&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>); <span class="comment">// &lt;3&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>()); <span class="comment">// &lt;4&gt; 未定义报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// &lt;5&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="TS-模块">TS - 模块</h2>
<h3 id="简要概述-2">简要概述</h3>
<p>任何<strong>包含 <code>import</code> 或 <code>export</code> 语句的文件</strong>，就是一个<strong>模块</strong>（module）。</p>
<ul>
<li>
<p>如果文件不包含 <code>export</code> 语句，就是一个<strong>全局的脚本文件</strong>。</p>
</li>
<li>
<p>模块本身就是一个<strong>作用域</strong>，不属于全局作用域。</p>
</li>
<li>
<p>暴露给外部的接口，必须用 <code>export</code> 命令声明；如果其他文件要使用模块的接口，必须用 <code>import</code> 命令来输入。</p>
</li>
<li>
<p>如果一个文件<strong>不包含 <code>export</code> 语句，但是希望把它当作一个模块</strong>（即内部变量对外不可见），可以在脚本头部添加一行语句如下，此时当前文件被当作模块处理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TypeScript 允许加载模块时，<strong>省略模块文件的后缀名</strong>。</p>
</li>
</ul>
<h3 id="模块语法-2">模块语法</h3>
<blockquote>
<p>注意-1：这里的类型包括 <code>type</code> 或 <code>interface</code> 关键字声明的类型。</p>
</blockquote>
<blockquote>
<p>注意-2：TypeScript 中通过 <code>export</code> 导出的内容分为<strong>正常接口</strong>和<strong>类型</strong>。</p>
</blockquote>
<p>TypeScript 支持所有 <strong>ES6 模块</strong>语法，此外还支持<strong>类型</strong>的导出和导入。</p>
<blockquote>
<p>注意：以下示例中，假设 A 是类型，a 是正常接口（变量、类、函数）。</p>
</blockquote>
<ol>
<li>
<p><strong>类型导出</strong></p>
<ul>
<li>
<p>语法一（不推荐，难以区分类型和正常接口）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123; <span class="attr">foo</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于（简写形式）</span></span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">foo</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; A, a &#125;; <span class="comment">// A 是类型，a 是值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法二</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">type</span> A, a &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法三</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> &#123; A &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>类型导入</strong></p>
<ul>
<li>
<p>语法一（不推荐，难以区分类型和正常接口）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;A, a&#125; <span class="keyword">from</span> <span class="string">&#x27;./my_module&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法二</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> A, a &#125; <span class="keyword">from</span> <span class="string">&#x27;./my_module&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法三</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>TypeScript 还支持<strong>默认导出导入和整体导入</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">interface</span> <span class="title class_">User</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;; <span class="comment">// 默认导出 - interface 定义的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Stu</span> = &#123; <span class="attr">grade</span>: <span class="built_in">number</span> &#125;; <span class="comment">// 默认导出 - type 定义的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Stu</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入 - 引入模块的默认导出类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> <span class="title class_">DefaultType</span> <span class="keyword">from</span> <span class="string">&#x27;./my_module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入 - 将模块的所有导出类型作为一个命名空间引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> * <span class="keyword">as</span> <span class="title class_">TypeNS</span> <span class="keyword">from</span> <span class="string">&#x27;./my_module&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于一个类，如果使用 <code>export &#123; className &#125;</code> 导出，那么导出的是一个<strong>正常接口</strong>；如果使用 <code>export type &#123; className &#125;</code> 导出，那么导出的是一个<strong>类型</strong>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="CommonJS-模块处理">CommonJS 模块处理</h4>
<ol>
<li>
<p>模块导入</p>
<ul>
<li>
<p><code>import=</code> 语句</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>import * as [模块名] from &quot;模块地址&quot;</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>模块导出：<code>export=</code> 语句</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = obj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>export=</code> 语句输出的对象，只能使用 <code>import =</code> 语句加载。</p>
</blockquote>
</li>
</ol>
<h3 id="类型编译">类型编译</h3>
<p>TypeScript 提供编译选项 <code>importsNotUsedAsValues</code> 来指定导入<strong>类型</strong>的 <code>import</code> 命令的编译方式。该编译选项的可取值为，</p>
<ul>
<li><code>remove</code>：默认值。删除导入类型的 <code>import</code> 语句。</li>
<li><code>preserve</code>：保留类型的 <code>import</code> 语句，将其变为 “<strong><code>import</code> 模块位置</strong>” 的形式，从而保留模块中的副作用。</li>
<li><code>error</code>：保留类型的 <code>import</code> 语句，与 <code>preserve</code> 相同，但是导入类型必须使用 <code>import type</code> 的形式，否则报错。</li>
</ul>
<hr>
<p>假设 <code>.ts</code> 脚本中有以下代码，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>&quot;importsNotUsedAsValues&quot;: &quot;remove&quot;</code> 时，编译结果为空。</p>
</li>
<li>
<p><code>&quot;importsNotUsedAsValues&quot;: &quot;preserve&quot;</code> 时，编译结果为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>&quot;importsNotUsedAsValues&quot;: &quot;error&quot;</code> 时，编译报错，除非原始的 <code>.ts</code> 脚本中的代码如下，此时编译结果与 <code>&quot;preserve&quot;</code> 的编译结果相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模块定位">模块定位</h3>
<p>模块定位（module resolution）指的是，一种用来确定 <code>import</code> 语句和 <code>export</code> 语句里面的<strong>模块文件位置</strong>的算法。</p>
<h4 id="相对、非相对模块">相对、非相对模块</h4>
<ol>
<li>
<p><strong>相对模块</strong>（relative import）：指的是路径以 <code>/</code>、<code>./</code>、<code>../</code> 开头的模块。相对模块根据<strong>当前脚本所在位置</strong>进行计算，通常用于保存在当前项目目录结构中的模块脚本。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Entry</span> <span class="keyword">from</span> <span class="string">&quot;./components/Entry&quot;</span>; <span class="comment">// 相对路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DefaultHeaders</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../constants/http&quot;</span>; <span class="comment">// 相对路径</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;/mod&quot;</span>; <span class="comment">// 绝对路径</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>非相对模块</strong>（non-relative import）：指的是不带有路径信息的模块。非相对模块根据 <strong><code>baseUrl</code> 属性或模块映射</strong>来确定，通常用于加载外部模块。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Classic、Node-方法">Classic、Node 方法</h4>
<p>TypeScript 使用编译参数 <code>moduleResolution</code> 来<strong>确定模块定位算法</strong>，常用的算法有两种：<code>Classic</code> 和 <code>Node</code>。其中 <code>Node</code> 方法就是模拟 Node.js 的加载方法，即 <code>require()</code> 的实现方法。</p>
<p>根据编译参数 <code>module</code> 值的不同，编译参数 <code>moduleResolution</code> 有不同的默认值，<code>&quot;module&quot;: &quot;commonjs&quot;</code> 时，默认值为 <code>&quot;node&quot;</code>，否则为 <code>&quot;classic&quot;</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块定位方法</th>
<th style="text-align:center">Classic 方法</th>
<th style="text-align:center">Node 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相对模块</td>
<td style="text-align:center">以当前脚本的路径作为<strong>基准路径</strong>，计算相对模块的位置。</td>
<td style="text-align:center">以当前脚本的路径作为<strong>基准路径</strong>，<br />1. 首先检查当前目录中是否存在与模块名称对应的 <code>.ts</code>、<code>.tsx</code>、<code>.d.ts</code>  文件。如果找到，直接加载该文件。<br />  2. 如果没有找到对应的文件，接下来检查当前目录中是否存在与模块名称对应的目录。 如果该目录存在，进一步检查目录下的 <code>package.json</code> 文件。 如果 <code>package.json</code> 文件存在，并且 <code>types</code> 字段指定了模块的入口文件，则加载该入口文件。<br />  3. 如果 <code>package.json</code> 文件不存在或 <code>types</code> 字段未指定入口文件，查找该目录下的 <code>index.ts</code>、<code>index.tsx</code>、或 <code>index.d.ts</code> 文件。 如果找到其中一个文件，则加载该文件。<br />4. 如果以上步骤均未成功找到模块，则抛出错误，提示无法找到指定模块。</td>
</tr>
<tr>
<td style="text-align:center">非相对模块</td>
<td style="text-align:center">以当前脚本的路径作为<strong>起点</strong>，一层层查找上级目录。</td>
<td style="text-align:center">1. 首先检查当前目录的 <code>node_modules</code> 子目录中是否存在文件 <code>.ts</code>、<code>.tsx</code> 或 <code>.d.ts</code>。如果找到，直接加载该文件。<br /> 2.  如果没有找到对应的文件，检查 <code>node_modules</code> 子目录中是否存在 <code>package.json</code> 文件。 如果 <code>package.json</code> 文件存在，并且 <code>types</code> 字段指定了入口文件，则加载该入口文件。<br />3.   如果 <code>package.json</code> 文件没有指定入口文件，检查 <code>node_modules</code> 中是否存在 <code>@types</code> 子目录。 在 <code>@types</code> 目录中查找 <code>.d.ts</code> 文件，如果找到，则加载该文件。<br />4.   如果没有找到 <code>@types</code> 目录或文件，检查 <code>node_modules</code> 中是否存在与模块名称相同的子目录。 在子目录中查找 <code>index.ts</code>、<code>index.tsx</code> 或 <code>index.d.ts</code> 文件。如果找到其中一个文件，则加载该文件。<br />5.   如果在当前目录中未找到模块，进入上一层目录，并重复上述步骤。 继续向上查找，直到找到模块或到达文件系统的根目录为止。</td>
</tr>
</tbody>
</table>
<h4 id="路径映射配置">路径映射配置</h4>
<p>TypeScript 提供了以下 <code>tsconfig.json</code> 中的配置，来指定<strong>脚本模块的路径</strong>。</p>
<ol>
<li>
<p><code>compilerOptions.baseUrl</code>：指定<strong>脚本模块的基准目录</strong>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span> <span class="comment">// &quot;.&quot; 表示基准目录是 tsconfig.json 所在的目录。</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>compilerOptions.paths</code>：指定<strong>非相对模块与实际脚本的映射</strong>，常与 <code>baseUrl</code> 配合使用。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span><span class="punctuation">]</span> <span class="comment">// 加载 jquery 时，实际加载的脚本为 node_modules/jquery/dist/jquery（结合 baseUrl 进行计算）</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：每个非相对模块名的值是一个数组，<strong>可以指定多个路径</strong>。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推。</p>
</blockquote>
</li>
<li>
<p><code>compilerOptions.rootDirs</code>：指定<strong>模块定位时需要查找的其他目录</strong>。该配置指定一个目录列表，此时这些目录在编译时被视为一个<strong>虚拟的根目录</strong>，也就是说 TypeScript 编译器会<strong>将这些目录中的文件当作在同一个目录中一样处理</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [<span class="string">&quot;src/zh&quot;</span>, <span class="string">&quot;src/de&quot;</span>, <span class="string">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="模块编译参数">模块编译参数</h4>
<ol>
<li>
<p><code>--traceResolution</code> 参数，表示编译时在命令行<strong>显示模块定位的每一步</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --traceResolution</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>--noResolve</code> 参数，表示<strong>模块定位时，只考虑在命令行传入的模块</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> A <span class="keyword">from</span> <span class="string">&quot;moduleA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> B <span class="keyword">from</span> <span class="string">&quot;moduleB&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc app.ts moduleA.ts --noResolve <span class="comment"># 报错，因为 moduleB 模块无法被定位</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TS-命名空间">TS - 命名空间</h2>
<h3 id="基本使用-2">基本使用</h3>
<ol>
<li>
<p>命名空间：<code>namespace</code> 是 TypeScript 在 ES6 之前用来组织相关代码（模块）的方式。TypeScript 允许使用 <code>namespace</code> 关键字创建一个容器，内部的所有变量和函数，都必须在这个容器里边使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">AssertUtils</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isString</span>(<span class="number">123</span>)); <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(AssertUtils.isNumber(&#x27;123&#x27;)); // ❌</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法 <code>namespace customName &#123; ... &#125;</code></p>
</li>
<li>
<p>使用说明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 给命名空间的内部成员加上 export 前缀，此时就可以在命名空间外部访问命名空间的内部成员。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> E = <span class="title class_">Math</span>.<span class="property">E</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Constants</span>.<span class="property">PI</span>, <span class="title class_">Constants</span>.<span class="property">E</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 命名空间的编译结果为一个 JavaScript 对象，此时凡命名空间中包含 export 前缀的内部成员，都成为了该对象的属性。</span></span><br><span class="line"><span class="comment">// 比如，Constants 的编译结果为 &#123; &quot;PI&quot;: 3.141592653589793, &quot;E&quot;: 2.718281828459045 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以在命名空间中使用 import 命令导入其他命名空间的成员，同时为该成员设置别名。也可以在命名空间外部使用 import 命令，同时设置别名。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">MathConstants</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="title class_">MathPI</span> = <span class="title class_">Constants</span>.<span class="property">PI</span>;</span><br><span class="line">    <span class="keyword">import</span> <span class="title class_">MathE</span> = <span class="title class_">Constants</span>.<span class="property">E</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;in MathConstants&quot;</span>, <span class="title class_">MathPI</span>, <span class="title class_">MathE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">PI</span> = <span class="title class_">Constants</span>.<span class="property">PI</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;import from Constants&#x27;</span>, <span class="variable constant_">PI</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 命名空间可以嵌套，但是如果要在外部使用被嵌套的命名空间，则要给其添加 export 前缀。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Jack</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">DetailInfo</span> &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jack\&#x27;s age is&#x27;</span>, <span class="title class_">Jack</span>.<span class="property">DetailInfo</span>.<span class="property">age</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 命名空间中不仅可以包含实义代码，还可以包括类型代码。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">N</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">MyType</span> = &#123;&#125;;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 命名空间与模块的作用一致，都用于将相关代码组织在一起，并对外输出接口。一个文件只能有一个模块（更建议使用），但可以有多个命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 可以使用三斜杠指令来引入存放在单个文件中的命名空间代码。</span></span><br><span class="line"><span class="comment">/// &lt;reference path = &quot;SomeFileName.ts&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 命名空间可以使用 export 命令导出，在其他文件中使用 import 命令导入。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    其他脚本中使用 import 语法如下导入命名空间 Shapes 的 Triangle 类</span></span><br><span class="line"><span class="comment">    - 方法一 </span></span><br><span class="line"><span class="comment">        import &#123; Shapes &#125; from &quot;./xxx.ts&quot;</span></span><br><span class="line"><span class="comment">        const t = new Shapes.Triangle();</span></span><br><span class="line"><span class="comment">    - 方法二</span></span><br><span class="line"><span class="comment">        import * as shapes from &#x27;./xxx.ts</span></span><br><span class="line"><span class="comment">        const t = new shapes.Shapes.Triangle(); </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="命名空间合并">命名空间合并</h3>
<ol>
<li>
<p>命名空间合并：与 <code>interface</code> 类似，多个同名的 <code>namespace</code> 会自动合并，这有利于对代码的扩展。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    namespace Animals &#123;</span></span><br><span class="line"><span class="comment">        export class Cat&#123;&#125;</span></span><br><span class="line"><span class="comment">        export class Dog&#123;&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 命名空间合并时，没有使用 export 前缀的成员不会被合并，其只能在各自的命名空间中使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 命名空间可以和同名函数、类、Enum 合并，但是函数、类、Enum 必须在命名空间之前声明，此时同名的命名空间相当于给这个函数、类、Enum 对象添加额外的属性。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((f <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">version</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">f</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// &#x27;1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 命名空间合并时，命名空间中使用 export 前缀的成员不能与 Enum 成员同名。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Left</span> = <span class="number">1</span>; <span class="comment">// ❌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TS-装饰器（标准语法）">TS - 装饰器（标准语法）</h2>
<h3 id="简要介绍">简要介绍</h3>
<ol>
<li>
<p>装饰器（Decorator）：一种<strong>特殊的函数</strong>，可以附加到类、方法、访问器、属性上，用于<strong>修改或扩展其行为</strong>。</p>
<ul>
<li>
<p>装饰器是<strong>函数</strong></p>
</li>
<li>
<p>装饰器通过 <code>&quot;@ + 函数&quot;</code> 或 <code>&quot;@ + 工厂函数(参数)&quot;</code> 的方式使用（工厂函数就是会返回一个函数的函数）</p>
</li>
<li>
<p>装饰器接受所修饰对象的一些相关值作为参数</p>
</li>
<li>
<p>装饰器要么不返回值，要么返回一个新对象来<strong>取代</strong>所修饰的对象</p>
</li>
<li>
<p>装饰器只能应用于类及其内部成员，不能用于独立的函数</p>
</li>
</ul>
</li>
<li>
<p>装饰器版本：TypeScript 支持两种装饰器语法：</p>
<ul>
<li>
<p><strong>传统语法</strong>：TypeScript 最初支持的语法。适用于 TypeScript 4.x 或更早版本，需要配置如下，</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// must</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// could 该编译选项用于控制是否产生一些装饰器的元数据，供某些模块（如 reflect-metadata）使用</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>标准语法</strong>：符合 ECMAScript 标准的语法。适用于 TypeScript 5.0 或更高版本，需要配置如下，</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>experimentalDecorators<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// must</span></span><br><span class="line">    <span class="attr">&quot;useDefineForClassFields&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// could 该编译选项用于控制是否使用 Object.defineProperty 来初始化类字段</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>装饰器的类型定义（函数）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: <span class="title class_">DecoratedValue</span>, <span class="comment">// 所装饰的对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123; // 上下文对象，包含有关所装饰对象的信息。可以使用 TypeScript 提供的原生接口 DecoratorContext 来描述</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="built_in">string</span>; // 所装饰对象的类型，可取值为 <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;method&#x27;</span>, <span class="string">&#x27;getter&#x27;</span>, <span class="string">&#x27;setter&#x27;</span>, <span class="string">&#x27;field&#x27;</span>, <span class="string">&#x27;accessor&#x27;</span>，即对应六种类型的装饰器</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="built_in">symbol</span>; // 所装饰对象的名字，如属性名、类名等</span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>; // 添加类的初始化逻辑的函数</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static</span>?: <span class="built_in">boolean</span>; // 所装饰对象是否为类的私有成员</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span>?: <span class="built_in">boolean</span>; // 所装饰对象是否为类的静态成员</span></span></span><br><span class="line"><span class="params"><span class="function">        access: &#123; // 某个值的 getter 和 setter 方法</span></span></span><br><span class="line"><span class="params"><span class="function">            get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数没有装饰器：因为函数存在提升机制，而类没有。可以使用高阶函数解决该问题。</p>
</li>
</ol>
<h3 id="装饰器语法">装饰器语法</h3>
<h4 id="类装饰器">类装饰器</h4>
<ol>
<li>
<p>类装饰器的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Function</span>&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: T, <span class="comment">// 被装饰的类的构造函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="string">&#x27;class&#x27;</span>; // 标识装饰器应用于类</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="literal">undefined</span>; // 类名，如果是匿名类则为 <span class="literal">undefined</span></span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>; // 添加类初始化逻辑的方法，通常在类的构造函数执行完毕后立即执行</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> T | <span class="built_in">void</span>; <span class="comment">// 可以返回一个新的类构造函数或不返回任何值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：类装饰器其实就是构造方法装饰器</p>
</blockquote>
</li>
<li>
<p>使用示例</p>
<ul>
<li>
<p>定义一个类装饰器，用于在所装饰的<strong>类的原型上添加一个 <code>greet</code> 方法</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserConstructor</span> &#123; <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展类的接口（避免 TypeScript 语法错误）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">UserConstructor</span>, <span class="attr">context</span>: <span class="title class_">ClassDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">        target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类装饰器</span></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>(); <span class="comment">// &#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个类装饰器，<strong>返回一个函数，用于替代所装饰的类的构造方法</strong>，并在其中实现了实例的计数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyClassConstructor</span> &#123; <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="title class_">MyClass</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展类的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">MyClassConstructor</span>, <span class="attr">context</span>: <span class="title class_">ClassDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instanceCount = <span class="number">0</span>; <span class="comment">// 实例统计变量，每创建一个实例对象，计数 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123; <span class="comment">// 要返回的构造函数</span></span><br><span class="line">        instanceCount++;</span><br><span class="line">        <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">target</span>(...args); <span class="comment">// 构造函数创建的实例对象</span></span><br><span class="line">        instance.<span class="property">count</span> = instanceCount; <span class="comment">// 实例属性 count，表示当前实例的编号</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line">    wrapper.<span class="property"><span class="keyword">prototype</span></span> = target.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 为了确保 wrapper 这个构造函数通过 instance of MyClass 运算符的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类装饰器</span></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">count</span>, instance2.<span class="property">count</span>); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个类装饰器，<strong>返回一个新类，用于替代所装饰的类</strong>，并在其中实现了实例的计数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NewClassConstructor</span> &#123; <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="title class_">NewClass</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展类的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NewClass</span> &#123; <span class="attr">count</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CountNewInstances</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">NewClassConstructor</span>, <span class="attr">context</span>: <span class="title class_">ClassDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> target &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">            <span class="variable language_">super</span>(...args);</span><br><span class="line">            instanceCount++;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类装饰器</span></span><br><span class="line"><span class="meta">@CountNewInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance3 = <span class="keyword">new</span> <span class="title class_">NewClass</span>();</span><br><span class="line"><span class="keyword">const</span> instance4 = <span class="keyword">new</span> <span class="title class_">NewClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance3.<span class="property">count</span>, instance4.<span class="property">count</span>); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance3 <span class="keyword">instanceof</span> <span class="title class_">NewClass</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个类装饰器，<strong>返回一个函数，用于替代所装饰类的构造方法</strong>，但是禁止该构造方法通过 <code>new</code> 命令新建类的实例</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补充：new.target 是 ES6 引入的元属性，用于在构造函数/方法中检测其是否通过 new 关键字调用，如果是 new.target 指向被调用的构造函数/被实例化的类，否则是 undefined</span></span><br><span class="line"><span class="comment">// 声明构造函数类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonConstructor</span> &#123; <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="title class_">Person</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fucntionCallable</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">PersonConstructor</span>, <span class="attr">context</span>: <span class="title class_">ClassDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;该函数不可以使用 new 命令调用&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">Person</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类装饰器</span></span><br><span class="line"><span class="meta">@fucntionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore 该注释告诉 TypeScript 编译器忽略下一行代码中的类型检查错误</span></span><br><span class="line"><span class="keyword">const</span> jack = <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jack.<span class="property">name</span>); <span class="comment">// &#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个<strong>装饰器工厂</strong>，其返回的装饰器将所装饰的类注册为自定义的 HTML 元素</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补充-1：customElements.define(name, constructor) 用于将一个 JavaScript 类（通常是继承自 HTMLElement 的类）与一个自定义的 HTML 标签关联起来，从而创建新的 HTML 元素，并定义这些元素的行为和属性。</span></span><br><span class="line"><span class="comment">// 参数解释</span></span><br><span class="line"><span class="comment">// - name 字符串，表示自定义元素的名称（必须包含连字符，以区分内置 HTML 元素）</span></span><br><span class="line"><span class="comment">// - constructor 一个 JavaScript 类，通常是继承自 HTMLElement 的类，定义了自定义元素的行为和属性</span></span><br><span class="line"><span class="comment">// 注意事项：constrctor 通常继承自 HTMLElement 的类，同时可以在其中定义生命周期回调（如 connectedCallback，用于在元素被插入到文档中时执行特定操作）</span></span><br><span class="line"><span class="comment">// 补充-2：类装饰器的 context.addInitializer(initializer) 用于注册一段初始化逻辑。接受一个函数作为参数，同时该函数在类的构造函数执行完成后立即执行。</span></span><br><span class="line"><span class="comment">// 注意事项：context.addInitializer(initializer) 可以多次调用，来注册多个初始化逻辑，这些逻辑会按照注册顺序依次执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明构造函数类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComponentConstructor</span> &#123; <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="title class_">MyComponent</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义装饰器工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customElement</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="title class_">MyComponentConstructor</span>, <span class="attr">context</span>: <span class="title class_">ClassDecoratorContext</span></span>) &#123; </span><br><span class="line">        context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            customElements.<span class="title function_">define</span>(name, target);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用装饰器工厂</span></span><br><span class="line"><span class="meta">@customElement</span>(<span class="string">&#x27;hello-world&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123; <span class="comment">// 当 &lt;hello-world&gt; 标签被插入到 DOM 时调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;h1&gt;Hello World&lt;/h1&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="方法装饰器">方法装饰器</h4>
<ol>
<li>
<p>方法装饰器的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Function</span>&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: T, <span class="comment">// 被装饰的类的方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="string">&#x27;method&#x27;</span>; // 标识装饰器应用于方法</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="built_in">symbol</span>; // 方法名</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static</span>: <span class="built_in">boolean</span>; // 所修饰的方法是否为静态方法</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span>: <span class="built_in">boolean</span>; // 所修饰的方法是否为私有方法</span></span></span><br><span class="line"><span class="params"><span class="function">        access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;; // 访问器对象，用于获取方法的值</span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>; // 添加方法初始化逻辑的方法，通常在类的构造函数执行期间执行，早于属性的初始化</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> T | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用示例</p>
<ul>
<li>
<p>定义一个方法装饰器，<strong>返回一个函数，用于替代所装饰的原始方法</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceMethod</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="comment">/* 知识回顾：TypeScript 允许函数增添一个名为 this 的参数，位于参数列表的首位，用于描述函数内部 this 的类型。</span></span><br><span class="line"><span class="comment">    在编译时，TypeScript 会对函数进行检查，如果函数参数列表的第一个参数名为 this，那么编译的结果将会删除这个参数。 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="title class_">Person</span></span>) &#123; <span class="comment">// 该方法会替换方法装饰器所装饰的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>?`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个方法装饰器，<strong>返回一个函数，用于替代所装饰的原始方法</strong>，在不改变原始方法功能的前提下，引入<strong>日志记录</strong>功能</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="title class_">Person</span>, ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123; <span class="comment">// 该方法会替换方法装饰器所装饰的方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LOG: Entering method <span class="subst">$&#123;<span class="built_in">String</span>(context.name)&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">const</span> result = target.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LOG: Existing method <span class="subst">$&#123;<span class="built_in">String</span>(context.name)&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span>) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用方法装饰器</span></span><br><span class="line">    <span class="meta">@replaceMethod</span></span><br><span class="line">    <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用方法装饰器</span></span><br><span class="line">    <span class="meta">@log</span></span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jack = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jack.<span class="title function_">hello</span>()); <span class="comment">// &#x27;How are you, jack?&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jack.<span class="title function_">greet</span>());</span><br><span class="line"><span class="comment">// &#x27;LOG: Entering method greet&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;LOG: Existing method greet&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;Hello, my name is jack&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个<strong>装饰器工厂</strong>，其返回的方法装饰器可以让所装饰的方法<strong>延迟执行</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params"><span class="attr">milliseconds</span>: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;method&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="title class_">Logger</span>, ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123; <span class="comment">// 该方法会替换方法装饰器所装饰的方法</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    target.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">                &#125;, milliseconds)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@delay</span>(<span class="number">1000</span>)</span><br><span class="line">    <span class="title function_">log</span>(<span class="params"><span class="attr">msg</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">logger.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个方法装饰器，通过 <code>addInitializer()</code> 添加<strong>初始化逻辑</strong>，将方法的 <code>this</code> 绑定到新创建的实例，从而确保方法在任何上下文中调用时，<code>this</code> 始终指向类的实例</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补充：context.addInitializer(initializer) 注册的初始化逻辑在构造函数执行期间执行</span></span><br><span class="line"><span class="comment">// 注意事项：与类装饰器类似，方法装饰器的 context.addInitializer(initializer) 也可以多次调用，用来注册多个初始化逻辑，并按照注册顺序依次执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bound</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> methodName = context.<span class="property">name</span> <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">private</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能给私有方法 <span class="subst">$&#123;methodName&#125;</span> 绑定 this`</span>);</span><br><span class="line"></span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[methodName] = target.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span>) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bound</span></span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"><span class="attr">food</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is eating <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Lucky&quot;</span>).<span class="property">eat</span>;</span><br><span class="line"><span class="title function_">eat</span>(<span class="string">&#x27;meat&#x27;</span>); <span class="comment">// &#x27;Lucky is eating meat&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个方法装饰器，通过 <code>addInitializer()</code> 添加<strong>初始化逻辑</strong>，将所修饰的方法名放入一个 <code>Set</code> 保存，并将这个 <code>Set</code> 作为实例属性 <code>collectedMethodKeys</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">collect</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span>.<span class="title function_">add</span>(context.<span class="property">name</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123; <span class="attr">collectedMethodKeys</span>: <span class="title class_">Set</span>&lt;<span class="built_in">string</span>&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@collect</span></span><br><span class="line">    <span class="title function_">wheel</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@collect</span></span><br><span class="line">    <span class="title function_">charge</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@collect</span></span><br><span class="line">    <span class="title function_">upkeep</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">collectedMethodKeys</span>); <span class="comment">// Set (3) &#123;&quot;wheel&quot;, &quot;charge&quot;, &quot;upkeep&quot;&#125; </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="属性装饰器">属性装饰器</h4>
<ol>
<li>
<p>属性装饰器的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="comment">// 该参数对于属性装饰器无用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="string">&#x27;field&#x27;</span>; // 标识装饰器应用于属性</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="built_in">symbol</span>; // 属性名</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static</span>: <span class="built_in">boolean</span>; // 所修饰的属性是否为静态属性</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span>: <span class="built_in">boolean</span>; // 所修饰的属性是否为私有属性</span></span></span><br><span class="line"><span class="params"><span class="function">        access: &#123; get: () =&gt; <span class="built_in">unknown</span>, set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;; // 访问器对象，用于获取或设置属性的值</span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>; // 添加属性初始化逻辑的方法</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params"><span class="attr">initialValue</span>: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>; <span class="comment">// 属性装饰器可以返回一个函数（会自动执行），参数为所装饰属性的初始值，返回值为该属性的最终值。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用示例</p>
<ul>
<li>
<p>定义一个属性装饰器，返回一个函数，用于<strong>计算该属性的最终值</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twice</span>(<span class="params"><span class="attr">_</span>: <span class="literal">undefined</span>, <span class="attr">context</span>: <span class="title class_">ClassFieldDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">initialValue</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> initialValue * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="meta">@twice</span></span><br><span class="line">    pi = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">pi</span>); <span class="comment">// 6.28</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个属性装饰器，将 <code>context.access</code> 的 <code>getter</code> 和 <code>setter</code> 绑定到全局变量，以便通过该变量访问和修改装饰属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> access;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exposeAccess</span>(<span class="params"><span class="attr">_</span>: <span class="literal">undefined</span>, <span class="attr">context</span>: <span class="title class_">ClassFieldDecoratorContext</span></span>) &#123;</span><br><span class="line">    access = context.<span class="property">access</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@exposeAccess</span></span><br><span class="line">    name = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">name</span>); <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(access!.<span class="title function_">get</span>(c)); <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line">access!.<span class="title function_">set</span>(c, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">name</span>); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    get: function (obj) &#123; return obj.name; &#125;</span></span><br><span class="line"><span class="comment">    set: function (obj, value) &#123; obj.name = value; &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="getter、setter-装饰器">getter、setter 装饰器</h4>
<ol>
<li>
<p><code>getter</code> 装饰器的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: <span class="title class_">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="string">&#x27;getter&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// getter 装饰器可以返回一个函数，取代原来的 getter（取值器）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>setter</code> 装饰器的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: <span class="title class_">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="string">&#x27;setter&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// setter 装饰器可以返回一个函数，取代原来的 setter（存值器）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用示例：定义一个 <code>getter</code> 装饰器，返回一个函数，用于取代原来的 <code>getter</code>，同时<strong>实现属性的懒加载</strong>，即只在首次访问时进行计算，并将结果缓存。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这里涉及知识点 - 属性覆盖，即 Object.defineProperty 在实例上定义了一个新的直接属性，这个属性遮盖了原有的 getter 方法。JavaScript 引擎在查找属性时，会先在对象实例上查找直接属性，然后才会查找原型链上的属性和方法。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazyLoad</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassGetterDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="title class_">BigNumbers</span>, ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;lazyloading...&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> result = target.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, context.<span class="property">name</span>, &#123;</span><br><span class="line">            <span class="attr">value</span>: result,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigNumbers</span> &#123;</span><br><span class="line">    <span class="meta">@lazyLoad</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;computing...&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;big data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">BigNumbers</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;value&#x27;</span>),<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> instance); <span class="comment">// false true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;value&#x27;</span>),<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> instance); <span class="comment">// true true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">value</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    false true // value 在原型链上</span></span><br><span class="line"><span class="comment">    lazyloading...</span></span><br><span class="line"><span class="comment">    computing...</span></span><br><span class="line"><span class="comment">    big data</span></span><br><span class="line"><span class="comment">    true true // value 在实例上</span></span><br><span class="line"><span class="comment">    big data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    补充</span></span><br><span class="line"><span class="comment">    - obj.hasOwnProperty(prop): boolean 检查属性 prop 是否是对象 obj 的实例属性</span></span><br><span class="line"><span class="comment">    - prop in obj: boolean 检查属性 prop 是否是对象 obj 的属性（实例属性和原型链上的属性）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="accessor-装饰器">accessor 装饰器</h4>
<ol>
<li>
<p><code>accessor</code> 属性修饰符：使用 <code>accessor</code> 修饰一个属性，等同于<strong>为该属性自动生成一对取值器和存值器</strong>。</p>
<ul>
<li>
<p><code>accessor</code> 修饰符生成的取值器和存值器作用于<strong>私有属性</strong>，这里的私有属性和公开属性可见下述 <code>#x</code> 和 <code>x</code></p>
</li>
<li>
<p><code>accessor</code> 修饰符可以修饰<strong>实例属性</strong>、<strong>静态属性</strong>、<strong>私有属性</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    accessor x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于（上述代码可以看作是下述代码的语法糖）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    #x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">x</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">x</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#x = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>accessor</code> 装饰器的类型定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassAutoAccessorDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        get: () =&gt; <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">context</span>: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        kind: <span class="string">&quot;accessor&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        access: &#123; get(): <span class="built_in">unknown</span>, set(value: <span class="built_in">unknown</span>): <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">    get?: <span class="function">() =&gt;</span> <span class="built_in">unknown</span>;</span><br><span class="line">    set?: <span class="function">(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    init?: <span class="function">(<span class="params"><span class="attr">initialValue</span>: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span>;</span><br><span class="line">&#125; | <span class="built_in">void</span>; <span class="comment">// accessor 装饰器可以返回一个对象，用于替代原有的 get() 和 set() 方法。此外，它还可以包含一个 init() 方法，该方法接受属性在类实例化时的初始值作为参数，并返回该属性的最终初始值。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用示例：定义一个 <code>accessor</code> 装饰器，为属性的存值器和取值器添加日志输出功能</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">ClassAccessorDecoratorTarget</span>&lt;<span class="title class_">Demo</span>, <span class="built_in">number</span>&gt;, <span class="attr">context</span>: <span class="title class_">ClassAccessorDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kind === <span class="string">&#x27;accessor&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; get, set &#125; = target;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;name <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> get.<span class="title function_">call</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span>(<span class="params"><span class="attr">val</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;name <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span> to <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> set.<span class="title function_">call</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>, val);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">init</span>(<span class="params"><span class="attr">initialValue</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`initializing <span class="subst">$&#123;name <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span> with <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> initialValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="meta">@log</span> accessor <span class="attr">value</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="number">124</span>);</span><br><span class="line">d.<span class="property">value</span> = <span class="number">125</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">value</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &quot;initializing value with 0&quot; </span></span><br><span class="line"><span class="comment">    &quot;setting value to 124&quot; </span></span><br><span class="line"><span class="comment">    &quot;setting value to 125&quot; </span></span><br><span class="line"><span class="comment">    &quot;getting value&quot; </span></span><br><span class="line"><span class="comment">    125 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="装饰器的执行顺序">装饰器的执行顺序</h3>
<ol>
<li>
<p>装饰器的执行流程：评估阶段 evaluation + 应用阶段 application</p>
<ul>
<li>
<p>评估阶段：计算 <code>@</code> 符号后面的表达式的值，得到一个函数（<strong>按顺序评估</strong>）</p>
</li>
<li>
<p>应用阶段：将评估装饰器后得到的函数，应用于所装饰对象（<strong>按优先级应用</strong>）</p>
</li>
<li>
<p>注意事项</p>
<ol>
<li>如果属性名或方法名是计算值，则它们在对应的装饰器评估之后，再进行计算。</li>
<li>应用阶段的优先级为：<strong>静态方法装饰器 -&gt; 原型方法装饰器 -&gt; 静态属性装饰器 -&gt; 实例属性装饰器 -&gt; 类装饰器</strong></li>
<li>实例属性值在类初始化阶段并不执行，直到类实例化时才执行；静态属性值在类初始化最后执行。</li>
</ol>
  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"><span class="attr">str</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`评估 @d(): <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="attr">value</span>: <span class="built_in">any</span>, <span class="attr">context</span>: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`应用 @d(): <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"><span class="attr">str</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@d</span>(<span class="string">&#x27;类装饰器&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;静态属性装饰器&#x27;</span>)</span><br><span class="line">    <span class="keyword">static</span> staticField = <span class="title function_">log</span>(<span class="string">&#x27;静态属性值&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">    [<span class="title function_">log</span>(<span class="string">&#x27;计算方法名&#x27;</span>)]() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;实例属性&#x27;</span>)</span><br><span class="line">    instanceField = <span class="title function_">log</span>(<span class="string">&#x27;实例属性值&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;静态方法装饰器&#x27;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    评估 @d(): 类装饰器</span></span><br><span class="line"><span class="comment">    评估 @d(): 静态属性装饰器</span></span><br><span class="line"><span class="comment">    评估 @d(): 原型方法</span></span><br><span class="line"><span class="comment">    计算方法名</span></span><br><span class="line"><span class="comment">    评估 @d(): 实例属性</span></span><br><span class="line"><span class="comment">    评估 @d(): 静态方法装饰器</span></span><br><span class="line"><span class="comment">    应用 @d(): 静态方法装饰器</span></span><br><span class="line"><span class="comment">    应用 @d(): 原型方法</span></span><br><span class="line"><span class="comment">    应用 @d(): 静态属性装饰器</span></span><br><span class="line"><span class="comment">    应用 @d(): 实例属性</span></span><br><span class="line"><span class="comment">    应用 @d(): 类装饰器</span></span><br><span class="line"><span class="comment">    静态属性值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明：<strong>如果一个方法或属性有多个装饰器，则内层的装饰器先执行，外层的装饰器后执行</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logger</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logger 装饰器执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"><span class="attr">target</span>: <span class="title class_">Function</span>, <span class="attr">context</span>: <span class="title class_">ClassMethodDecoratorContext</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bound 装饰器执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@bound</span></span><br><span class="line">    <span class="meta">@logger</span></span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    logger 装饰器执行</span></span><br><span class="line"><span class="comment">    bound 装饰器执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TS-装饰器（传统语法）">TS - 装饰器（传统语法）</h2>
<h3 id="装饰器语法-2">装饰器语法</h3>
<h4 id="类装饰器-2">类装饰器</h4>
<ol>
<li>
<p>解释：类装饰器应用于类（class），但实际上是<strong>应用于类的构造方法</strong>。</p>
<ul>
<li>返回值：如果有返回值，<strong>返回的构造方法将替代被装饰的类的构造方法</strong>。否则，被装饰的类将保持装饰器处理后的状态。</li>
<li>执行时机：类装饰器在代码加载阶段执行，并且只会执行一次。由于装饰器在编译阶段对类的行为进行修改，因此本质上，装饰器是<strong>编译时执行的函数</strong>。</li>
</ul>
</li>
<li>
<p>类型定义</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = &lt;<span class="title class_">TFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">target</span>: <span class="title class_">TFunction</span> <span class="comment">// 构造方法</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TFunction</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加精确的表述，表示类装饰器实际上应用于类的构造方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Constructor</span> &#123; <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = &lt;<span class="title class_">TFunction</span> <span class="keyword">extends</span> <span class="title class_">Constructor</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">target</span>: <span class="title class_">TFunction</span> <span class="comment">// 构造方法</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TFunction</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="方法装饰器-2">方法装饰器</h4>
<ol>
<li>
<p>解释：方法装饰器用来装饰类的方法（method）。</p>
<ul>
<li>返回值：如果有返回值，<strong>返回的是修改后的该方法的描述对象，用于覆盖该方法的原始描述对象</strong>。否则，被装饰后的方法将保持装饰器处理后的状态。</li>
</ul>
</li>
<li>
<p>类型定义</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MethodDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">target</span>: <span class="title class_">Object</span>, <span class="comment">// 类的构造函数 for 静态方法；类的原型 for 实例方法。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">propertyKey</span>: <span class="built_in">string</span>|<span class="built_in">symbol</span>, <span class="comment">// 所装饰方法的方法名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">descriptor</span>: <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; <span class="comment">// 所装饰方法的描述对象（value 属性是被装饰的方法）</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="属性装饰器-2">属性装饰器</h4>
<ol>
<li>
<p>解释：属性装饰器用来装饰属性（property），<strong>无返回值</strong>。</p>
</li>
<li>
<p>类型定义</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropertyDecorator</span> =</span><br><span class="line">  <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">target</span>: <span class="title class_">Object</span>, <span class="comment">// 类的构造函数 for 静态属性；类的原型 for 实例属性。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="attr">propertyKey</span>: <span class="built_in">string</span>|<span class="built_in">symbol</span> <span class="comment">// 所装饰属性的属性名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="存取器装饰器">存取器装饰器</h4>
<ol>
<li>
<p>解释：存取器装饰器用来装饰类的存取器（accessor）。</p>
<blockquote>
<p>存取器指的是某个属性的<strong>取值器</strong>（getter）和<strong>存值器</strong>（setter）。</p>
</blockquote>
<ul>
<li>返回值：如果有返回值，<strong>返回的是修改后的该存取器的描述对象，用于覆盖该存取器的原始描述对象</strong>。否则，被装饰后的存取器将保持装饰器处理后的状态。</li>
<li>使用限制：在 TypeScript 中，<strong>不允许对同一个属性的存取器（getter 和 setter）使用同一个装饰器</strong>。也就是说，装饰器只能应用于这两个存取器中的一个，并且必须应用于顺序上靠前的那个，否则会导致错误。这是因为装饰器能够从属性描述对象中同时获取取值器和存值器，因此只需要调用一次即可完成装饰。</li>
</ul>
</li>
<li>
<p>类型定义</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AccessorDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">target</span>: <span class="title class_">Object</span>, <span class="comment">// 类的构造函数 for 静态属性的存取器；类的原型 for 实例属性的存取器</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">propertyKey</span>: <span class="built_in">string</span>|<span class="built_in">symbol</span>, <span class="comment">// 存取器的属性名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">descriptor</span>: <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; <span class="comment">// 存取器的属性描述对象（get、set 属性是被装饰的存取器方法）</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="参数装饰器">参数装饰器</h4>
<ol>
<li>
<p>解释：参数装饰器用来装饰构造方法或者其他方法的参数（parameter），<strong>无返回值</strong>。跟其他装饰器不同，参数装饰器主要用于输出信息，<strong>没有办法修改类的行为</strong>。</p>
</li>
<li>
<p>类型定义</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParameterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">target</span>: <span class="title class_">Object</span>, <span class="comment">// 类的构造函数 for 静态方法；类的原型 for 实例方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">propertyKey</span>: <span class="built_in">string</span>|<span class="built_in">symbol</span>, <span class="comment">// 所装饰的方法的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="attr">parameterIndex</span>: <span class="built_in">number</span> <span class="comment">// 当前参数在方法的参数序列的位置（从 0 开始）</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="装饰器的执行顺序-2">装饰器的执行顺序</h3>
<p>装饰器执行顺序：<strong>实例相关的装饰器 -&gt; 静态相关的装饰器 -&gt; 构造方法的参数装饰器 -&gt; 类装饰器</strong>。</p>
<blockquote>
<p>装饰器只会在代码解析时执行一次。</p>
</blockquote>
<ul>
<li><strong>同一优先级的装饰器的执行顺序</strong>：按照装饰器在<strong>代码中出现的顺序</strong>。但是，<strong>对于同一个方法，参数装饰器 -&gt; 方法装饰器</strong>。</li>
<li><strong>同一个方法或属性的多个装饰器</strong>：顺序加载，逆序执行。</li>
<li><strong>同一个方法的多个参数的参数装饰器</strong>（每个参数有一个参数装饰器）：顺序加载，逆序执行。</li>
</ul>
<h2 id="TS-declare-关键字">TS - declare 关键字</h2>
<ol>
<li>
<p>解释：<code>declare</code> 关键字用于<strong>告诉编译器某个类型已经存在，并可以在当前文件中使用</strong>。它只能用来<strong>描述已经存在的变量和数据结构</strong>，而不能用于声明新的变量和数据结构。<code>declare</code> 可以描述的类型包括：变量、<code>type</code>、<code>interface</code>、<code>class</code>、<code>enum</code>、<code>function</code>、<code>module</code> 和 <code>namespace</code>。</p>
</li>
<li>
<p><code>declare variable</code>：给出外部变量的类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> x; <span class="comment">// 此时 x 的类型为 any</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="variable language_">document</span>; <span class="comment">// 告诉编译器 document 的类型是外部定义的，如果编译器没有在 lib.d.ts 内置文件中找到类型信息，则假定 document 的类型为 any</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>declare function</code>：给出外部函数的类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">name</span>:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>declare class</code>：给出外部 <code>class</code> 类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">arg</span>: <span class="built_in">number</span></span>); <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">s0</span>(): <span class="built_in">string</span>; <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">s1</span>: <span class="built_in">string</span>; <span class="comment">// 静态属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">a</span>: <span class="built_in">number</span>; <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="title function_">m</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>; <span class="comment">// 实例方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">c</span>(): <span class="built_in">number</span>; <span class="comment">// 存取器</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">c</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">number</span></span>);</span><br><span class="line">  </span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 索引签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>declare namespace</code>：给出外部 <code>namespace</code> 类型描述。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">// export 关键字可加可不加</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>; <span class="comment">// export 关键字可加可不加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>declare module</code></p>
<blockquote>
<p><code>declare module</code> 描述的模块名可以使用通配符 <code>*</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;my-plugin-*&#x27;</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>给出外部 <code>module</code> 类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">// export 关键字可加可不加</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>; <span class="comment">// export 关键字可加可不加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对导入的 <code>module</code> 进行类型扩展。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;./module&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> A &#123; <span class="comment">// 这里利用了同名 interface 的类型声明自动合并的特性，从而实现类型扩展</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>declare module NAME</code> 语法限制</p>
<ul>
<li>模块名 <code>NAME</code>，需要跟 <code>import</code> 和 <code>export</code> 的模块名规则一样，且必须跟当前文件加载该模块的语句写法保持一致。</li>
<li>不能创建新的顶层类型，只允许对模块中已经存在的类型进行扩展。</li>
<li>不能对默认的 <code>default</code> 接口进行扩展，只能对 <code>export</code> 命令输出的<strong>命名接口</strong>进行扩充。</li>
</ul>
</blockquote>
</li>
<li>
<p>让没有提供接口类型的第三方模块通过编译，所有从该模块输入的接口都将为 <code>any</code> 类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;模块名&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用于类型声明文件或为模块指定加载路径：为整个项目定义一个大的 <code>.d.ts</code> 文件，在这个文件里面使用 <code>declare module</code> 定义每个<strong>模块脚本的类型</strong>或为其指定<strong>加载路径</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;url&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">urlStr</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    parseQueryString?,</span></span><br><span class="line"><span class="params">    slashesDenoteHost?</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Url</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;path&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">normalize</span>(<span class="params"><span class="attr">p</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">...<span class="attr">paths</span>: <span class="built_in">any</span>[]</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">sep</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;lodash&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;../../dependencies/lodash&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">from</span> <span class="string">&quot;../../dependencies/lodash&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自己的脚本可以使用三斜杠命令，加载该类型声明文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;xxx.d.ts&quot;/&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>declare global</code>：为 JavaScript 引擎的原生对象添加属性和方法。</p>
<blockquote>
<p><code>declare global</code> 只能扩充现有对象的类型描述，不能增加新的顶层类型。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;; <span class="comment">// 强制编译器将这个脚本当作模块处理。因为 declare global 必须用在模块里面。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">toSmallString</span>(): <span class="built_in">string</span>; <span class="comment">// 为 JavaScript 原生的String对象添加了 toSmallString() 方法。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toSmallString</span> = ():<span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>declare enum</code>：给出 <code>enum</code> 类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法 1</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E1</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 2</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E2</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 3</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E3</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 4</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E4</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TS-d-ts-类型声明文件">TS - d.ts 类型声明文件</h2>
<h3 id="简要概述-3">简要概述</h3>
<ol>
<li>
<p>类型声明文件（declaration file）：是用于描述当前模块的外部接口所有类型的文件。这类文件仅包含类型定义，而不包括具体的代码实现，通常命名为 <code>[模块名].d.ts</code>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型的具名导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params"><span class="attr">arr</span>: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型的默认导出</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pi; <span class="comment">// 写法 1</span></span><br><span class="line"><span class="keyword">export</span> = pi; <span class="comment">// 写法 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以在 <code>tsconfig.json</code> 文件的 <code>files</code> 配置中包括类型声明文件。这样，在编译器打包项目时，类型声明文件会被自动加入编译，无需在每个脚本中单独加载类型声明文件。</p>
</blockquote>
<ul>
<li>类型声明文件中，<code>interface</code> 类型可以不使用 <code>declare</code> 关键字，因为其本身就是完全的类型代码。</li>
<li>类型声明文件中，顶层类型可以使用，也可以不使用 <code>export</code> 命令。除非有显示使用 <code>export</code> 输出的类型的场景。</li>
</ul>
</li>
<li>
<p>模块发布：如果当前模块包含自己的类型声明文件，可以在 <code>package.json</code> 文件里面添加一个 <code>types</code> 字段或 <code>typings</code> 字段，指明类型声明文件的位置。但是，如果类型声明文件名为 <code>index.d.ts</code>，且在项目的根目录中，那就不需要在 <code>package.json</code> 里面注明了。</p>
</li>
<li>
<p>类型声明文件来源</p>
<ul>
<li>
<p>TypeScript 编译器<strong>自动</strong>生成：设置 <code>tsconfig.json</code> 文件的 <code>compilerOptions.declaration</code> 为 <code>true</code>，此时编译器会在编译时自动生成单独的类型声明文件。</p>
</li>
<li>
<p>TypeScript <strong>内置</strong>类型文件：安装 TypeScript 语言时，同时安装的一些内置的类型声明文件，如 lib.d.ts、lib.dom.d.ts、lib.es2015.d.ts、…、lib.es2020.d.ts、lib.es5.d.ts、lib.es6.d.ts 等。</p>
<ul>
<li>内置类型文件统一命名为 <code>lib.[description].d.ts</code>，<code>description</code> 部分描述了文件内容。</li>
<li>编译器会自动根据 <code>tsconfig.json</code> 文件的 <code>compilerOptions.target</code> 的值，<strong>加载对应的内置声明文件</strong>。但是，可以使用编译选项 <code>compilerOptions.lib</code>，<strong>指定加载哪些内置声明文件</strong>。也可以使用编译选项 <code>compilerOptions.noLib</code> <strong>禁止加载任何内置声明文件</strong>。</li>
</ul>
</li>
<li>
<p><strong>外部</strong>模块的类型声明文件，需要自己安装</p>
<ul>
<li>
<p>外部模块<strong>自带</strong>类型声明文件：一般来说，如果这个库的源码包含了 <code>[vendor].d.ts</code> 文件，那么就自带了类型声明文件。其中的 <code>vendor</code> 表示这个库的名字。</p>
</li>
<li>
<p>外部模块不自带，但存在<strong>社区</strong>提供的类型声明文件：TypeScript 社区主要使用 DefinitelyTyped 仓库，各种类型声明文件都会提交到那里。这些声明文件都会作为一个单独的库，发布到 <strong>npm 的 <code>@types</code> 名称空间</strong>之下。如 jquery 库的类型声明文件的安装命令为，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述命令将 <code>@types/jquery</code> 这个库安装到项目的 <code>node_modules/@types/jquery</code> 目录，里面的 <code>index.d.ts</code> 文件就是 jQuery 的类型声明文件。如果类型声明文件不是 <code>index.d.ts</code>，那么就需要在 <code>package.json</code> 的 <code>types</code> 或 <code>typings</code> 字段，指定类型声明文件的文件名。</p>
</blockquote>
<ul>
<li>TypeScript 会自动加载 <code>node_modules/@types</code> 目录下的模块，也可以通过 <code>tsconfig.json</code> 文件的 <code>compilerOptions.typeRoots</code> 自定义类型模块的加载路径。</li>
<li>TypeScript 会自动加载 <code>typeRoots</code> 指定的目录里的所有模块，可以通过编译选项 <code>types</code> 指定加载 <code>typeRoots</code> 目录的哪些模块。</li>
</ul>
</li>
<li>
<p>找不到类型声明文件，需要自己写</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="三斜杠命令">三斜杠命令</h3>
<p>解释：三斜杠命令（<code>///</code>）是一个 TypeScript 编译器命令，用来指定编译器行为。</p>
<ul>
<li>
<p>三斜杠命令可以<strong>拆分类型声明文件</strong>，也可以用于普通脚本<strong>加载类型声明文件</strong>。</p>
</li>
<li>
<p>三斜杠命令<strong>只能用在文件的头部</strong>，如果用在其他地方，会被当作普通的注释。</p>
</li>
<li>
<p>三斜线命令<strong>之前只允许使用单行注释、多行注释和其他三斜线命令</strong>，否则三斜杠命令也会被当作普通的注释。</p>
</li>
<li>
<p>可以通过 <code>tsconfig.json</code> 的 <code>compilerOptions.noResolve</code> <strong>忽略三斜杠指令</strong>。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>/// &lt;reference path=&quot;&quot; /&gt;</code></td>
<td style="text-align:center">告诉编译器在编译时需要包括的文件，常用来声明当前脚本依赖的类型文件。</td>
<td style="text-align:center"><code>path</code> 使用相对路径时，基于当前脚本的路径进行计算。<code>path</code> 不允许指向当前文件。</td>
</tr>
<tr>
<td style="text-align:center"><code>/// &lt;reference types=&quot;&quot; /&gt;</code></td>
<td style="text-align:center">告诉编译器当前脚本依赖某个 DefinitelyTyped 类型库，通常安装在 <code>node_modules/@types</code> 目录。</td>
<td style="text-align:center"><code>types</code> 参数的值是类型库的名称，也就是安装到 <code>node_modules/@types</code> 目录中的子目录的名字。</td>
</tr>
<tr>
<td style="text-align:center"><code>/// &lt;reference lib=&quot;&quot; /&gt;</code></td>
<td style="text-align:center">允许脚本文件显式包含内置 lib 库，等同于在 <code>tsconfig.json</code> 文件里面使用 <code>lib</code> 属性指定 lib 库。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="TS-类型运算符">TS - 类型运算符</h2>
<h3 id="keyof">keyof</h3>
<ol>
<li>
<p>解释：keyof 是一个<strong>单目运算符</strong>，接受一个<strong>对象类型</strong>作为参数，返回该对象的<strong>所有键名组成的联合类型</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>; <span class="comment">// &#x27;foo&#x27;|&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用途</p>
<ul>
<li>
<p>当一个函数接收对象、对象的属性作为参数，则可以使用 keyof <strong>确保参数的类型之间满足给定约束</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> prop&lt;T, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">    <span class="attr">obj</span>: T, <span class="attr">key</span>: K</span><br><span class="line">): T[K] &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>属性映射</strong>，将一个对象类型基于其所有属性逐一映射得到一个新的对象类型，可以修改属性的<strong>类型、只读性、可选性</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改属性类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewMyObjProp1</span>&lt;T&gt; = &#123;</span><br><span class="line">    [key <span class="keyword">in</span> keyof T]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewMyObj1</span> = <span class="title class_">NewMyObjProp1</span>&lt;<span class="title class_">MyObj</span>&gt;; <span class="comment">// &#123;foo: boolean, bar: boolean&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性只读性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewMyObjProp2</span>&lt;T&gt; = &#123;</span><br><span class="line">    +<span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof T]: T[key]; <span class="comment">// 可以通过 -readonly 去除属性的只读特性，也可以通过 +readonly 添加属性的只读特性(+readonly 可以简写为 readonly)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewMyObj2</span> = <span class="title class_">NewMyObjProp2</span>&lt;<span class="title class_">MyObj</span>&gt;; <span class="comment">// &#123;readonly foo: number, readonly bar: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性可选性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewMyObjProp3</span>&lt;T&gt; = &#123;</span><br><span class="line">    [key <span class="keyword">in</span> keyof T]+?: T[key]; <span class="comment">// 可以通过 -? 去除属性的可选设置，也可以通过 +? 添加属性的可选设置(+? 可以简写为 ?)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewMyObj3</span> = <span class="title class_">NewMyObjProp3</span>&lt;<span class="title class_">MyObj</span>&gt;; <span class="comment">// &#123;foo?: number | undefined, bar?: string | undefined&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用说明</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是 string|number|symbol。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfAny</span> = keyof <span class="built_in">any</span>; <span class="comment">// string|number|symbol </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有自定义键名的类型使用 keyof 运算符，返回 never 类型，表示不可能有这样类型的键名。(object 类型没有自身的属性，也就没有键名)</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfObject</span> = keyof <span class="built_in">object</span>; <span class="comment">// never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某些场合中，只需要使用 keyof 返回的类型中的一种类型时，可以采用交叉类型的写法。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyString</span>&lt;customObj <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; = <span class="built_in">string</span> &amp; keyof customObj; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象属性名采用索引形式，keyof 会返回属性名的索引类型。</span></span><br><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> T2 &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfT1</span> = keyof <span class="variable constant_">T1</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfT2</span> = keyof <span class="variable constant_">T2</span>; <span class="comment">// string | number（因为数值属性名会自动转为字符串，所以 JavaScript 属性名为字符串时，包含了属性名为数值的情况）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 keyof 运算符用于数组或元组类型，得到的结果可能出人意料。keyof 会返回数组的所有键名，包括数字键名和继承的键名。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfArr</span> = keyof [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// number | &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;length&quot; | &quot;pop&quot; | &quot;push&quot; | ···</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于联合类型，keyof 返回成员共有的键名；对于交叉类型，keyof 返回所有键名。</span></span><br><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfOr</span> = <span class="title function_">keyof</span> (A | B); <span class="comment">// &quot;z&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeysOfAnd</span> = <span class="title function_">keyof</span> (A &amp; B); <span class="comment">// &quot;a&quot; | &quot;z&quot; | &quot;b&quot;（等价于 keyof A | keyof B）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过对象类型及其 keyof 的运算结果取得该对象的所有键值组成的联合类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span> = <span class="title class_">MyObj</span>[<span class="title class_">Keys</span>]; <span class="comment">// number|string</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="in">in</h3>
<p>解释</p>
<ul>
<li>
<p>JavaScript 语言中，in 运算符用来确定对象是否包含某个属性名。</p>
</li>
<li>
<p>TypeScript 语言中，in 运算符用来<strong>取出（遍历）联合类型的每一个成员类型</strong>。</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InT</span> = &#123;</span><br><span class="line">    [key <span class="keyword">in</span> U]: <span class="built_in">number</span></span><br><span class="line">&#125; <span class="comment">// &#123;a: number, b: number, c: number&#125;（类似 keyof 的属性映射用法）</span></span><br></pre></td></tr></table></figure>
<h3 id="">[]</h3>
<ol>
<li>
<p>解释：[] 运算符用于<strong>取出对象的键值类型</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="title class_">MyObj</span>[<span class="string">&#x27;foo&#x27;</span>] <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方括号的参数如果是联合类型，那么返回的也是联合类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span> = <span class="title class_">MyObj</span>[keyof <span class="title class_">MyObj</span>]; <span class="comment">// number | string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果访问不存在的属性，会报错。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnexistedT</span> = <span class="title class_">MyObj</span>[<span class="string">&#x27;c&#x27;</span>]; <span class="comment">// ❌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方括号运算符的参数也可以是属性名的索引类型。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjValueT</span> = <span class="title class_">Obj</span>[<span class="built_in">string</span>]; <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组或元组类型使用方括号运算符时，需要以 number 作为方括号的参数。</span></span><br><span class="line"><span class="keyword">const</span> myArr = [<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyArrValueT</span> = (<span class="keyword">typeof</span> myArr)[<span class="built_in">number</span>]; <span class="comment">// string | number（由于 typeof 优先级高于 []，因此也可以简写为 typeof myArr[number]）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="extends…">extends…?</h3>
<ol>
<li>
<p>解释：条件运算符 <code>extends...?:</code> 可以<strong>根据当前类型是否符合某种条件，返回不同的类型</strong>。</p>
</li>
<li>
<p>语法：<code>T extends U ? X : Y</code>（这里的 extends 用来判断，类型 T 是否可以赋值给类型 U，即 T 是否为 U 的子类型，这里的 T 和 U 可以是任意类型）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123; <span class="attr">category</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说，调换 extends 两侧类型，会返回相反的结果。</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对泛型使用 extends 条件运算时，如果泛型参数是联合类型，那么条件运算时会展开这个类型参数，然后对每一部分分别进行条件运算，返回的结果也是一个联合类型。</span></span><br><span class="line"><span class="keyword">type</span> toArray1&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? T[] : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = toArray1&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// string[] | number[]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    计算流程: toArray&lt;string | number&gt; </span></span><br><span class="line"><span class="comment">            = toArray&lt;string&gt; | toArray&lt;number&gt; </span></span><br><span class="line"><span class="comment">            = (string extends any ? string[] : never) | (number extends any ? number[] : never)</span></span><br><span class="line"><span class="comment">            = string[] | number[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对泛型使用 extends 条件运算时，如果不希望联合类型被条件运算符展开，可以把 extends 两侧的操作数都放在方括号里面。</span></span><br><span class="line"><span class="keyword">type</span> toArray2&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? T[] : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = toArray2&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// (string | number)[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件运算符还可以嵌套使用。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LiteralTypeName</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">bigint</span> ? <span class="string">&quot;bigint&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="number">12131</span>&gt;; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="infer">infer</h3>
<ol>
<li>
<p>解释：infer 关键字用来<strong>定义泛型里面推断出来的类型参数</strong>，而不是外部传入的类型参数。它通常跟条件运算符一起使用，用在 extends 关键字后面的父类型之中。</p>
</li>
<li>
<p>使用示例</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 1：泛型参数是数组，则返回其成员类型，否则返回其本身。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : T; <span class="comment">// 这里的 Item 是 TypeScipt 自行推断出来的，不用显式传入</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>[]&gt;; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2：泛型参数是函数，则返回返回值为 Promise 的函数类型，否则返回其本身。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnPromise</span>&lt;T&gt; =</span><br><span class="line">    T <span class="title function_">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R ?</span><br><span class="line">    <span class="function">(<span class="params">...<span class="attr">args</span>: A</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;R&gt;</span><br><span class="line">    : T;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">ReturnPromise</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// () =&gt; Promise&lt;void&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">ReturnPromise</span>&lt;<span class="built_in">number</span>[]&gt;; <span class="comment">// number[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3：提取对象的值类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> &#123;</span><br><span class="line">        <span class="attr">a</span>: infer M,</span><br><span class="line">        <span class="attr">b</span>: infer N</span><br><span class="line">    &#125; ? [M, N] : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Values</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">string</span> &#125;&gt;; <span class="comment">// [number, string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">Values</span>&lt;<span class="built_in">number</span>[]&gt;; <span class="comment">// never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 4：正则匹配提取类型参数。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetFooAfter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="string">`foo-<span class="subst">$&#123;infer rest&#125;</span>`</span></span><br><span class="line">    ? rest</span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T7</span> = <span class="title class_">GetFooAfter</span>&lt;<span class="string">&#x27;foo-bar&#x27;</span>&gt;; <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T8</span> = <span class="title class_">GetFooAfter</span>&lt;<span class="string">&#x27;fooooooo&#x27;</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="is">is</h3>
<ol>
<li>
<p>解释：函数返回布尔值的时候，可以使用 is 运算符，<strong>限定布尔返回值与参数类型之间的关系</strong>。</p>
</li>
<li>
<p>语法：<code>parameterName is Type</code>（左侧为当前函数的参数名，右侧为某一种类型，此时函数返回一个布尔值，表示左侧参数是否属于右侧的类型）</p>
</li>
<li>
<p>用途</p>
<ul>
<li>
<p>类型保护，明确参数类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&#x27;  12334&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isString</span>(x)) &#123;</span><br><span class="line">    x.<span class="title function_">trim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>描述类的方法的返回值，明确实例类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">isDog</span>(): <span class="variable language_">this</span> is <span class="title class_">Dog</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">isDog</span>(): <span class="variable language_">this</span> is <span class="title class_">Dog</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="模版字符串">模版字符串</h3>
<ol>
<li>
<p>解释：TypeScript 允许<strong>使用模板字符串，构建类型</strong>。模版字符串中<strong>允许引用 7 种类型</strong>：string、number、bigint、boolean、null、undefined、Enum。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringValue</span> = <span class="string">&#x27;134&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="string">`<span class="subst">$&#123;StringValue&#125;</span> is received.`</span>; <span class="comment">// &quot;134 is received.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用说明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版字符串引用联合类型时，其结果也是联合类型，因为默办字符串会展开联合类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U1</span> = <span class="string">&#x27;123&#x27;</span> | <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="string">`<span class="subst">$&#123;U1&#125;</span>_id`</span>; <span class="comment">// &quot;true_id&quot; | &quot;123_id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版字符串引用两个以上联合类型时，其会交叉展开这些联合类型。（排列组合）</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U2</span> = <span class="string">&#x27;456&#x27;</span> | <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="string">`<span class="subst">$&#123;U1&#125;</span>--<span class="subst">$&#123;U2&#125;</span>`</span>; <span class="comment">// &quot;true--false&quot; | &quot;true--456&quot; | &quot;123--false&quot; | &quot;123--456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U3</span> = <span class="string">&#x27;789&#x27;</span> | <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="string">`<span class="subst">$&#123;U1&#125;</span>--<span class="subst">$&#123;U2&#125;</span>--<span class="subst">$&#123;U3&#125;</span>`</span>; <span class="comment">// &quot;true--false--true&quot; | &quot;true--false--789&quot; | ... | &quot;123--false--789&quot; | &quot;123--456--789&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="satisfies">satisfies</h3>
<ol>
<li>
<p>解释：satisfies 运算符用于<strong>检查某个值是否符合指定的类型</strong>。</p>
</li>
<li>
<p>使用场景：当不便于直接将某个值显式指定为某种类型，但仍希望该值满足特定的类型条件时，可以使用 satisfies。这样<strong>既能保留类型检查，又能实现类型推断</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Colors</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;green&#x27;</span> | <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">RGB</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 satisfies 运算符</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">palette1</span>: <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span> | <span class="variable constant_">RGB</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">    <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 报错（因为 palette1 不满足类型声明）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">palette1.<span class="property">green</span>.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">6</span>); <span class="comment">// 报错（因为 green 被类型声明为 string | RGB，其上不直接可访问到 substring 方法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 satisfies 运算符</span></span><br><span class="line"><span class="keyword">const</span> palette2 = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">    <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 报错（因为 palette2 不满足 satisfies 类型约束，此时 palette2 的类型为 TS 自行推断的）</span></span><br><span class="line">&#125; <span class="keyword">satisfies</span> <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span> | <span class="variable constant_">RGB</span>&gt;;</span><br><span class="line"></span><br><span class="line">palette2.<span class="property">green</span>.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">6</span>); <span class="comment">// 正确（因为 green 被类型推断为 string，其上可以直接访问到 substring 方法）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TS-类型映射">TS - 类型映射</h2>
<h3 id="简要概述-4">简要概述</h3>
<ol>
<li>
<p>映射（mapping）：<strong>将一种类型按照映射规则，转换成另一种类型</strong>，通常用于对象类型。</p>
</li>
<li>
<p>语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ObjNew</span> = &#123;</span><br><span class="line">  [prop <span class="keyword">in</span> keyof <span class="title class_">ObjOld</span>]: valueType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>prop</code>：属性名变量，名字可以随便起。</li>
<li><code>in</code> 运算符，用来取出右侧的联合类型的每一个成员。</li>
<li><code>keyof ObjOld</code>：返回类型 ObjOld 的每一个属性名组成的联合类型。</li>
</ul>
</li>
<li>
<p>使用说明</p>
   <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象的所有属性值的类型都映射为 boolean 类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjOld</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> toBoolean&lt;T&gt; = &#123;</span><br><span class="line">    [prop <span class="keyword">in</span> keyof T]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = toBoolean&lt;<span class="title class_">ObjOld</span>&gt;; <span class="comment">// &#123; foo: boolean; bar: boolean; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [prop in string] 是 [p: string] 的映射写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">    [prop <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="映射修饰符">映射修饰符</h3>
<ol>
<li>
<p>映射修饰符：用于在映射过程中<strong>修改属性的可选特性和只读特性</strong>。</p>
</li>
<li>
<p>语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ObjNew</span> = &#123;</span><br><span class="line">  +<span class="regexp">/-readonly [prop in keyof ObjOld]+/</span>-?: valueType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>+</code> 修饰符：写成 <code>+?</code> 或 <code>+readonly</code>，为映射属性添加 <code>?</code> 修饰符或 <code>readonly</code> 修饰符。（变为可选或只读属性）</li>
</ul>
<ul>
<li><code>–</code> 修饰符：写成 <code>-?</code> 或 <code>-readonly</code>，为映射属性移除 <code>?</code> 修饰符或 <code>readonly</code> 修饰符。（变为必选或可改属性）</li>
<li><code>+?</code> 或 <code>+readonly</code> 修饰符可以简写为 <code>?</code> 或 <code>readonly</code></li>
</ul>
</li>
<li>
<p>使用示例</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Optional</span>&lt;T&gt; = &#123;</span><br><span class="line">    [prop <span class="keyword">in</span> keyof T]+?: T[prop] <span class="comment">// Partial&lt;T&gt; 的实现原理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;T&gt; = &#123;</span><br><span class="line">    [prop <span class="keyword">in</span> keyof T]-?: T[prop] <span class="comment">// Required&lt;T&gt; 的实现原理；-? 会使得属性为必选属性，即此时不能为 undefined，但可以为 null。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateImmutable</span>&lt;T&gt; = &#123;</span><br><span class="line">    +<span class="keyword">readonly</span> [prop <span class="keyword">in</span> keyof T]: T[prop] <span class="comment">// Readonly&lt;T&gt; 的实现原理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;T&gt; = &#123;</span><br><span class="line">    -<span class="keyword">readonly</span> [prop <span class="keyword">in</span> keyof T]: T[prop]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="键名重映射">键名重映射</h3>
<ol>
<li>
<p>键名重映射（key remapping）：<strong>用于在映射过程中修改键名</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attr">location</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="comment">// Capitalize&lt;T&gt;：一个原生的工具泛型，用来将 T 的首字母变成大写。</span></span><br><span class="line">    <span class="comment">// string &amp; P：一个交叉类型，其中的 P 是 keyof 运算符返回的键名联合类型 string|number|symbol，但是 Capitalize&lt;T&gt; 只能接受字符串作为类型参数，因此 string &amp; P 只返回 P 的字符串属性名。</span></span><br><span class="line">    [prop <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;prop &amp; <span class="built_in">string</span>&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[prop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    等同于</span></span><br><span class="line"><span class="comment">    type LazyPerson = &#123;</span></span><br><span class="line"><span class="comment">        getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">        getAge: () =&gt; string;</span></span><br><span class="line"><span class="comment">        getLocation: () =&gt; string;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ObjNew</span> = &#123;</span><br><span class="line">  [prop <span class="keyword">in</span> keyof <span class="title class_">ObjOld</span> <span class="keyword">as</span> 新类型]: valueType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新类型：通常是一个模板字符串，里面可以对原始键名进行各种操作。</li>
</ul>
</li>
<li>
<p>用途</p>
<ul>
<li>
<p>属性过滤：在属性映射过程中通过映射键名为 <code>never</code> 过滤掉某些属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用途 1：属性映射过程中过滤掉所有字符串属性。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">deviceType</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span>&lt;T&gt; = &#123;</span><br><span class="line">    [prop <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[prop] <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="built_in">never</span> : prop]: T[prop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FilteredUser</span> = <span class="title class_">Filter</span>&lt;<span class="title class_">User</span>&gt;;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    等同于</span></span><br><span class="line"><span class="comment">    type FilteredUser = &#123;</span></span><br><span class="line"><span class="comment">        age: number;</span></span><br><span class="line"><span class="comment">        deviceType: number;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>联合类型映射：将语法修改为 <code>[prop in 联合类型]</code> 可以实现将联合类型映射为一个对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用途 2: 属性映射过程中将每个联合类型映射为新对象类型中的一个属性。</span></span><br><span class="line"><span class="keyword">type</span> S = &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&#x27;square&#x27;</span>,</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">    <span class="attr">radius</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyEvents</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">    [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&#x27;kind&#x27;</span>]]: <span class="function">(<span class="params"><span class="attr">event</span>: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">MyEvents</span>&lt;S | C&gt;;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    等价于</span></span><br><span class="line"><span class="comment">    type Config = &#123;</span></span><br><span class="line"><span class="comment">        square: (event: S) =&gt; void;</span></span><br><span class="line"><span class="comment">        circle: (event: C) =&gt; void;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="TS-类型工具">TS - 类型工具</h2>
<table>
<thead>
<tr>
<th style="text-align:center">语法</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>构造函数</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>ConstructorParameters&lt;Type&gt;</code></td>
<td style="text-align:center">提取构造方法的参数类型，组成一个元组类型返回。</td>
<td style="text-align:center">如果参数类型不是构造方法，就会报错。<br /><code>any</code> 类型和 <code>never</code> 类型是两个特殊值，分别返回 <code>unknown[]</code> 和 <code>never</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>InstanceType&lt;Type&gt;</code></td>
<td style="text-align:center">提取构造函数的返回值的类型（即实例类型）。</td>
<td style="text-align:center">Class 作为类型，代表实例类型。要获取它的构造方法，必须把它当成值，然后用 <code>typeof</code> 运算符获取它的构造方法类型。<br />如果类型参数不是构造方法，就会报错。<br /> <code>any</code> 类型和 <code>never</code> 类型是两个特殊值，分别返回 <code>any</code> 和 <code>never</code>。</td>
</tr>
<tr>
<td style="text-align:center"><strong>联合类型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></td>
<td style="text-align:center">用来从联合类型 <code>UnionType</code> 里面，删除某些类型 <code>ExcludedMembers</code>，组成一个新的类型返回。</td>
<td style="text-align:center"><code>Exclude&lt;T, U&gt;</code> 就相当于从 <code>T</code> 中删除兼容 <code>U</code> 的类型，剩下不兼容的类型。</td>
</tr>
<tr>
<td style="text-align:center"><code>Extract&lt;UnionType, Union&gt;</code></td>
<td style="text-align:center">用来从联合类型 <code>UnionType</code> 之中，提取指定类型 <code>Union</code>，组成一个新类型返回。</td>
<td style="text-align:center"><code>Extract&lt;T, U&gt;</code> 就相当于从 <code>T</code> 中取出兼容 <code>U</code> 的类型。<br />如果参数类型 <code>Union</code> 不包含在联合类型 <code>UnionTyp</code> 之中，则返回 <code>never </code>类型。</td>
</tr>
<tr>
<td style="text-align:center"><code>NonNullable&lt;Type&gt;</code></td>
<td style="text-align:center">用来从联合类型 <code>Type</code> 删除 <code>null</code> 类型和 <code>undefined</code> 类型，组成一个新类型返回，也就是返回 <code>Type</code> 的非空类型版本。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>对象类型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Omit&lt;Type, Keys&gt;</code></td>
<td style="text-align:center">用来从对象类型 <code>Type</code> 中，删除指定的属性 <code>Keys</code>，组成一个新的对象类型返回。</td>
<td style="text-align:center"><code>Omit&lt;T, U&gt;</code> 相当于从 <code>T</code> 中删除值兼容 <code> U</code> 的属性。<br />指定删除的键名 <code>Keys</code> 可以是对象类型 <code>Type</code> 中不存在的属性，但必须兼容 `string</td>
</tr>
<tr>
<td style="text-align:center"><code>Pick&lt;Type, Keys&gt;</code></td>
<td style="text-align:center">返回一个新的对象类型，第一个参数 <code>Type</code> 是一个对象类型，第二个参数 <code>Keys</code> 是 <code>Type</code> 里面被选定的键名。</td>
<td style="text-align:center"><code>Pick&lt;T, U&gt;</code> 相当于从 T 中筛选出值兼容 U 的属性。<br />指定的键名 <code>Keys</code> 必须是对象键名 <code>Type</code> 里面已经存在的键名，否则会报错。</td>
</tr>
<tr>
<td style="text-align:center"><code>Partial&lt;Type&gt;</code></td>
<td style="text-align:center">返回一个新类型，将参数类型 <code>Type</code> 的所有属性变为可选属性。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Required&lt;Type&gt;</code></td>
<td style="text-align:center">返回一个新类型，将参数类型 <code>Type</code> 的所有属性变为必选属性。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Readonly&lt;Type&gt;</code></td>
<td style="text-align:center">返回一个新类型，将参数类型 <code>Type</code> 的所有属性变为只读属性。</td>
<td style="text-align:center"><code>Readonly&lt;Type&gt;</code> 可以与 <code>Partial&lt;Type&gt;</code> 结合使用 <code>Readonly&lt;Partial&lt;Type&gt;&gt;</code>，将所有属性变成只读的可选属性。</td>
</tr>
<tr>
<td style="text-align:center"><code>Record&lt;Keys, Type&gt;</code></td>
<td style="text-align:center">返回一个对象类型，参数 <code>Keys</code> 用作键名，参数 <code>Type</code> 用作键值类型。</td>
<td style="text-align:center">参数 <code>Keys</code> 可以是联合类型，这时会依次展开为多个键。<br />如果参数 <code>Type</code> 是联合类型，就表明键值是联合类型。<br />参数 <code>Keys</code> 的类型必须兼容 `string</td>
</tr>
<tr>
<td style="text-align:center"><strong>函数类型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Parameters&lt;Type&gt;</code></td>
<td style="text-align:center">从函数类型 <code>Type</code> 里面提取参数类型，组成一个元组返回。</td>
<td style="text-align:center">如果参数类型 <code>Type </code>不是带有参数的函数形式，会报错（包括 <code>Function</code> 类型）。<br /><code>any</code> 和 <code>never</code> 是两个特殊值，会返回 <code>unknown[]</code> 和 <code>never</code>。<br /><code>Parameters&lt;Type&gt;</code> 主要用于从外部模块提供的函数类型中，获取参数类型。</td>
</tr>
<tr>
<td style="text-align:center"><code>ReturnType&lt;Type&gt;</code></td>
<td style="text-align:center">提取函数类型 <code>Type</code> 的返回值类型，作为一个新类型返回。</td>
<td style="text-align:center">如果类型不是函数，会报错（包括 <code>Function</code> 类型）。<br /><code>any</code> 和 <code>never</code> 是两个特殊值，分别返回 <code>any</code> 和 <code>never</code>。<br />如果参数类型是泛型函数，返回值取决于泛型类型。如果泛型不带有限制条件，就会返回 <code>unknown</code>。</td>
</tr>
<tr>
<td style="text-align:center"><strong><code>this</code></strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>OmitThisParameter&lt;Type&gt;</code></td>
<td style="text-align:center">从函数类型中移除 <code>this</code> 参数。</td>
<td style="text-align:center">如果函数没有 <code>this</code> 参数，则返回原始函数类型。</td>
</tr>
<tr>
<td style="text-align:center"><code>ThisParameterType&lt;Type&gt;</code></td>
<td style="text-align:center">提取函数类型中 <code>this</code> 参数的类型。</td>
<td style="text-align:center">如果函数没有 <code>this</code> 参数，则返回 <code>unknown</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>ThisType&lt;Type&gt;</code></td>
<td style="text-align:center">不返回类型，只用来跟其他类型组成交叉类型，用来提示 TypeScript 其他类型里面的 <code>this</code> 的类型。</td>
<td style="text-align:center"><code>ThisType&lt;T&gt; &amp; U</code> 声明对象类型时，<code>T</code>、<code>U</code> 往往是一个对象类型，包含了方法定义，此时在这些方法中使用 <code>this</code> 时，<code>this</code> 需要满足 <code>T</code> 所指定的类型约束。<br />使用这个类型工具时，必须打开 <code>noImplicitThis</code> 设置。</td>
</tr>
<tr>
<td style="text-align:center"><strong><code>Promise</code></strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Awaited&lt;Type&gt;</code></td>
<td style="text-align:center">用来取出 Promise 的返回值类型。</td>
<td style="text-align:center">用于描述 <code>then()</code> 方法和 <code>await</code> 命令的参数类型。<br />可以返回多重 Promise 的返回值类型。<br />如果类型参数不是 Promise 类型，那么就会原样返回。</td>
</tr>
<tr>
<td style="text-align:center"><strong>数组类型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>ReadonlyArray&lt;Type&gt;</code></td>
<td style="text-align:center">用来生成一个只读数组类型，类型参数 <code>Type</code> 表示数组成员的类型。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>字符串类型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>Uppercase&lt;StringType&gt;</code></td>
<td style="text-align:center">将字符串类型的每个字符转为大写。</td>
<td style="text-align:center">通过底层调用 JavaScript 引擎提供 JavaScript 字符操作方法来实现。</td>
</tr>
<tr>
<td style="text-align:center"><code>Lowercase&lt;StringType&gt;</code></td>
<td style="text-align:center">将字符串类型的每个字符转为小写。</td>
<td style="text-align:center">通过底层调用 JavaScript 引擎提供 JavaScript 字符操作方法来实现。</td>
</tr>
<tr>
<td style="text-align:center"><code>Capitalize&lt;StringType&gt;</code></td>
<td style="text-align:center">将字符串的第一个字符转为大写。</td>
<td style="text-align:center">通过底层调用 JavaScript 引擎提供 JavaScript 字符操作方法来实现。</td>
</tr>
<tr>
<td style="text-align:center"><code>Uncapitalize&lt;StringType&gt;</code></td>
<td style="text-align:center"><code>Uncapitalize&lt;StringType&gt;</code> 将字符串的第一个字符转为小写。</td>
<td style="text-align:center">通过底层调用 JavaScript 引擎提供 JavaScript 字符操作方法来实现。</td>
</tr>
</tbody>
</table>
<h2 id="TS-注释指令">TS - 注释指令</h2>
<h3 id="注释指令">注释指令</h3>
<p>注释指令：指的是采用 JS 双斜杠注释的形式，向编译器发出的命令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>// @ts-nocheck</code></td>
<td style="text-align:center">不对当前脚本进行类型检查。</td>
</tr>
<tr>
<td style="text-align:center"><code>// @ts-check</code></td>
<td style="text-align:center">对当前脚本进行类型检查，不论是否启用了 <code>checkJs</code> 编译选项。</td>
</tr>
<tr>
<td style="text-align:center"><code>// @ts-ignore</code></td>
<td style="text-align:center">不对下一行代码进行类型检查。</td>
</tr>
<tr>
<td style="text-align:center"><code>// @ts-expect-error</code></td>
<td style="text-align:center">主要用在<strong>测试用例</strong>，当下一行有类型错误时，它会压制 TypeScript 的报错信息（即不显示报错信息），把错误留给代码自己处理。<br />如果下一行代码确实存在错误，编译器不会报错；但如果没有错误，编译器会抛出一个错误，提示不应使用 <code>@ts-expect-error</code>。</td>
</tr>
</tbody>
</table>
<h3 id="JS-Doc">JS Doc</h3>
<p>解释：TypeScript 直接处理 JS 文件时，如果无法推断出类型，会使用 JS 脚本里面的 JSDoc 注释。要求：</p>
<ul>
<li>JSDoc 注释必须以 <code>/**</code> 开始；</li>
<li>JSDoc 注释必须与它描述的代码处于相邻的位置，并且注释在上，代码在下。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@typedef &#123;类型&#125; 类型别名</code></td>
<td style="text-align:center">创建自定义类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>@type &#123;类型 or 类型别名&#125;</code></td>
<td style="text-align:center">定义变量的类型</td>
<td style="text-align:center">其下必须紧接变量声明</td>
</tr>
<tr>
<td style="text-align:center"><code>@param &#123;类型 or 类型别名&#125; 参数名</code><br /><code>@param &#123;类型 or 类型别名&#125; [参数名]</code>（可选参数）<br /><code>@param &#123;类型 or 类型别名&#125; [参数名=默认值]</code>（参数默认值）</td>
<td style="text-align:center">定义函数参数的类型</td>
<td style="text-align:center">其下必须紧接函数声明</td>
</tr>
<tr>
<td style="text-align:center"><code>@return &#123;类型 or 类型别名&#125;</code> / <code>@returns &#123;类型 or 类型别名&#125;</code></td>
<td style="text-align:center">指定函数返回值的类型</td>
<td style="text-align:center">其下必须紧接函数声明</td>
</tr>
<tr>
<td style="text-align:center"><code>@extends &#123;基类名&#125;</code></td>
<td style="text-align:center">定义继承的基类</td>
<td style="text-align:center">其下必须紧接类声明</td>
</tr>
<tr>
<td style="text-align:center"><code>@public</code>、<code>@protected</code>、<code>@protected</code>、<code>@readonly</code></td>
<td style="text-align:center">指定类的公开成员、保护成员、私有成员和只读成员</td>
<td style="text-align:center">其下必须紧接类的成员声明<br />一个成员可以同时使用可访问性修饰符和只读修饰符</td>
</tr>
</tbody>
</table>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">Object</span>&#125; <span class="variable">Person</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span> - The name of the person.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">number</span>&#125; <span class="variable">age</span> - The age of the person.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">Person</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LivingBeing</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@public</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    isAlive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">breathe</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Breathing&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> &#123;<span class="type">LivingBeing</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> <span class="keyword">extends</span> <span class="title class_ inherited__">LivingBeing</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@public</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@readonly</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    species = <span class="string">&quot;Homo sapiens&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _heartRate = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _brainActivity = <span class="string">&quot;active&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">age</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; [isAwake=true] - Whether the human is awake.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age, isAwake = <span class="literal">true</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isAwake</span> = isAwake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getStatus</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isAwake</span> ? <span class="string">&quot;awake&quot;</span> : <span class="string">&quot;asleep&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TS-tsconfig-json">TS - tsconfig.json</h2>
<ol>
<li>
<p>解释：<code>tsconfig.json</code> 是 TypeScript 项目的配置文件，位于项目的根目录。</p>
<blockquote>
<p>如果想用 TypeScript 处理 JavaScript 项目，此时可使用配置文件 <code>jsconfig.json</code>。</p>
</blockquote>
<blockquote>
<p><code>tsc</code> 编译器编译 TypeScript 代码时，<strong>首先在当前目录搜索，如果不存在则在上一级目录搜索，直到找到为止</strong>。</p>
</blockquote>
<blockquote>
<p><code>tsc</code> 编译时，可以使用命令行参数 <code>--project</code> 或 <code>-p</code> 来指定配置文件 <code>tsconfig.json</code> 的位置（目录或文件）。</p>
</blockquote>
</li>
<li>
<p>生成 <code>tsconfig.json</code></p>
<ul>
<li>
<p>方式一：使用 <code>tsc</code> ，命令自动生成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --init</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式二：安装 npm 的 <a target="_blank" rel="noopener" href="https://github.com/tsconfig/bases/tree/main/bases"><code>@tsconfig</code> 名称空间</a>下的模块，即写好的  <code>tsconfig.json</code>  样本，然后在 <code>tsconfig.json</code> 中使用 <code>extends</code> 关键字引用这个模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev @tsconfig/deno</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tsconfig/deno/tsconfig.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<hr>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// &quot;include&quot;: [&quot;src/**/*&quot;, &quot;tests/**/*&quot;],              /* 数组，指定哪些文件需要编译，即要编译的文件列表。既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。 */</span></span><br><span class="line">  <span class="comment">//                                                     /* include属性支持三种通配符：? 指代单个字符；* 指代任意字符，不含路径分隔符；** 指定任意目录层级。 */</span></span><br><span class="line">  <span class="comment">//                                                     /* 如果不指定文件后缀名，默认包括 .ts、.tsx 和 .d.ts 文件。如果打开了 allowJs，那么还包括 .js 和 .jsx。 */</span></span><br><span class="line">  <span class="comment">// &quot;exclude&quot;: [&quot;**/*.spec.ts&quot;],                        /* 数组，指定哪些文件不需要编译，用于从编译列表中去除指定的文件，该属性必须和 include 属性一起使用。 */</span></span><br><span class="line">  <span class="comment">// &quot;extends&quot;: &quot;@tsconfig/node12/tsconfig.json&quot;,        /* 指定当前 tsconfig 要继承的配置文件，可以是本地文件，也可以是 npm 模块中的 tsconfig 文件。 */</span></span><br><span class="line">  <span class="comment">//                                                     /* 编译时，extends 指定的 tsconfig 文件会先加载，然后加载当前的 tsconfig 文件，后者会覆盖前者。 */</span></span><br><span class="line">  <span class="comment">//                                                     /* 如果一个项目有多个配置，可以把共同的配置写成 tsconfig.base.json，其他的配置文件继承该文件，这样便于维护和修改。 */</span></span><br><span class="line">  <span class="comment">// &quot;files&quot;: [&quot;a.ts&quot;, &quot;b.ts&quot;],                          /* 数组，指定编译的文件列表，如果其中有一个文件不存在，就会报错。排在前面的文件先编译。 */</span></span><br><span class="line">  <span class="comment">//                                                     /* 由于该属性需要逐一列出文件，且不支持文件匹配，因此文件较多时，建议使用 include 和 exclude 属性。 */</span></span><br><span class="line">  <span class="comment">// &quot;references&quot;: [                                     /* references 属性是一个数组，数组成员为对象，适合一个大项目由许多小项目构成的情况，用来设置需要引用的底层项目。 */</span></span><br><span class="line">  <span class="comment">//   &#123; &quot;path&quot;: &quot;../pkg1&quot; &#125;,                            /* references 数组成员对象的 path 属性，既可以是含有文件 tsconfig.json 的目录，也可以直接是该文件。 */</span></span><br><span class="line">  <span class="comment">//   &#123; &quot;path&quot;: &quot;../pkg2/tsconfig.json&quot; &#125;               /* 与此同时，被引用的底层项目的 tsconfig.json 必须启用 composite 属性。（compilerOptions.composite) */</span></span><br><span class="line">  <span class="comment">// ],                                                  /* 假设项目 A 引用了项目 B 和 C，那么 B 和 C 编译需要先于 A。 */</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">/* 该属性用于定制编译行为 */</span></span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig to read more about this file */</span></span><br><span class="line">    <span class="comment">/* Projects */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                              /* 让 TypeScript 项目构建时产生文件 tsbuildinfo，从而完成增量构建。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 增量编译是一种编译优化技术，旨在通过只重新编译自上次编译以来发生变化的部分代码来加快编译过程。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Save .tsbuildinfo files to allow for incremental compilation of projects. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                                /* 打开某些设置，使得 TypeScript 项目可以进行增量构建，往往跟 incremental 属性配合使用。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable constraints that allow a TypeScript project to be used with project references. */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./.tsbuildinfo&quot;,              /* Specify the path to .tsbuildinfo incremental compilation file. */</span></span><br><span class="line">    <span class="comment">// &quot;disableSourceOfProjectReferenceRedirect&quot;: true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */</span></span><br><span class="line">    <span class="comment">// &quot;disableSolutionSearching&quot;: true,                 /* Opt a project out of multi-project reference checking when editing. */</span></span><br><span class="line">    <span class="comment">// &quot;disableReferencedProjectLoad&quot;: true,             /* Reduce the number of projects loaded automatically by TypeScript. */</span></span><br><span class="line">    <span class="comment">/* Language and Environment */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2016&quot;</span><span class="punctuation">,</span> <span class="comment">/* 指定编译出来的 JavaScript 代码的 ECMAScript 版本。该配置可取值为 es3、es5、es6/es2015、es2016、es2017、es2018、es2019、es2020、es2021、es2022、esnext */</span></span><br><span class="line">    <span class="comment">//                                                   /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                                        /* 数组，描述项目需要加载的 TypeScript 内置类型描述文件，跟三斜线指令 /// &lt;reference lib=&quot;&quot; /&gt; 作用相同。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 常见的库文件有， */</span></span><br><span class="line">    <span class="comment">//                                                   /* - ES5、ES6（也称为 ES2015）、ES2016 等：提供 ECMAScript 不同版本的内置对象和 API 的类型定义。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - DOM：提供对浏览器环境中 DOM API 的类型定义支持。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - WebWorker：提供对 Web Worker 环境的类型定义支持。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - ESNext：提供对最新 ECMAScript 提案的类型定义支持。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果没有显式指定 lib 选项，TypeScript 会根据 target 选项的值自动选择适当的库文件。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify a set of bundled library declaration files that describe the target runtime environment. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                                /* 设置如何处理 .tsx 文件。它可以取以下五个值。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - preserve：保持 jsx 语法不变，输出的文件名为.jsx。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - react：将 &lt;div /&gt; 编译成 React.createElement(&quot;div&quot;)，输出的文件名为 .js。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - react-native：保持 jsx 语法不变，输出的文件后缀名为 .js。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - react-jsx：将 &lt;div /&gt; 编译成 _jsx(&quot;div&quot;)，输出的文件名为 .js。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - react-jsxdev：跟 react-jsx 类似，但是为 _jsx() 加上更多的开发调试项，输出的文件名为 .js。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify what JSX code is generated. */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,                   /* Enable experimental support for legacy experimental decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,                    /* Emit design-type metadata for decorated declarations in source files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsxFactory&quot;: &quot;&quot;,                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. &#x27;React.createElement&#x27; or &#x27;h&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;jsxFragmentFactory&quot;: &quot;&quot;,                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. &#x27;React.Fragment&#x27; or &#x27;Fragment&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;jsxImportSource&quot;: &quot;&quot;,                            /* Specify module specifier used to import the JSX factory functions when using &#x27;jsx: react-jsx*&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;reactNamespace&quot;: &quot;&quot;,                             /* Specify the object invoked for &#x27;createElement&#x27;. This only applies when targeting &#x27;react&#x27; JSX emit. */</span></span><br><span class="line">    <span class="comment">// &quot;noLib&quot;: true,                                    /* Disable including any library files, including the default lib.d.ts. */</span></span><br><span class="line">    <span class="comment">// &quot;useDefineForClassFields&quot;: true,                  /* 这个设置针对的是，在类（class）的顶部声明的属性。TypeScript 早先对这一类属性的处理方法，与写入 ES2022 标准的处理方法不一致。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 这个设置设为 true，就用来开启 ES2022 的处理方法，设为 false 就是 TypeScript 原有的处理方法。*/</span></span><br><span class="line">    <span class="comment">//                                                   /* 它的默认值跟 target 属性有关，如果编译目标是 ES2022 或更高，那么 useDefineForClassFields 默认值为 true，否则为 false。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Emit ECMAScript-standard-compliant class fields. */</span></span><br><span class="line">    <span class="comment">// &quot;moduleDetection&quot;: &quot;auto&quot;,                        /* Control what method is used to detect module-format JS files. */</span></span><br><span class="line">    <span class="comment">/* Modules */</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span> <span class="comment">/* 指定编译产物的模块格式。它的默认值与 target 属性有关，如果 target 是 ES3 或 ES5，它的默认值是 commonjs，否则就是ES6/ES2015。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 可以取以下值：none、commonjs、amd、umd、system、es6/es2015、es2020、es2022、esnext、node16、nodenext。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify what module code is generated. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                                  /* 指定项目的根目录。它告诉编译器从哪个目录开始寻找源文件，并保持该目录的结构在输出目录中。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify the root folder within your source files. */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node10&quot;,                     /* 确定模块路径的算法，即如何查找模块。它可以取以下四种值。*/</span></span><br><span class="line">    <span class="comment">//                                                   /* - node：采用 Node.js 的 CommonJS 模块算法。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - node16 或 nodenext：采用 Node.js 的 ECMAScript 模块算法，从 TypeScript 4.7 开始支持。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - classic：TypeScript 1.6 之前的算法，新项目不建议使用。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* - bundler：TypeScript 5.0 新增的选项，表示当前代码会被其他打包器（比如 Webpack、Vite、esbuild、Parcel、rollup、swc）处理，从而放宽加载规则，它要求 module 设为 es2015 或更高版本。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 它的默认值与 module 属性有关，如果 module 为 AMD、UMD、System 或 ES6/ES2015，默认值为 classic；如果 module 为 node16 或 nodenext，默认值为这两个值；其他情况下,默认值为 Node。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify how TypeScript looks up a file from a given module specifier. */</span></span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                                  /* 字符串，指定 TypeScript 项目的基准目录。由于默认是以 tsconfig.json 的位置作为基准目录，所以一般情况不需要使用该属性。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果设置了基准目录，那么 TypeScript 在 import 模块时，会以基准目录为起点开始查找。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify the base directory to resolve non-relative module names. */</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                                      /* 对象，设置模块名和模块路径的映射，也就是 TypeScript 如何导入 require 或 imports 语句加载的模块。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* paths 基于 baseUrl 进行加载，所以必须同时设置后者。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果设置 &#x27;baseUrl&#x27; 为 &#x27;./&#x27;，&#x27;paths&#x27; 为 &#123; &quot;b&quot;: [&quot;bar/b&quot;] &#125;，那么 require(&#x27;b&#x27;) 时，加载的是 ./bar/b */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果设置 &#x27;baseUrl&#x27; 为 &#x27;./&#x27;，&#x27;paths&#x27; 为 &#123; &quot;@bar/*&quot;: [&quot;bar/*&quot;] &#125;，那么 require(&#x27;@bar/b&#x27;) 时，加载的是 ./bar/b */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify a set of entries that re-map imports to additional lookup locations. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                                   /* 将多个目录视为一个虚拟目录，使得这些目录中的文件可以相互引用，就像它们在同一个目录中一样，简化了路径管理。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Allow multiple folders to be treated as one when resolving modules. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                                  /* 设置类型模块所在的目录，默认是 node_modules/@types，该目录里面的模块会自动加入编译。一旦指定了该属性，就不会再用默认值 node_modules/@types 里面的类型模块。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 数组，数组的每个成员就是一个目录，它们的路径是相对于 tsconfig.json 位置。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify multiple folders that act like &#x27;./node_modules/@types&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                                      /* 默认情况下，typeRoots 目录下所有模块都会自动加入编译，如果指定了 types 属性，那么只有其中列出的模块才会自动加入编译。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果 &quot;types&quot;: []，就表示不会自动将所有 @types 模块加入编译。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify type package names to be included without being referenced in a source file. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,                     /* Allow accessing UMD globals from modules. */</span></span><br><span class="line">    <span class="comment">// &quot;moduleSuffixes&quot;: [],                             /* 数组，指定模块的后缀名。假设该属性取值为 [&quot;.ios&quot;, &quot;.native&quot;, &quot;&quot;]，此时 */</span></span><br><span class="line">    <span class="comment">//                                                   /* TypeScript 对于语句 import * as foo from &quot;./foo&quot;;，会搜索以下脚本 ./foo.ios.ts、./foo.native.ts 和 ./foo.ts。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* List of file name suffixes to search when resolving a module. */</span></span><br><span class="line">    <span class="comment">// &quot;allowImportingTsExtensions&quot;: true,               /* Allow imports to include TypeScript file extensions. Requires &#x27;--moduleResolution bundler&#x27; and either &#x27;--noEmit&#x27; or &#x27;--emitDeclarationOnly&#x27; to be set. */</span></span><br><span class="line">    <span class="comment">// &quot;rewriteRelativeImportExtensions&quot;: true,          /* Rewrite &#x27;.ts&#x27;, &#x27;.tsx&#x27;, &#x27;.mts&#x27;, and &#x27;.cts&#x27; file extensions in relative import paths to their JavaScript equivalent in output files. */</span></span><br><span class="line">    <span class="comment">// &quot;resolvePackageJsonExports&quot;: true,                /* Use the package.json &#x27;exports&#x27; field when resolving package imports. */</span></span><br><span class="line">    <span class="comment">// &quot;resolvePackageJsonImports&quot;: true,                /* Use the package.json &#x27;imports&#x27; field when resolving imports. */</span></span><br><span class="line">    <span class="comment">// &quot;customConditions&quot;: [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */</span></span><br><span class="line">    <span class="comment">// &quot;noUncheckedSideEffectImports&quot;: true,             /* Check side effect imports. */</span></span><br><span class="line">    <span class="comment">// &quot;resolveJsonModule&quot;: true,                        /* 允许 import 命令导入 JSON 文件。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable importing .json files. */</span></span><br><span class="line">    <span class="comment">// &quot;allowArbitraryExtensions&quot;: true,                 /* Enable importing files with any extension, provided a declaration file is present. */</span></span><br><span class="line">    <span class="comment">// &quot;noResolve&quot;: true,                                /* Disallow &#x27;import&#x27;s, &#x27;require&#x27;s or &#x27;&lt;reference&gt;&#x27;s from expanding the number of files TypeScript should add to a project. */</span></span><br><span class="line">    <span class="comment">/* JavaScript Support */</span></span><br><span class="line">    <span class="comment">// &quot;allowJs&quot;: true,                                  /* 是否允许 TypeScript 项目加载 JS 脚本。编译时，也会将 JS 文件，一起拷贝到输出目录。 */                                </span></span><br><span class="line">    <span class="comment">//                                                   /* Allow JavaScript files to be a part of your program. Use the &#x27;checkJS&#x27; option to get errors from these files. */</span></span><br><span class="line">    <span class="comment">// &quot;checkJs&quot;: true,                                  /* 是否对 JS 文件同样进行类型检查。打开这个属性，也会自动打开 allowJs。它等同于在 JS 脚本的头部添加// @ts-check命令。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable error reporting in type-checked JavaScript files. */</span></span><br><span class="line">    <span class="comment">// &quot;maxNodeModuleJsDepth&quot;: 1,                        /* Specify the maximum folder depth used for checking JavaScript files from &#x27;node_modules&#x27;. Only applicable with &#x27;allowJs&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Emit */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                              /* 设置编译时是否为每个脚本生成类型声明文件.d.ts。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Generate .d.ts files from TypeScript and JavaScript files in your project. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                           /* 设置生成 .d.ts 类型声明文件的同时，还会生成对应的 Source Map 文件。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Create sourcemaps for d.ts files. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDeclarationOnly&quot;: true,                      /* 设置编译后只生成 .d.ts 文件，不生成 .js 文件。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Only output d.ts files and not JavaScript files. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                                /* 编译时是否生成 SourceMap 文件。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Create source map files for emitted JavaScript files. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,                          /* 设置将 SourceMap 文件写入编译后的 JS 文件中，否则会单独生成一个 .js.map 文件。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Include sourcemap files inside the emitted JavaScript. */</span></span><br><span class="line">    <span class="comment">// &quot;noEmit&quot;: true,                                   /* 设置是否产生编译结果。如果不生成，TypeScript 编译就纯粹作为类型检查了。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable emitting files from a compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;./&quot;,                                  /* 设置将所有非模块的全局文件，编译在同一个文件里面。它只有在 module 属性为 None、System、AMD 时才生效，并且不能用来打包 CommonJS 或 ES6 模块。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify a file that bundles all outputs into one JavaScript file. If &#x27;declaration&#x27; is true, also designates a file that bundles all .d.ts output. */</span></span><br><span class="line">    <span class="comment">// &quot;outDir&quot;: &quot;./&quot;,                                   /* 指定编译产物的存放目录。如果不指定，编译出来的 .js 文件存放在对应的 .ts 文件的相同位置。 */</span></span><br><span class="line">    <span class="comment">/* Specify an output folder for all emitted files. */</span></span><br><span class="line">    <span class="comment">// &quot;removeComments&quot;: true,                           /* 移除 TypeScript 脚本里面的注释，默认为 false。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable emitting comments. */</span></span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                                 /* 在 SourceMap 里面设置 TypeScript 源文件的位置。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify the root path for debuggers to find the reference source code. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                                    /* 指定 SourceMap 文件的位置，而不是默认的生成位置。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                            /* 控制是否将源代码内联到生成的 Source Map 文件中。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 要求 sourceMap 或 inlineSourceMap 至少打开一个 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Include source code in the sourcemaps inside the emitted JavaScript. */</span></span><br><span class="line">    <span class="comment">// &quot;emitBOM&quot;: true,                                  /* emitBOM 设置是否在编译结果的文件头添加字节顺序标志 BOM，默认值是false。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 字节顺序标记（BOM）是 Unicode 字符编码中的一个特殊字符，位于文本文件的开头，用于指示文件的字节顺序（即字节序）和编码格式。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 字节顺序（Byte Order），也称为字节序，是指在计算机内存中存储多字节数据（如整数、浮点数）的字节排列方式。分为大端字节序和小端字节序。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */</span></span><br><span class="line">    <span class="comment">// &quot;newLine&quot;: &quot;crlf&quot;,                                /* 设置换行符为 CRLF（Windows）还是 LF（Linux）。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Set the newline character for emitting files. */</span></span><br><span class="line">    <span class="comment">// &quot;stripInternal&quot;: true,                            /* Disable emitting declarations that have &#x27;@internal&#x27; in their JSDoc comments. */</span></span><br><span class="line">    <span class="comment">// &quot;noEmitHelpers&quot;: true,                            /* 设置在编译结果文件不插入 TypeScript 辅助函数，而是通过外部引入辅助函数来解决，比如 NPM 模块tslib。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 当 noEmitHelpers 设置为 true 时，TypeScript 编译器不会在输出的 JavaScript 文件中包含辅助函数。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 这意味着如果你的代码使用了需要辅助函数的特性（如类继承、异步函数等），你需要通过其他方式提供这些辅助函数。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable generating custom helper functions like &#x27;__extends&#x27; in compiled output. */</span></span><br><span class="line">    <span class="comment">// &quot;noEmitOnError&quot;: true,                            /* 指定一旦编译报错，就不生成编译产物，默认为false。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable emitting files if any type checking errors are reported. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveConstEnums&quot;: true,                       /* 将 const enum 结构保留下来，不替换成常量值。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable erasing &#x27;const enum&#x27; declarations in generated code. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationDir&quot;: &quot;./&quot;,                           /* 设置生成的 .d.ts 文件所在的目录。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Specify the output directory for generated declaration files. */</span></span><br><span class="line">    <span class="comment">/* Interop Constraints */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,                          /* 设置如果当前 TypeScript 脚本作为单个模块编译，是否会因为缺少其他脚本的类型信息而报错，主要便于非官方的编译工具（比如 Babel）正确编译单个脚本。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Ensure that each file can be safely transpiled without relying on other imports. */</span></span><br><span class="line">    <span class="comment">// &quot;verbatimModuleSyntax&quot;: true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file&#x27;s format based on the &#x27;module&#x27; setting. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedDeclarations&quot;: true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,             /* 允许 import 命令默认加载没有 default 输出的模块。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 打开这个设置，就可以写 import React from &quot;react&quot;;，而不是import * as React from &quot;react&quot;;。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Allow &#x27;import x from y&#x27; when a module doesn&#x27;t have a default export. */</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* esModuleInterop 修复了一些 CommonJS 和 ES6 模块之间的兼容性问题。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果 module 属性为 node16 或 nodenext，则 esModuleInterop 默认为 true，其他情况默认为 false。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 不打开这个选项，使用 import * as moment from &#x27;moment&#x27; 加载 CommonJS 模块。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 打开这个选项，使用 import moment from &#x27;moment&#x27; 加载 CommonJS 模块，同时 moment 可以作为一个函数使用。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 注意，打开 esModuleInterop，将自动打开 allowSyntheticDefaultImports。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables &#x27;allowSyntheticDefaultImports&#x27; for type compatibility. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* 设置文件名是否为大小写敏感，默认为true。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Ensure that casing is correct in imports. */</span></span><br><span class="line">    <span class="comment">/* Type Checking */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* 打开 TypeScript 的严格检查，默认是关闭的。当该配置打开时，相当于打开了一系列配置， */</span></span><br><span class="line">    <span class="comment">//                                                   /* alwaysStrict、strictNullChecks、strictBindCallApply、strictFunctionTypes */</span></span><br><span class="line">    <span class="comment">//                                                   /* strictPropertyInitialization、noImplicitAny、noImplicitThis、useUnknownInCatchVariables */</span></span><br><span class="line">    <span class="comment">//                                                   /* 打开该选项时，允许关闭 alwaysStrict */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitAny&quot;: true,                            /* 设置当一个表达式没有明确的类型描述、且编译器无法推断出具体类型时，是否允许将它推断为 any 类型。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 它是一个布尔值，默认为 true，即只要推断出 any 类型就报错。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable error reporting for expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,                         /* 是否使用严格类型，如果使用，则禁止变量赋值为 undefined 和 null，除非变量原本就是这两种类型。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 它相当于从变量的值里面，排除了 undefined 和 null。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* When type checking, take into account &#x27;null&#x27; and &#x27;undefined&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,                      /* 允许对函数更严格的参数检查。具体来说，如果函数 B 的参数是函数 A 参数的子类型，那么函数 B 不能替代函数 A。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,                      /* 设置是否对函数的 call()、bind()、apply() 这三个方法进行类型检查。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 如果不打开该编译选项，编译器不会对以上三个方法进行类型检查，参数类型都是 any，传入任何参数都不会产生编译错误。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Check that the arguments for &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods match the original function. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,             /* 设置类的实例属性都必须初始化，包括：设置为 undefined 类型，显示初始化，构造函数中赋值。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* 注意，使用该属性的同时，必须打开 strictNullChecks。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Check for class properties that are declared but not set in the constructor. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBuiltinIteratorReturn&quot;: true,              /* Built-in iterators are instantiated with a &#x27;TReturn&#x27; type of &#x27;undefined&#x27; instead of &#x27;any&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                           /* 设置如果 this 被推断为 any 类型是否报错。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable error reporting when &#x27;this&#x27; is given the type &#x27;any&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;useUnknownInCatchVariables&quot;: true,               /* 设置 catch 语句捕获的 try 抛出的返回值类型，从 any 变成 unknown。此时，使用 err 之前，必须缩小它的类型，否则会报错。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Default catch clause variables as &#x27;unknown&#x27; instead of &#x27;any&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                             /* 确保脚本以 ECMAScript 严格模式进行解析，因此脚本头部不用写 &quot;use strict&quot;，默认为 true。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Ensure &#x27;use strict&#x27; is always emitted. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                           /* 设置是否允许未使用的局部变量。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable error reporting when local variables aren&#x27;t read. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,                       /* 设置是否允许未使用的函数参数。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Raise an error when a function parameter isn&#x27;t read. */</span></span><br><span class="line">    <span class="comment">// &quot;exactOptionalPropertyTypes&quot;: true,               /* 设置可选属性不能赋值为 undefined。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Interpret optional property types as written, rather than adding &#x27;undefined&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,                        /* 设置是否要求函数任何情况下都必须返回一个值，即函数必须有 return 语句。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable error reporting for codepaths that do not explicitly return in a function. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,               /* 设置是否对没有 break 语句（或者 return 和 throw 语句）的 switch 分支报错，即 case 代码里面必须有终结语句（比如 break）。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Enable error reporting for fallthrough cases in switch statements. */</span></span><br><span class="line">    <span class="comment">// &quot;noUncheckedIndexedAccess&quot;: true,                 /* Add &#x27;undefined&#x27; to a type when accessed using an index. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitOverride&quot;: true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */</span></span><br><span class="line">    <span class="comment">// &quot;noPropertyAccessFromIndexSignature&quot;: true,       /* Enforces using indexed accessors for keys declared using an indexed type. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUnreachableCode&quot;: true,                     /* 设置是否允许存在不可能执行到的代码。它的值有三种可能。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* undefined： 默认值，编辑器显示警告。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* true：忽略不可能执行到的代码。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* false：编译器报错。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable error reporting for unreachable code. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUnusedLabels&quot;: true,                        /* 设置是否允许存在没有用到的代码标签（label）。它的值有三种可能。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* undefined： 默认值，编辑器显示警告。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* true：忽略没有用到的代码标签。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* false：编译器报错。 */</span></span><br><span class="line">    <span class="comment">//                                                   /* Disable error reporting for unused labels. */</span></span><br><span class="line">    <span class="comment">/* Completeness */</span></span><br><span class="line">    <span class="comment">// &quot;skipDefaultLibCheck&quot;: true,                      /* Skip type checking .d.ts files that are included with TypeScript. */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* Skip type checking all .d.ts files. */</span></span><br><span class="line">    <span class="comment">// &quot;listEmittedFiles&quot;: false,                        /* 设置编译时在终端显示，生成了哪些文件。 */</span></span><br><span class="line">    <span class="comment">// &quot;listFiles&quot;: false,                               /* 设置编译时在终端显示，参与本次编译的文件列表。 */</span></span><br><span class="line">    <span class="comment">// &quot;pretty&quot;: true,                                   /* 设置美化输出终端的编译信息，默认为 true。 */</span></span><br><span class="line">    <span class="comment">// &quot;suppressExcessPropertyErrors&quot;: false,            /* 关闭对象字面量的多余参数的报错。 */  </span></span><br><span class="line">    <span class="comment">// &quot;traceResolution&quot;: false,                         /* 控制是否在终端输出模块解析的步骤和决策过程 */ </span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<details class="toggle" ><summary class="toggle-button" style="">本贴参考</summary><div class="toggle-content"><p><a target="_blank" rel="noopener" href="https://wangdoc.com/typescript/">TypeScript 教程</a></p>
<p><a target="_blank" rel="noopener" href="https://wangdoc.com/es6/">ES6 教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html">The TypeScript Handbook</a></p>
</div></details>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Nasir1423">yiTuChuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zhengzehua.top/2024/12/05/TypeScript%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/">https://zhengzehua.top/2024/12/05/TypeScript%E6%95%99%E7%A8%8B@%E9%98%AE%E4%B8%80%E5%B3%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zhengzehua.top" target="_blank">川一土的博客视界</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/butterfly_avatar_img.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/21/word%20%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88@%E5%86%B0%E5%86%B7%E7%9A%84%E5%B8%8C%E6%9C%9B123/" title="📖word 论文排版@冰冷的希望123"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">📖word 论文排版@冰冷的希望123</div></div><div class="info-2"><div class="info-item-1">详细介绍 Word 论文排版的核心技巧，包括设置样式、多级列表、题注和交叉引用、三线表制作、参考文献插入、目录生成以及页码设置等内容，帮助读者快速掌握学术论文的规范化排版。</div></div></div></a><a class="pagination-related" href="/2024/11/30/TypeScript%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B@%E5%B0%9A%E7%A1%85%E8%B0%B7/" title="📖TypeScript 速通教程 @尚硅谷"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">📖TypeScript 速通教程 @尚硅谷</div></div><div class="info-2"><div class="info-item-1">快速上手 TypeScript 的核心知识，详细介绍 TS 的类型系统（基础类型、type、interface）、类与继承、泛型编程、装饰器模式等内容，并通过大量示例代码展示 TS 在实际开发中的应用。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E6%A6%82%E8%BF%B0"><span class="toc-text">TS - 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">TS - 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">1. 类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">2. 类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C"><span class="toc-text">3. 代码运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-tsc-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">3.1 tsc 编译器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-ts-node-%E6%A8%A1%E5%9D%97"><span class="toc-text">3.2 ts-node 模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-1%EF%BC%88%E7%89%B9%E6%AE%8A%E3%80%81%E5%9F%BA%E6%9C%AC%E3%80%81%E5%8C%85%E8%A3%85%E3%80%81Object%E3%80%81%E5%80%BC%E3%80%81%E8%81%94%E5%90%88%E3%80%81%E4%BA%A4%E5%8F%89%E3%80%81type%E3%80%81typeof%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%85%BC%E5%AE%B9%EF%BC%89"><span class="toc-text">TS - 类型系统 1（特殊、基本、包装、Object、值、联合、交叉、type、typeof、作用域、兼容）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-any"><span class="toc-text">1.1 any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-unknown"><span class="toc-text">1.2 unknown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-never"><span class="toc-text">1.3 never</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. 包装对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Object-object"><span class="toc-text">4. Object&#x2F;object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">5. 值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">6. 联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">7. 交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-type"><span class="toc-text">8. 类型别名 - type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97-typeof"><span class="toc-text">9. 类型运算 - typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7"><span class="toc-text">10. 类型作用域 - 块级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9"><span class="toc-text">11. 类型兼容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-2%EF%BC%88%E6%95%B0%E7%BB%84%E3%80%81%E5%85%83%E7%BB%84%E3%80%81symbol%EF%BC%89"><span class="toc-text">TS - 类型系统 2（数组、元组、symbol）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84"><span class="toc-text">1. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84"><span class="toc-text">1.2 只读数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%83%E7%BB%84"><span class="toc-text">2. 元组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">2.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8F%AA%E8%AF%BB%E5%85%83%E7%BB%84"><span class="toc-text">2.2 只读元组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-symbol"><span class="toc-text">3. symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.1 基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-unique-symbol"><span class="toc-text">3.2 unique symbol</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-3%EF%BC%88%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-text">TS - 类型系统 3（函数、对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0"><span class="toc-text">1. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Function"><span class="toc-text">1.2 Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0"><span class="toc-text">1.3 特殊参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="toc-text">参数解构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rest-%E5%8F%82%E6%95%B0"><span class="toc-text">rest 参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%8F%82%E6%95%B0"><span class="toc-text">只读参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E7%89%B9%E6%AE%8A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">1.4 特殊返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#void"><span class="toc-text">void</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#never"><span class="toc-text">never</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">1.5 函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1.6 构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="toc-text">2.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7"><span class="toc-text">2.2 特殊属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-text">索引签名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.3 结构类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%9C%80%E5%B0%8F%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">2.4 最小可选属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-4%EF%BC%88interface%E3%80%81%E7%B1%BB%EF%BC%89"><span class="toc-text">TS - 类型系统 4（interface、类）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-interface"><span class="toc-text">1. interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-3"><span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">1.2 接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%8E%A5%E5%8F%A3%E5%90%88%E5%B9%B6"><span class="toc-text">1.3 接口合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-interface-Vs-type"><span class="toc-text">1.4 interface Vs. type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB"><span class="toc-text">2. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-3"><span class="toc-text">2.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2 类的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.3 类的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">2.4 类的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2.5 可访问性修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E9%A1%B6%E5%B1%82%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">2.6 顶层属性的初始化问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">2.7 抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-this-%E4%B9%8B%E7%94%A8"><span class="toc-text">2.8 this 之用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-5%EF%BC%88%E6%B3%9B%E5%9E%8B%E3%80%81Enum%EF%BC%89"><span class="toc-text">TS - 类型系统 5（泛型、Enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B"><span class="toc-text">1. 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-4"><span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%AF%E9%80%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">1.2 可选的类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">1.3 类型参数的约束条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Enum"><span class="toc-text">2. Enum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-5"><span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Enum-%E5%90%88%E5%B9%B6"><span class="toc-text">1.2 Enum 合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="toc-text">1.3 反向映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Enum-%E6%8F%90%E5%8F%96"><span class="toc-text">1.4 Enum 提取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">TS - 类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-const-%E6%96%AD%E8%A8%80"><span class="toc-text">as const 断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80"><span class="toc-text">非空断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="toc-text">断言函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E6%A8%A1%E5%9D%97"><span class="toc-text">ES6 - 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0"><span class="toc-text">简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-text">模块语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AF%BC%E5%85%A5"><span class="toc-text">具名导出与导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AF%BC%E5%85%A5"><span class="toc-text">默认导出与导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%AF%BC%E5%85%A5"><span class="toc-text">整体导入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AF%BC%E5%87%BA"><span class="toc-text">重导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%B8%B8%E9%87%8F"><span class="toc-text">跨模块常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD"><span class="toc-text">运行时加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-text">模块元信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="toc-text">ES6 - 模块加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="toc-text">浏览器加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-js-%E5%8A%A0%E8%BD%BD"><span class="toc-text">Node.js 加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%8C%BA%E5%88%AB"><span class="toc-text">加载区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">入口配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E5%8A%A0%E8%BD%BD"><span class="toc-text">兼容加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%94%AF%E6%8C%81"><span class="toc-text">兼容支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-%E6%A8%A1%E5%9D%97%E5%8C%96-Vs-CommonJS-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">ES6 模块化 Vs. CommonJS 模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="toc-text">循环加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E6%A8%A1%E5%9D%97"><span class="toc-text">TS - 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-2"><span class="toc-text">简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95-2"><span class="toc-text">模块语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CommonJS-%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86"><span class="toc-text">CommonJS 模块处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%96%E8%AF%91"><span class="toc-text">类型编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%BD%8D"><span class="toc-text">模块定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E3%80%81%E9%9D%9E%E7%9B%B8%E5%AF%B9%E6%A8%A1%E5%9D%97"><span class="toc-text">相对、非相对模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Classic%E3%80%81Node-%E6%96%B9%E6%B3%95"><span class="toc-text">Classic、Node 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE"><span class="toc-text">路径映射配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0"><span class="toc-text">模块编译参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">TS - 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-text">命名空间合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E6%A0%87%E5%87%86%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-text">TS - 装饰器（标准语法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">简要介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">装饰器语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">类装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">方法装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">属性装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getter%E3%80%81setter-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">getter、setter 装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#accessor-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">accessor 装饰器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">装饰器的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E4%BC%A0%E7%BB%9F%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-text">TS - 装饰器（传统语法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95-2"><span class="toc-text">装饰器语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-2"><span class="toc-text">类装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8-2"><span class="toc-text">方法装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8-2"><span class="toc-text">属性装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E5%99%A8%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">存取器装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">参数装饰器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-2"><span class="toc-text">装饰器的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-declare-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">TS - declare 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-d-ts-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-text">TS - d.ts 类型声明文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-3"><span class="toc-text">简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%96%9C%E6%9D%A0%E5%91%BD%E4%BB%A4"><span class="toc-text">三斜杠命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">TS - 类型运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#keyof"><span class="toc-text">keyof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in"><span class="toc-text">in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends%E2%80%A6"><span class="toc-text">extends…?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#infer"><span class="toc-text">infer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is"><span class="toc-text">is</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">模版字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#satisfies"><span class="toc-text">satisfies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-text">TS - 类型映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0-4"><span class="toc-text">简要概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">映射修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%90%8D%E9%87%8D%E6%98%A0%E5%B0%84"><span class="toc-text">键名重映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">TS - 类型工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E6%B3%A8%E9%87%8A%E6%8C%87%E4%BB%A4"><span class="toc-text">TS - 注释指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E6%8C%87%E4%BB%A4"><span class="toc-text">注释指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-Doc"><span class="toc-text">JS Doc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-tsconfig-json"><span class="toc-text">TS - tsconfig.json</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By yiTuChuan</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.0-b2"></script><script src="/js/main.js?v=5.4.0-b2"></script><div class="js-pjax"><script>(() = {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs@6.4.4/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'Nasir1423/blog-comment',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/click-show-text.min.js" data-mobile="false" data-text="Prosperity,Democracy,Civility,Harmony,Freedom,Equality,Justice,Rule of Law,Patriotism,Dedication,Integrity,Friendliness" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>